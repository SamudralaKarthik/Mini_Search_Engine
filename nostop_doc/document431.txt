next prev Huffman Coding using Python Huffman coding lossless method compressing encoding text based frequency characters text. information theory computer science studies, Huffman code special type optimal prefix code that generally utilized lossless data compression. following tutorial, will going understand theory Huffman Coding along with implementation using Python programming language. that; understand Huffman Coding brief. Understanding Huffman Coding Huffman Coding Lossless Compression Algorithm that utilized data compression. algorithm developed David Huffman while Sc.D. Student Massachusetts Institute Technology (MIT) published year 1952 paper Method Construction Minimum-Redundancy Codes". part research into Computer Programming generally found programming languages like C++, Python, Java, JavaScript, Ruby, many more. thought process behind Huffman encoding follows: letter symbol that occurs often exemplified using shorter code, letter symbol that occurs infrequently exemplified using longer code. This thought leads efficient depiction characters that need less memory stored. Hence, conclude that Huffman coding data compression method. understand theory Huffman coding. Understanding Theory Huffman Coding know that file stored computer binary code that each character file been assigned binary character, character codes generally have fixed length distinct characters. Huffman coding established frequency with which each character file appears number characters data structure with frequency zero (0). Huffman encoding typical text file saves around percent size actual data. Huffman binary code, like compiled executables, would thus have distinct space-saving. binary file which ASCII character encoded with frequency would have very different frequency distribution from ASCII equivalent. order compress file using sequence characters, require table that provides with sequences bits utilized each character. This table generates encoding tree that utilizes root/leaf path order create sequence that encodes characters. follow roots leaves create list characters with maximum length encoded characters number occurrences. greedy algorithm order construct optimal tree. Huffman encoding trees return minimum length character encodings utilized compressing data. nodes tree depict frequency occurrence character. root node depicts length string, traversing tree provides with encodings specified character. Once tree constructed, traversing tree provides with respective codes each symbol. optimal tree upon completion shown following table image: Character Frequency develop implement program that utilizes Huffman coding following section. Huffman Code Implementation using Python will start creating class Nodes, referred nodes Binary Huffman Tree. Essentially, each node consists symbol associated probability variable, left right child, code variable. Code variable will either depending side choose (left right while traveling through Huffman Tree. consider following snippet code demonstrating same: Example: Node Huffman Tree class Nodes: __init__(self, probability, symbol, left None, right None): probability symbol self.probability probability symbol self.symbol symbol left node self.left left right node self.right right tree direction self.code Explanation: above snippet code, have defined class Nodes initialized some parameters probability, symbol, left, right. have initially values left right variables None direction defined yet. last, have also initialized code variable. Now, will some supporting functions. first function calculate probabilities symbols provided data. second function obtain encodings symbols that will once have Huffman Tree. last function obtain result (encoded data). Example: supporting function order calculate probabilities symbols specified data CalculateProbability(the_data): the_symbols dict() item the_data: the_symbols.get(item) None: the_symbols[item] else: the_symbols[item] return the_symbols supporting function order print codes symbols travelling Huffman Tree the_codes dict() CalculateCodes(node, value ''): huffman code current node newValue value str(node.code) if(node.left): CalculateCodes(node.left, newValue) if(node.right): CalculateCodes(node.right, newValue) if(not node.left node.right): the_codes[node.symbol] newValue return the_codes supporting function order encoded result OutputEncoded(the_data, coding): encodingOutput element the_data: print(coding[element], encodingOutput.append(coding[element]) the_string ''.join([str(item) item encodingOutput]) return the_string Explanation: above snippet code, have defined three different helper functions order calculate probabilities symbols given data, obtain encoding symbols, obtain result. first function, have defined dictionary the_symbols iterate through items given data using for-loop insert them into dictionary. have also used if-else conditional statement check data contains some element perform operation accordingly. second function, have defined another dictionary the_codes. Within function, have assigned variable storing Huffman code current node used conditional statements nodes left right with current node return symbols encoding. last function, have created empty array. have then used for-loop iterating through characters data append() function data array. have then used join() function join elements from array string returned string. Moreover, will also define another function TotalGain, which accepts initial data dictionary coming from CalculateCode, holding symbols their codes together. That function will help calculate difference between size compressed non-compressed data. consider following snippet code demonstrating same: Example: supporting function order calculate space difference between compressed compressed data""" TotalGain(the_data, coding): total space store data before compression beforeCompression len(the_data) afterCompression the_symbols coding.keys() symbol the_symbols: the_count the_data.count(symbol) calculating many required that symbol total afterCompression the_count len(coding[symbol]) print("Space usage before compression bits):", beforeCompression) print("Space usage after compression bits):", afterCompression) Explanation: above snippet code, have defined function. calculated total space store data before compression. have then defined variable store space size after data compression assigned zero. have then iterated through keys from dictionary from CalculateCode function counted their occurrences. have then calculated space that requires store data after compression. will HuffmanEncoding function, which accepts only data argument returns resulting encoding total gain using above-described functions. understand same using following snippet code: Example: HuffmanEncoding(the_data): symbolWithProbs CalculateProbability(the_data) the_symbols symbolWithProbs.keys() the_probabilities symbolWithProbs.values() print("symbols: the_symbols) print("probabilities: the_probabilities) the_nodes converting symbols probabilities into huffman tree nodes symbol the_symbols: the_nodes.append(Nodes(symbolWithProbs.get(symbol), symbol)) while len(the_nodes) sorting nodes ascending order based their probability the_nodes sorted(the_nodes, lambda x.probability) node nodes: print(node.symbol, node.prob) picking smallest nodes right the_nodes[0] left the_nodes[1] left.code right.code combining smallest nodes create node newNode Nodes(left.probability right.probability, left.symbol right.symbol, left, right) the_nodes.remove(left) the_nodes.remove(right) the_nodes.append(newNode) huffmanEncoding CalculateCodes(the_nodes[0]) print("symbols with codes", huffmanEncoding) TotalGain(the_data, huffmanEncoding) encoded_output OutputEncoded(the_data,huffmanEncoding) return encoded_output, the_nodes[0] Explanation: above snippet code, used data argument, calculated probability symbols using CalculateProbability function, stored resulting data variable. have then extracted symbols (keys) probabilities (values) printed them users. have then defined array the_nodes converted symbols probabilities into nodes Huffman tree. have used for-loop iterating through symbols appending them array. have also used while loop order sort nodes ascending order based their probabilities. selected smallest nodes combined them create node. removed smallest nodes from array added node have then used CalculateCodes function calculate code Huffman encoding print symbols with codes users. have also used TotalGain function, providing required parameters calculate difference between space compressed non-compressed data. last, have printed result returned encodedOutput zeroth index array. Now, will define function order decode Huffman Encoded data obtaining initial, uncompressed data again which quite simple process. consider following snippet code demonstrating process decoding Huffman Encoded data. Example: HuffmanDecoding(encodedData, huffmanTree): treeHead huffmanTree decodedOutput encodedData: '1': huffmanTree huffmanTree.right elif '0': huffmanTree huffmanTree.left try: huffmanTree.left.symbol None huffmanTree.right.symbol None: pass except AttributeError: decodedOutput.append(huffmanTree.symbol) huffmanTree treeHead string ''.join([str(item) item decodedOutput]) return string Explanation: above snippet code, have defined function HuffmanDecoding that accepts parameters encodedData huffmanTree. have then assigned huffmanTree variable another variable. have also defined empty array decodedOutput. have then used for-loop iterate through elements encoded data. Within loop, have used if-elif-else conditional statement try-exception method order decode encoded data append each decoded element generate decoded output. last, have created string returned string users. Now, initialize string data print results. Example: the_data "AAAAAAABBCCCCCCDDDEEEEEEEEE" print(the_data) encoding, the_tree HuffmanEncoding(the_data) print("Encoded output", encoding) print("Decoded Output", HuffmanDecoding(encoding, the_tree)) Explanation: above snippet code, have defined string data printed users. passed this data HuffmanEncoding function stored values encoding the_tree variables. have then printed Encoded result users. last, have passed encoded data HuffmanDecoding function printed decoded string. complete project before execution. Complete Project Code complete Python project code Huffman coding. File: huffmanAlgo.py Node Huffman Tree class Nodes: __init__(self, probability, symbol, left None, right None): probability symbol self.probability probability symbol self.symbol symbol left node self.left left right node self.right right tree direction self.code supporting function order calculate probabilities symbols specified data CalculateProbability(the_data): the_symbols dict() item the_data: the_symbols.get(item) None: the_symbols[item] else: the_symbols[item] return the_symbols supporting function order print codes symbols travelling Huffman Tree the_codes dict() CalculateCodes(node, value ''): huffman code current node newValue value str(node.code) if(node.left): CalculateCodes(node.left, newValue) if(node.right): CalculateCodes(node.right, newValue) if(not node.left node.right): the_codes[node.symbol] newValue return the_codes supporting function order encoded result OutputEncoded(the_data, coding): encodingOutput element the_data: print(coding[element], encodingOutput.append(coding[element]) the_string ''.join([str(item) item encodingOutput]) return the_string supporting function order calculate space difference between compressed compressed data""" TotalGain(the_data, coding): total space store data before compression beforeCompression len(the_data) afterCompression the_symbols coding.keys() symbol the_symbols: the_count the_data.count(symbol) calculating many required that symbol total afterCompression the_count len(coding[symbol]) print("Space usage before compression bits):", beforeCompression) print("Space usage after compression bits):", afterCompression) HuffmanEncoding(the_data): symbolWithProbs CalculateProbability(the_data) the_symbols symbolWithProbs.keys() the_probabilities symbolWithProbs.values() print("symbols: the_symbols) print("probabilities: the_probabilities) the_nodes converting symbols probabilities into huffman tree nodes symbol the_symbols: the_nodes.append(Nodes(symbolWithProbs.get(symbol), symbol)) while len(the_nodes) sorting nodes ascending order based their probability the_nodes sorted(the_nodes, lambda x.probability) node nodes: print(node.symbol, node.prob) picking smallest nodes right the_nodes[0] left the_nodes[1] left.code right.code combining smallest nodes create node newNode Nodes(left.probability right.probability, left.symbol right.symbol, left, right) the_nodes.remove(left) the_nodes.remove(right) the_nodes.append(newNode) huffmanEncoding CalculateCodes(the_nodes[0]) print("symbols with codes", huffmanEncoding) TotalGain(the_data, huffmanEncoding) encodedOutput OutputEncoded(the_data,huffmanEncoding) return encodedOutput, the_nodes[0] HuffmanDecoding(encodedData, huffmanTree): treeHead huffmanTree decodedOutput encodedData: '1': huffmanTree huffmanTree.right elif '0': huffmanTree huffmanTree.left try: huffmanTree.left.symbol None huffmanTree.right.symbol None: pass except AttributeError: decodedOutput.append(huffmanTree.symbol) huffmanTree treeHead string ''.join([str(item) item decodedOutput]) return string the_data "AAAAAAABBCCCCCCDDDEEEEEEEEE" print(the_data) encoding, the_tree HuffmanEncoding(the_data) print("Encoded output", encoding) print("Decoded Output", HuffmanDecoding(encoding, the_tree)) Output: AAAAAAABBCCCCCCDDDEEEEEEEEE symbols: dict_keys(['A', 'B', 'C', 'D', 'E']) probabilities: dict_values([7, symbols with codes {'E': '00', 'A': '01', 'C': '10', 'D': '110', 'B': '111'} Space usage before compression bits): Space usage after compression bits): Encoded output 01010101010101111111101010101010110110110000000000000000000 Decoded Output AAAAAAABBCCCCCCDDDEEEEEEEEE Next TopicNested Dictionary Python prev next