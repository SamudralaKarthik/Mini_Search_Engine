next prev Python Itertools Itertool most amazing Python standard libraries. This library pretty much coolest functions nothing wrong that gem Python programing language. Python provides excellent documentation itertools this tutorial, will discuss important useful functions iterators itertools. thing about itertools that functions this library used make memory-efficient precise code. Before learning Python itertools, should have knowledge Python iterator generators. this article, will describe itertools beginners well professionals. Introduction According official definition itertools, "this module implements number iterator building blocks inspired constructs from APL, Haskell, SML." simple words, number iterators together create 'iterator algebra' which makes possible complete complex task. functions itertools used produce more complex iterators. Let's take example: Python built-in zip() function accepts number arguments iterable. iterates over tuples return their corresponding elements. [1,2,3] ['a', 'b', 'c'] zip(a,b) print(c) Output: [(1, 'a'), 'b'), 'c')] above code, have passed lists [1,2,3] ['a', 'b', 'c'] iterable zip() function. These lists return element time. Python, element that implement .__iter__() .__getitem__() method called iterable. Python iter() function used call iterable return iterator object iterable. iter('Hello') print(a) Output: <str_iterator object 0x01505FA0> Python zip() function calls iter() each argument then calls next() combining result into tuple. Note: using zip() function map() function that means already using itertools. don't need import distinctly. Types Iterator There various types iterator itertools module. list given below: Infinite iterators Combinatoric iterators Terminating iterators Infinite Iterators Python, object that implement loop called iterators. Lists, tuples, set, dictionaries, strings example iterators iterator also infinite this type iterator called infinite iterator. Iterator Argument Results count(start,step) start, [step] start, start+step, step+2*step cycle() p0,p1,….plast repeat() elem [,n] elem, elem, elem,….endlessly upto times count(start, stop): prints from start value infinite. step argument optional, value provided step then number steps will skipped. Consider following example: import itertools itertools.count(10,5): 50: break else: print(i,end=" Output: cycle(iterable): This iterator prints value sequence from passed argument. prints values cyclic manner. Consider following example: import itertools temp itertools.cycle("123"): temp break else: print(i,end=' temp temp+1 Output: Example Using next() function import itertools ['Java', 'T', 'Point'] iter itertools.cycle(val) range(6): Using next function print(next(iter), Output: Java Point Java Point repeat(val,num): name suggests, repeatedly prints passed value infinite time. argument optional. Consider following example: import itertools print("Printing number repeadtly:") print(list(itertools.repeat(40,15))) Output: [40, Combinatoric iterators: complex combinatorial constructs simplified recursive generators. permutations, combinations, Cartesian products example combinatoric construct. Python, there four types combinatoric iterators: Product() used calculate cartesian product input iterable. this function, optional repeat keyword argument computation product iterable with itself. repeat keyword represents number repetitions. returns output form sorted tuples. Consider following example: from itertools import product print("We computing cartesian product using repeat Keyword Argument:") print(list(product([1, repeat=2))) print() print("We computing cartesian product containers:") print(list(product(['Java', 'T', 'point'], '5'))) print() print("We computing product containers:") print(list(product('CD', 5]))) Output: Computing cartesian product using repeat Keyword Argument: [(1, Computing cartesian product containers: [('Java', '5'), ('T', '5'), ('point', '5')] Computing product containers: [('C', ('C', ('D', ('D', Permutations(): used generate possible permutation iterable. uniqueness each element depends upon their position instead values. accepts argument iterable group_size. value group_size none specified then group_size turns into length iterable. from itertools import permutations print("Computing permutation following list") print(list(permutations([3,"Python"],2))) print() print("Permutations following string") print(list(permutations('AB'))) print() print("Permutation given container is:") print(list(permutations(range(4),2))) Output: Computing permutation following list [(3, 'Python'), ('Python', Permutations following string [('A', 'B'), ('B', 'A')] Permutation given container [(0, Combinations(): used print possible combinations (without replacement) container which passed argument specified group size sorted order. from itertools import combinations print("Combination list sorted order(without replacement)",list(combinations(['B',3],2))) print() print("Combination string sorted order",list(combinations("ZX",2))) print() print("Combination list sorted order",list(combinations(range(20),1))) Output: Combination list sorted order(without replacement) [('B', Combination string sorted order [('Z', 'X')] Combination list sorted order [(0,), (1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,)] Combination_with_replacement(): accepts arguments, first argument r-length tuple second argument repetition. returns subsequence length from elements iterable repeat same process. Separate elements repeat itself combination_with_replacement() from itertools import combinations_with_replacement print("Combination string sorted order(with replacement) is:") print(list(combinations_with_replacement("XY", 3))) print() print("Combination list sorted order(with replacement) is:") print(list(combinations_with_replacement([4, 3))) print() print("Combination container sorted order(with replacement) is:") print(list(combinations_with_replacement(range(3), 2))) Output: Combination string sorted order(with replacement) [('X', 'X', 'X'), ('X', 'X', 'Y'), ('X', 'Y', 'Y'), ('Y', 'Y', 'Y')] Combination list sorted order(with replacement) [(4, Combination container sorted order(with replacement) [(0, Terminating Iterator Terminating iterators generally used work small input sequence generate output based functionality method used iterator. There different types terminating iterator: accumulate(iter, func): takes arguments, first argument iterable second function which would followed each iteration value iterable. function defined accumulate() iterator, addition takes place default. output iterable depends input iterable; input iterable contains value then output iterable will also empty. import itertools import operator initializing list list1 using accumulate() that will prints successive summation elements print("The end="") print(list(itertools.accumulate(list1))) using accumulate() that will prints successive multiplication elements print("The product end="") print(list(itertools.accumulate(list1, operator.mul))) using accumulate() that will prints successive summation elements print("The end="") print(list(itertools.accumulate(list1))) using accumulate() that will prints successive multiplication elements print("The product end="") print(list(itertools.accumulate(list1, operator.mul))) Output: product 140, 1260, 13860] product 140, 1260, 13860] chain(iter1, iter2) used print values iterable passed form chain declared arguments. Consider following example: import itertools declaring list list1 declaring list list2 declaring list list3 using chain() function that will print elements lists print("The output end="") print(list(itertools.chain(list1, list2, list3))) Output: output dropwhile(func, seq) starts printing character only after func. Consider following argument: import itertools initializing list list1 using dropwhile() iterator that will print start displaying after condition false print("The output end="") print(list(itertools.dropwhile(lambda list1))) Output: output filterfalse(func,seq) assume name, this iterator prints only those values that return false passed function. Consider following example: import itertools declaring list list1 [12, using filterfalse() iterator that will print false values print("The Output end="") print(list(itertools.filterfalse(lambda list1))) Output: Output [15, islice(iterable,start,stop,step) slices given iterable according given position. accepts four arguments respectively these iterable, container, starting pos., ending position step(optional). import itertools Declaring list list1 [12, using islice() iterator that will slice list acc. given argument starts printing from 3nd index till 8th skipping print("The sliced list values end="") print(list(itertools.islice(list1, 2))) Output: sliced list values [34, starmap(func, tuple list) takes arguments; first argument function second argument list which consists element form tuple. Consider following example. import itertools Declaring list that contain tuple element list1 [(10, 15), (18, 19), (53, 90), (16, 27)] using starmap() iterator selection value acc. function selects tuple values print("The values acc. function end="") print(list(itertools.starmap(max, list1))) Output: values acc. function [20, takewhile(func, iterable) visa-versa dropwhile(). will print values until returns false condition. Consider following example: import itertools Defining list list1 [20, takewhile() iterator used print values till condition return false. print("Print until false value returned end="") print(list(itertools.takewhile(lambda list1))) Output: list values until false value return [20, tee(iterator, count) divides container into number iterators which defined argument. Consider following example: import itertools Declaring list li storing list iterator iti iter(li) using tee() iterator create list iterators Creating list iterators having similar values. itertools.tee(iti, will print object iterator print(it) print("The iterators range(0, print(list(it[i])) Output: (<itertools._tee object 0x01B88D88>, <itertools._tee object 0x01B88DA8>, <itertools._tee object 0x01B88BA8>) iterators zip_longest(iterable1, iterable2, fillval) prints values iterable alternatively sequence. iterable prints values, remaining values filled values assigned fill value. import itertools print(" combined value iterrables print(*(itertools.zip_longest('Java', 'Tpoint', fillvalue='_'))) Output: combined value iterables ('J', 'T') ('a', 'p') ('v', 'o') ('a', 'i') ('_', 'n') ('_', 't') this tutorial, have discussed several useful iterators along with itertools. Next TopicPython Multiprocessing prev next