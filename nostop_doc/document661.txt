next prev K-means clustering Python this article, K-means clustering 1D?will main topic. introduce technique illustrate idea, basic implementation 1D?will used. notion will expanded dimensions following post. This article will concentrate just technique under discussion also underlying code this case, Python. That this post about K-means clustering much about Python, maybe even programming general. order accomplish this, will line line through associated code comprehend just what doing also why. Create centroids assign each cluster. Each data point should matched with closest centroid. Recalculate each cluster's centroid after each point been assigned cluster depending close cluster centroids. predetermined number iterations, until centroids stop changing, repeat steps 2-3. Although one-dimensional data isn't typically used K-means clustering, makes very straightforward example that shows process functions. purpose this post demonstrate Python display K-means clustering dimension, indicated title. Programme This particular script aims clarity above brevity, some knowledge with Python least programming anticipated, although most information will detailed depth below. Both Python Python should compatible with script, which also needs numpy matplotlib packages installed. Okay, let's going. Create file called kmeans1D_demo.py your preferred text editor then start following instructions. import numpy import matplotlib.pyplot import colorsys import centroids computing nmbrClusters actual clusters that generated pntsPerCluster points actual cluster xCntrBounds (-2, limits within which actual cluster centers placed clusters we'll actually create, each containing pntsPerCluster points, nmbrClusters. (min, max) values provided xCntrBounds will used position centres these clusters ("x" dimension one-dimensional example). "K-means" stands no.?of centroids, clusters, that want algorithm search for. Keep mind that algorithm looks different clusters than actually produce. This actually crucial point; this instance, actively create data clusters before allowing K-means algorithm have crack However, won't typically producing data real world. will and/or K-means algorithm decide many clusters data needs divided into, i.e., what value select, since won't know precisely many clusters exist, any. best value found using several techniques; however, we'll cover those more detail later. Randomly placing cluster centers within area xCntrBounds. centers np.random.random_sample((nmbrClusters,)) centers centers (xCntrBounds[1] xCntrBounds[0]) xCntrBounds[0] Initializing array data pts. points np.zeros((nmbrClusters pntsPerCluster,)) Normally distributing pntsPerCluster points around each center. stDev 0.15 range(nmbrClusters): points[i*pntsPerCluster:(i+1)*pntsPerCluster] stDev np.random.randn(pntsPerCluster) centers[i]) order create array random floats range [0.0, 1.0], chosen from continuous uniform distribution, first uses random sample function random module Numpy contrast normal distribution). next line converts these elements from [0.0, 1.0] range xCntrBounds range. These variables serve centres point clusters that we'll create, which accomplished following section code (every iteration loop here generating cluster points storing them different points). this, numpy function randn(), which pulls from normal distribution, construct standard deviation, stDev. points will spread stDev's value increases, whereas decrease value will result clusters that closer together. Play with this observe affects algorithm's capacity distinguish across clusters. Selecting points randomly initial centroid locations. centroids np.zeros((K,)) indices while len(indices) index np.random.randint(0, nmbrClusters pntsPerCluster) index indices: indices.append(index) centroids points[indices] Assigning each point closest centroid then Storing this classifications, where every single element must ranging from K-1. classifications np.zeros((points.shape[0],), dtype=np.int) assignPntsToCentroids(): range(points.shape[0]): smallestDist range(K): distance abs(points[i] centroids[k]) smallestDist distance classifications[i] elif distance smallestDist: smallestDist distance classifications[i] assignPntsToCentroids() There numerous strategies determining initial positions centroids. This significant since result depends starting locations choose. given data clustered variety ways. K-means method merely ensures that will solution ("local optimum"), necessarily optimal answer (the "global optimum"). Nevertheless, general rule, selecting distinct points random from data collection using those initial centroid locations decent technique establish centroid locations. selecting distinct indices from points array saving values such indices centroids array, this achieved. will update centroids with updated centroid locations after each algorithm iteration. Finally, using function "assignPntsToCentroids()", will assign each point collection cluster whose centroid closest other words, will iterate through points and, each point, find which centroids centroids that point closest then hold index pertaining that centroid/cluster array classifications (since "classifying" point belonging clusters).?A point points equivalent each categorization element. This means that classifications[3] fourth point, points[3], nearest centroid whom location indicated centroids[0]. built-in absolute value method?abs()?can used calculate path?between given point particular centroid because this example only involves dimension. Once we've defined method assignPntsToCentroids(), call once cluster points according initial centroid coordinates that already centroids. Defining func recalculatinge cluster's centroid reCalcCentroids(): range(K): sum(classifications centroids[k] sum(points[classifications sum(classifications other component process recalculate centroid location each cluster, this section program defines function called reCalcCentroids() that does sum(classifications first determine whether points have actually been awarded each cluster. components least then least point allocated that cluster. comparative statement classifiers returns array with indices where the?classifications represents where doesn't. next sentence divides total no.?of points cluster calculate centroid. Division zero avoided ensuring that cluster contains least point. Using color scheme, generating different color each cluster. Simultaneously, initializing matplotlib line objects every centroid their cluster. hues np.linspace(0, K+1)[:-1] fig, plt.subplots() clusterPntsList centroidPntsList range(K): clusterColor tuple(colorsys.hsv_to_rgb(hues[k], 0.8, 0.8)) clusterLineObj, ax.plot([], ls='None', marker='x', color=clusterColor) clusterPntsList.append(clusterLineObj) centroidLineObj, ax.plot([], ls='None', marker='o', markeredgecolor='k', color=clusterColor) centroidPntsList.append(centroidLineObj) iterText ax.annotate('', xy=(0.01, 0.01), xycoords='axes fraction') Since purpose this lesson display algorithm, each cluster should represented different colour. Utilizing colour space, which organises colours according hue, saturation, brightness value, clever approach accomplish this arbitrary clusters. cone/cylinder used symbolise these properties. round cylinder, colour changes. represented 0°, green 120°, blue 240°, returning 360°. float from represents range 0°-360° Python colorsys module. Then, using final number, split spectrum into K+1 equally distanced values different colours. This fact that first last numbers will both which colour space represents colour red. Then, pyplot function subplots() generate figure with axis. This function will return handles figure axis objects, allowing subsequently obtain alter properties figure axis. would like plot every cluster centroid separate colour order visualise process. Additionally, should able update every cluster following algorithm iteration. accomplish this, we'll for-loop execute plot() function axis each cluster centroid. This will initialise empty matplotlib line object each cluster centroid. essence, plot() "line object" axis axe every clusters. arguments supply plot() determine characteristics line object. coordinates points want depict first arguments plot() function. With ax.plot([], [],...), initialise line without data supplying empty arrays. linestyle determined keyword parameter ls; matplotlib informed that wish plot points without even connecting line ls='None'. marker style determined keyword argument marker. matplotlib colour specification used keyword argument colour. Here, we're using colorsys method hsv_to_rgb create tuple from colours(Note that colorsys used demonstrate that Python already built-in package handle this capability; matplotlib also includes colours module, matplotlib.colors, which could also convert RGB). order later change aforementioned properties, plot() outputs handle line object just constructed. course, whenever wish update plot, must able access this line object handles afterwards. order accomplish this, cluster centroid line object handles corresponding lists, clusterPntsList centroidPntsList. This keeps track items from for-loop even after loop ended. plot's lower left corner then annotated with blank line text. This text will used show many iterations algorithm gone through, we'll update using handle, which I've named iterText. Defining func updating plot. updatePlot(iteration): range(K): xDataNew points[classifications clusterPntsList[k].set_data(xDataNew, np.zeros((len(xDataNew),))) centroidPntsList[k].set_data(centroids[k], iterText.set_text('i {:d}'.format(iteration)) plt.savefig('./{:d}.png'.format(iteration)) plt.pause(0.5) dataRange np.amax(points) np.amin(points) ax.set_xlimt(np.amin(points) 0.05*dataRange, np.amax(points) 0.05*dataRange) ax.set_ylimt(-1, iteration updatePlot(iteration) plt.ion() plt.show() Just simple function, required update plot throughout each iteration algorithm. value iterText annotation updatePlot() function using input, current iteration. function first determines which points part each cluster using that information data line object belonging that cluster (which obtains from clusterPntsList). array coordinates other?array coordinates inputs that data() function requires. values irrelevant because this 1D?example, them Note that since specified line object colours marker styles when generated line objects, don't need bother about doing now. only supply single value single value data() method centroid line object since every?cluster only centroid value. plot then saved image using savefig() method. This will happen each iteration of?while loop that we'll animate algorithm. animation will then turned into video using photos. don't want save photographs animation, comment this line. NOTE USING WHILE LOOP USING ANIMATION MATPLOTLIB ANIMATE VIDEOS RECOMMENDED. When using while loop animate objects Matplotlib possible, recommended. This better accomplished with animation module matplotlib. Additionally pointless, matplotlib.animation module already performs task manually producing video saving individual frames. addition, would like show it's done "hard way" before showing it's done correctly. Returning present code; order guarantee that data points will shown, next specify axis bounds plot. updatePlot() function, which previously defined, then used initialise plot. Afterward, activate Plt.ion() method's interactive charting. Ironically, allowing remainder code continue running while plot open, this enables continuously update plot without user intervention. Finally, actually display plot, call plt.show() required. Executing animating algorithm using while loop. Which isn't best considered animating matplotlib plot rather matplotlib animation module should taken into consideration, using while loop here making easy understand. last_Centroids centroids while np.array_equal(centroids, last_Centroids): last_Centroids np.copy(centroids) reCalcCentroids() assignPntsToCentroids() iteration updatePlot(iteration) pythonMajorVersion sys.version_info[0] pythonMajorVersion raw_input("Press Enter continue.") else: input("Press Enter continue.") Finally, algorithm into action. When centroid positions stop shifting, condition been satisfied. ensure while loop runs least once, construct array last_Centroids initialise with random values that differ from centroids. other words, were using last_Centroids centroids, last_Centroids centroids will indeed point same object, modifying would modify other, since they both point same object, they will always equal, meaning loop would only execute once. Take note that np.copy() instead last_Centroids centroids because that would point rather than create copy It's crucial aware this peculiarity numpy arrays. check results after running script. executing more than once observe effects various centroid initializations outcomes. Play with settings experimenting with different values, cluster densities, cluster standard deviations. Complete Code: import numpy import matplotlib.pyplot import colorsys import centroids computing nmbrClusters actual clusters that generated pntsPerCluster points actual cluster xCntrBounds (-2, limits within which actual cluster centers placed Randomly placing cluster centers within area xCntrBounds. centers np.random.random_sample((nmbrClusters,)) centers centers (xCntrBounds[1] xCntrBounds[0]) xCntrBounds[0] Initializing array data pts. points np.zeros((nmbrClusters pntsPerCluster,)) Normally distributing pntsPerCluster points around each center. stDev 0.15 range(nmbrClusters): points[i*pntsPerCluster:(i+1)*pntsPerCluster] stDev np.random.randn(pntsPerCluster) centers[i]) Selecting points randomly initial centroid locations. centroids np.zeros((K,)) indices while len(indices) index np.random.randint(0, nmbrClusters pntsPerCluster) index indices: indices.append(index) centroids points[indices] Assigning each point closest centroid then Storing this classifications, where every single element must ranging from K-1. classifications np.zeros((points.shape[0],), dtype=np.int) assignPntsToCentroids(): range(points.shape[0]): smallestDist range(K): distance abs(points[i] centroids[k]) smallestDist distance classifications[i] elif distance smallestDist: smallestDist distance classifications[i] assignPntsToCentroids() Defining func recalculatinge cluster's centroid reCalcCentroids(): range(K): sum(classifications centroids[k] sum(points[classifications sum(classifications Using color scheme, generating different color each cluster. Simultaneously, initializing matplotlib line objects every centroid their cluster. hues np.linspace(0, K+1)[:-1] fig, plt.subplots() clusterPntsList centroidPntsList range(K): clusterColor tuple(colorsys.hsv_to_rgb(hues[k], 0.8, 0.8)) clusterLineObj, ax.plot([], ls='None', marker='x', color=clusterColor) clusterPntsList.append(clusterLineObj) centroidLineObj, ax.plot([], ls='None', marker='o', markeredgecolor='k', color=clusterColor) centroidPntsList.append(centroidLineObj) iterText ax.annotate('', xy=(0.01, 0.01), xycoords='axes fraction') Defining func updating plot. updatePlot(iteration): range(K): xDataNew points[classifications clusterPntsList[k].set_data(xDataNew, np.zeros((len(xDataNew),))) centroidPntsList[k].set_data(centroids[k], iterText.set_text('i {:d}'.format(iteration)) plt.savefig('./{:d}.png'.format(iteration)) plt.pause(0.5) dataRange np.amax(points) np.amin(points) ax.set_xlimt(np.amin(points) 0.05*dataRange, np.amax(points) 0.05*dataRange) ax.set_ylimt(-1, iteration updatePlot(iteration) plt.ion() plt.show() Executing animating algorithm using while loop. Which isn't best considered animating matplotlib plot rather matplotlib animation module should taken into consideration, using while loop here making easy understand. last_Centroids centroids while np.array_equal(centroids, last_Centroids): last_Centroids np.copy(centroids) reCalcCentroids() assignPntsToCentroids() iteration updatePlot(iteration) pythonMajorVersion sys.version_info[0] pythonMajorVersion raw_input("Press Enter continue.") else: input("Press Enter continue.") Output Next TopicAdding key:value pair dictionary Python prev next