next prev What Python? Global Interpreter Lock This tutorial will focused important Python's topics, GIL. will also cover impacts Python programs' performance with code implementation. Before diving into this topic, let's have basic idea GIL. Global Interpreter Lock Python Global Interpreter Lock important part multithreading programming. type process lock used when working with multiple processes. gives control only thread. Generally, Python uses single thread single process. same performance result single-threaded multi-threaded processes using GIL. restricts achieving multithreading Python because prevents threads works single thread. Note Python doesn't support multithreading because threading packages couldn't multiple cores. Python Developers Uses GIL? Python provides unique reference counter feature, which used memory management. reference counter counts total number references made internally Python assign value data object. When reference counts reach zero, assigned memory object released. Let's below example. Example import sys.getrefcount(a) main concern with reference count variable that affected when three threads trying increase decrease value simultaneously. known race condition. this condition occurs, caused leaked memory that never released. crash bugs Python program. helps remove such situation using locks shared data structures across threads that they changed inconsistently. Python provides easy implement deals with thread-safe memory management. requires offering single lock thread processing Python. increases performance single-threaded program only lock requires handled. also helps make CPU-bound program prevents deadlocks condition. Impact Multi-threaded Python Programs There difference between CPU-bounds their performance bound typical Python program computer program. CPU-bound programs generally pushed limits. These programs generally used mathematical computation such matrix multiplications, searing, image processing, etc. bound programs those programs that spend time input/output that generated user, file, database, network, etc. Such programs have wait some significant amount time until source provides input. other hand, source also processing time. example user thinking about what enter input. Let's understand following example. Example import time from threading import Thread COUNT 100000000 countdown(num): while num>0: start_time time.time() countdown(COUNT) end_time time.time() print('Time taken seconds end_time start_time) Output: Time taken seconds 7.422671556472778 modify above code running threads. Example import time from threading import Thread COUNT 100000000 countdown(num): while num>0: thread1 Thread(target=countdown, args=(COUNT//2,)) thread2 Thread(target=countdown, args=(COUNT//2,)) start_time time.time() thread1.start() thread2.start() thread1.join() thread2.join() end_time time.time() print('Time taken seconds end_time start_time) Output: Time taken seconds 6.90830135345459 that both codes took same time finish. prevented CPU-bound threads from executing parallel second code. Hasn't Been Removed Yet? Many programmers have complaint regarding this, Python cannot bring changes significant removal GIL. Another reason that improved now. changes Python will create some serious issues. Instead removing GIL, concept improve. According Guido Rossom "I'd welcome patches into Py3k only performance single-threaded program (and multi-threaded I/O-bound program) does decrease". There also many methods available that solve same problem solved GIL, there hard implement. Deal with Python's Using multiprocessing most suitable prevent program from GIL. Python offers various interpreters each process run, that scenario, single thread provided each process multiprocessing. Let's understand following example. Example from multiprocessing import Pool import time COUNT 50000000 countdown(num): while num>0: __name__ '__main__': pool Pool(processes=2) start_time time.time() pool.apply_async(countdown, [COUNT//2]) pool.apply_async(countdown, [COUNT//2]) pool.close() pool.join() end_time time.time() print('Time taken seconds end_time start_time) Output: Time taken seconds 3.3707828521728516 seem decent performance increased process management overheads multiple processes heavier than multiple threads. Conclusion this tutorial, have discussed gives control single thread execute time. This tutorial also covered important Python programmers. Next TopicBasic Python Java Developers prev next