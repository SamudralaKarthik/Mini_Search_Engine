next prev Customizing Parser Behaviour Python Module 'configparser.' Utilize ConfigParser module oversee user documents files apps. document format coordinated into segments; each part contain key-value matches coordinated data. Key-value interjection utilizing Python formatting strings technique likewise upheld fabricate values that rely upon each other (this particularly helpful URLs message strings). document format utilized ConfigParser like arrangement utilized more established adaptations Microsoft Windows. comprises least named area, every which contain individual choices with names values. Config document segments recognized searching lines beginning with. worth between square sections segment name contain characters with exception square sections. Customizing Parser Behavior There nearly many design format variations apps utilizing Python module configparser goes quite offer help biggest reasonable arrangement styles accessible. verifiable foundation chiefly directs default usefulness, almost certainly, will need tweak portion highlights. most well-known method having impact particular config parser works utilize __init__() function choices: Defaults, default value: None This choice acknowledges word reference key-values matches, which will first placed DEFAULT segment. This makes rich method supporting compact setup records that don't indicate values equivalent reported default. Here's clue: need determine default values particular segment, read_dict() function before read genuine record. dict_type, default values: dict This wide range options impacts mapping protocol works future what configuration files will look. With standard word reference, each segment away request they were added parser. same goes choices inside segments. alternative type utilized instead dictionary, instance, sort segments choices write-back. it's much trouble, note: there ways adding bunch pair value matches solitary activity. point when utilize standard word reference those tasks, request keys will requested. instance: Python console screen: parser_ configparser_.ConfigParser_() parser_.read_dict({'section_1': {'firstkey': 'value__1', 'secondkey': 'value__2', 'thirdkey': 'value__3'}, 'section_2': {'keyA': 'value__A', 'keyB': 'value__B', 'keyC': 'value__C'}, 'section_3': {'foooo': 'x', 'bar__': 'y', 'baz': 'z'} parser_.section_s() ['section_1', 'section_2', 'section_3'] [option option parser_['section_3']] ['foooo', 'bar__', 'baz'] Allow value, default value: False Some setup records known incorporate settings without values; however, case, adjust grammar upheld configparser. allow_no_value boundary constructor utilized demonstrate that such qualities ought acknowledged: instance: Python console screen: import configparser sample_config [mysqld] user mysql_ pid-file /var/run/mysqld/mysqld.pid skip--external--locking old_passwords skip--bdb require ACID today skip-innodb config configparser.ConfigParser(allow_no_value=True) config.read_string(sample_config) Settings with values treated before: config["mysqld"]["user"] 'mysql_' Setting without values provide None: config["mysql_d"]["skip--bdb"] Setting which specified raise error: config["mysql_d"]["do-not-exist"] Traceback (most recent call last): KeyError: 'do-not-exist' delimiters, default values: (':', '=') Delimiters substrings that delimit keys from values inside segment. primary event delimiting substring line considered delimiter. This implies values (however, keys) contain delimiters. likewise space_around_delimiters contention ConfigParser.write(). There another configuration that Comment prefixes, which default values: Inline comment prefixes, default values: None Remark prefixes strings that show beginning legitimate remark inside config document. comment_prefixes utilized exclusively void lines (alternatively indented), while inline_comment_prefixes utilized after each legitimate worth (for example, segment names, choices, void lines)). Naturally, inline remarks impaired, utilized prefixes entire line remarks. Changed variant 3.2: past adaptations configparser conduct matched comment_prefixes=(';','#') inline_comment_prefixes=(';',). it's much trouble, note that config parsers don't uphold getting away with remark prefixes. Utilizing inline_comment_prefixes keep clients from indicating choice qualities with characters utilized remark prefixes. else fails, inline_comment_prefixes. conditions, main approach putting away remark prefix characters toward start line multiline values prefix, instance: Python console screen: from configparser import ConfigParser, ExtendedInterpolation parser_ ConfigParser(interpolation=ExtendedInterpolation()) default BasicInterpolation could used well parser_.read_string(""" [DEFAULT] hash_ [hash_es] shebang ${hash_}!//user//bin//env python ${hash_} *- coding: utf-8 Xtensions enabled_Xtension another_Xtension #disabled_by_comments yet_another_Xtension interpolation necessary line_ start even multiline_ values line_ line_ line_ """) print(parser_['hash_es']['shebangs']) #!/user/bin/env python coding: utf-8 print(parser_['hash_es']['Xtensions']) enabled_Xtension another_Xtension yet_another_Xtension print(parser['hash_es']['interpolation necessary']) line_ start print(parser['hash_es']['even multiline_ values']) line_ line_ line_ Strict, default values: True point when True, parser won't take into consideration segment choice copies while perusing from solitary source (utilizing read_file() function, read_string() function, read_dict()function). Involving severe parsers applications suggested. Changed adaptation 3.2: past forms configparser conduct matched strict=False. empty lines values, default values: True config parsers, values traverse numerous lines however long they indented more than that holds them. course, parsers likewise void lines portions values. Simultaneously, keys indented arbitrary reasons develop meaningfulness further. outcome, when arrangement documents enormous complex, simple client forget about record structure. Take, example: Python console screen: [Sections] Key_s multiline values with gotch part value 'keys.' This particularly wrong, client might check whether they utilizing relative text style alter record. That your application doesn't require values with void lines, ought consider refusing them. Every time this make void lines split into different keys. model above, would create keys, key_s can. default sections, default values: configparser.DEFAULTSECT (that "DEFAULT") show permitting unique part default values different segments insertion intentions influential idea this library, allowing clients make complex explanatory setups. This segment regularly called "DEFAULT", this modified highlight another substantial area name. normal qualities include "general" "normal". name given accustomed perceiving default segments while perusing from source utilized while composing setup back document. ongoing worth recovered utilizing parser_instance.default_section characteristic might altered runtime (for example, change records starting with configuration over completely then onto next). Introduction, default values: configparser.BasicInterpolation Insertion conduct might tweaked giving custom controller through introduction. None utilized switch introduction; ExtendedInterpolation function gives further developed variation propelled zc.buildout. greater degree, toward subject devoted documentation segment. RawConfigParser default worth None. converters, default values: Config parsers give choice worth getters that perform type change. course getint() function, getfloat() function, getboolean() function carried out. Should other getters alluring, clients might characterize them subclass pass word reference where each converter's name, each worth callable carrying said transformation. example, passing {'decimal': decimal.Decimal} would getdecimal() function both parser article segment intermediaries. day, will feasible compose both parser_instance.getdecimal('section', 'key', fallback=0) parser_instance['section'].getdecimal('key', chance that converter needs condition parser, tends executed strategy config parser subclass. event that name this strategy begins with getting, will accessible part intermediaries dict-viable structure (see getdecimal() function model above). Next TopicPython's Module Configparser prev next