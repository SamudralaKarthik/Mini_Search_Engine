next prev Python Memory Management this tutorial, will learn Python manages memory Python handles date internally. will dive deep into this topic understand internal working Python handles memory. This tutorial will give deep understanding Python memory management. When execute Python script, there many logic runs behind Python memory make code efficient. Introduction Memory management very important software developers work efficiently with programming language. know, Python famous widely used programming language. used almost every technical domain. contrast programming language, memory management related writing memory-efficient code. cannot overlook importance memory management while implementing large amount data. Improper memory management leads slowness application server-side components. also becomes reason improper working. memory handled well, will take much time while preprocessing data. Python, memory managed Python manager which determines where application data memory. must have knowledge Python memory manager write efficient code maintainable code. Let's assume memory looks like empty book want write anything book's page. Then, write data data manager find free space book provide application. procedure providing memory objects called allocation. other side, when data longer use, deleted Python memory manager. question how? where this memory come from? Python Memory Allocation Memory allocation essential part memory management developer. This process basically allots free space computer's virtual memory, there types virtual memory works while executing programs. Static Memory Allocation Dynamic Memory Allocation Static Memory Allocation Static memory allocation happens compile time. example C/C++, declare static array with fixed sizes. Memory allocated time compilation. However, cannot memory again further program. static a=10; Stack Allocation Stack data structure used store static memory. only needed inside particular function method call. function added program's call stack whenever call Variable assignment inside function temporarily stored function call stack; function returns value, call stack moves text task. compiler handles these processes, don't need worry about Call stack (stack data structure) holds program's operational data such subroutines function call order they called. These functions popped from stack when called. Dynamic Memory Allocation Unlike static memory allocation, Dynamic memory allocates memory runtime program. example C/C++, there predefined size integer float data type there predefine size data types. Memory allocated objects time. Heap implement dynamic memory management. memory throughout program. *a; int; know, everything Python object means dynamic memory allocation inspires Python memory management. Python memory manager automatically vanishes when object longer use. Heap Memory Allocation Heap data structure used dynamic memory which related naming counterparts. type memory that uses outside program global space. best advantages heap memory freed memory space object longer node deleted. below example, define function's variable store stack heap. Default Python Implementation Python open-source, object-oriented programming language which default implemented programming language. That's very interesting fact language which most popular written another language? this complete truth, sort Basically, Python language written English language. However, defined reference manual that isn't useful itself. need interpreter based code rule manual. benefit default implementation, executes Python code computer also converts Python code into instruction. that Python's default implementation fulfills both requirements. Note Virtual Machines physical computer, they instigated software. program that write using Python language first converts into computer-relatable instructions bytecode. virtual machine interprets this bytecode. Python Garbage Collector have explained earlier, Python removes those objects that longer that frees memory space. This process vanish unnecessary object's memory space called Garbage Collector. Python garbage collector initiates execution with program activated reference count falls zero. When assign name placed containers such dictionary tuple, reference count increases value. reassign reference object, reference counts decreases value if. also decreases value when object's reference goes scope object deleted. know, Python uses dynamic memory allocation which managed Heap data structure. Memory Heap holds objects other data structures that will used program. Python memory manager manages allocation de-allocation heap memory space through functions. Python Objects Memory know, everything Python object. object either simple (containing numbers, strings, etc.) containers (dictionary, lists, user defined classes). Python, don't need declare variables their types before using them program. Let's understand following example. Example a= print(a) print(a) Output: Traceback (most recent call last): File line print(x) NameError name defined above output, assigned value object printed When remove object access further code, there will error that claims that variable defined. Hence, Python garbage collector works automatically programmers doesn't need worry about unlike Reference Counting Python Reference counting states that many times other objects reference object. When reference object assigned, count object incremented one. When references object removed deleted, count object decremented. Python memory manager performs de-allocation when reference count becomes zero. Let's make simple understand. Example Suppose, there more variable that contains same value, Python virtual machine rather creating another object same value private heap. actually makes second variable point that originally existing value private heap. This highly beneficial preserve memory, which used another variable. When assign value integer object created Heap memory reference assigned id(x) id(y): 	print("The variables referring same object") above code, have assigned which means object will refer same object because Python allocated same object reference variable object already exists with same value. Now, another example. Example id(x) id(y): print("x refer same object") Output: refer same object variables referring same object because incremented one, creates reference object still referring Transforming Garbage Collector Python Garbage collector classified objects using generation. Python Garbage collector three-generation. When define object program, life cycle handled garbage collector's first generation. object different program, will stimulated next generation. Every generation threshold. garbage collector comes into action threshold number allocations minus number de-allocation exceeded. modify threshold value manually using module. This module provides get_threshold() method check threshold value different generation garbage collector. Let's understand following example. Example Import print(GC.get_threshold()) Output: (700, above output, threshold value first generation other values second third generation. threshold value trigger garbage collector modified using set_threshold() method. Example import gc.set_threshold(800, above example, value threshold increased three generations. will affect frequency running garbage collector. Programmers don't need worry about garbage collector, plays essential role optimizing Python runtime target system. Python garbage collector handles low-level details developer. Importance Performing Manual Garbage Collection have discussed earlier, Python interpreter handles reference object used program. automatically frees memory when reference count becomes zero. This classical approach reference counting, fails work when program referenced cycles. reference cycle occurs when more objects referenced each other. Hence reference count never becomes zero. Let's understand following example cycle_create(): list1 [18, list1.append(list1) return list1 cycle_create() [18, [...]] have created reference cycle. list1 object referring object list1 itself. When function returns object list1, memory object list1 freed that reference counting suitable solving reference cycle. But, solve altering garbage collector performance garbage collector. accomplish that, will gc.collect() function module. import gc.collect() print("Number object:", above code will give number collected de-allocated objects. perform manual garbage collector using methods time-based event-based garbage collection. gc.collect() method used perform time-based garbage collection. This method called after fixed time interval perform time-based garbage collection. even-based garbage collection, gc.collect() function calls after event occur. Let's understand following example. Example import sys, cycle_create(): list1 [18, list1.append(list1) main(): print("Here creating garbage...") range(10): cycle_create() print("Collecting object...") gc.collect() print("Number unreachable objects collected GC:", num) print("Uncollectable garbage:", gc.garbage) __name__ "__main__": main() sys.exit() Output: Here, creating garbage... Collecting object... Number unreachable objects collected GC: Uncollectable garbage: above code, have created list1 object referred list variable. first element list object refers itself. list object's reference count always greater than zero, even deleted scope program. Python Memory Management this section, will discuss Python memory architecture detail. discussed earlier, there layer abstraction from physical hardware Python. Various application Python access virtual memory that created operating system. Python uses portion memory internal non-object memory. Another part memory used Python object such int, dict, list, etc. CPython contains object allocator that allocates memory within object area. object allocator gets call every time object needs space. allocator primary designs small amount data because Python doesn't involve much data time. allocates memory when absolutely required. There three main components CPython memory allocation strategy. Arena largest chunks memory aligned page boundary memory. operating system uses page boundary which edge fixed-length contiguous chuck memory. Python assumes system's page size kilobytes. Pools composed single size class. pool same size manages double-linked list. pool must used, full, empty. used pool consists memory blocks data stored. full pool allocated contain data. empty pool doesn't have data assigned size class block when needed. Blocks Pools contains pointer their "free" block memory. pool, there pointer, which indicates free block memory. allocator doesn't touch these block until it's actually needed. Common Ways Reduce Space Complexity follow some best practices reduce space complexity. These techniques supposed save quite space make program efficient. Below practices Python memory allocators. Avoid List Slicing define list Python; memory allocator allocates Heap's memory according list indexing, respectively. Suppose need sub-list given list, then perform list slicing. straightforward sublist from original list. Somehow, suitable small amount data large data. Hence, list slicing generates copies object list. just copies reference them. result, Python memory allocator creates copy object allocates need avoid list slicing. best avoid developer should separate variable track indices instead slicing list. List Indexing Carefully developer should "for item array" instead "for index range(len(array))" save space time. program doesn't need indexing list element, then don't String Concatenation String concatenation suitable saving space time complexity. When possible, should avoid using string concatenation because strings immutable. When string existing string, Python creates string allocates address. Each string needs fixed size memory based character length. When change string, needs different amount memory requires reallocating. Let's following example. Mango print(a) Ice-cream" print Output: Mango Mango Ice-cream will create variable refer string object, which string value information. Then sting using operator. Python reallocates string memory based size length. Suppose original string's memory size byte, then string will bytes. Instead using string concatenation, the" .join(iterable_object)" format This makes huge impact saving memory time. Iterators Generators Iterators very helpful both time memory when working large data. Working with large dataset, need data processing immediately wait program process entire data first. Generators special functions used create iterator function. following example, implement iterator that calls special generator function. yield keyword returns current value, moving next value only loop's next iteration. Example __iter__(self): 	''' This function allows iterable. Element looped over using loop''' 	return self. _generator() _generator(self): 	""" This function used implement iterable. stores data currently gives next item each iteration loop.""" 	for self.items(): 		yield Built-in Library when Possible methods that have already been predefined Python library, then import corresponding library. would save space time. also create module define function import current working program. Conclusion this tutorial, have discussed working memory internally Python. have learned Python manages memory also discussed default Python implementation. CPython written programming language. Python dynamic type language that used Heap data structure store memory. Next TopicPython Libraries Data Visualization prev next