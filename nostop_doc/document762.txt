next prev Boruvka's Algorithm Minimum Spanning Trees this tutorial, will learn about Boruvka's algorithm Python. used identify minimum spanning trees. Otakar Boruvka, Czech mathematician, introduced this algorithm known work graph theories. This algorithm most famous application finding minimum spanning trees graph. will implement this algorithm using Python programming language. oldest minimum spanning tree algorithms. record, Boruvka came 1926. published method constructing efficient electricity network. Before jumping Boruvka's algorithm implementing using Python, let's understand concepts minimum spanning tree take recall graphs. Graphs Minimum Spanning Trees graph called abstracted structure representing group several objects known nodes (vertices). nodes connected, each these connections called Edge. Graphs used solve real-life problems, such social network graphs neural networks. simplify graph, draw family tree explain some complex relationship. Types Graphs There distinct categories graphs mainly Undirected Graphs Directed Graphs Undirected Graphs Undirected graphs referred which edges have directions. edges undirected graph are, therefore, measured bidirectional. define undirected graph where represents nodes, that contains unordered pair elements from which means edges. other words, undirected graph explained can't define direction edges relationship between nodes always two-sided. example edge goes from there edge that goes from Directed Graph directed graph said graph which edges have specific directions. define undirected graph where represents nodes, that contains ordered pair elements from which means edges. ordered pair means relationship between edges one-sided. other words, edge goes can't identify there edge that goes from also categorize graphs based their edges regarding weight those edges. These types graphs weighted. Unweighted Weighted Graphs graph weighted number assigned edge. Those numbers represent Edge's weight, which means weight between nodes, capacity, etc. refer importance anything according problem. Weighed Graphs used solve many problems, such need find shortest path, which will upcoming section. Unweighted Graphs just opposite weighted graph; such graphs don't have weight their edges, graph also disconnected connected. graph also connected disconnected. there path between nodes, considered connected graph. other hand, there path between nodes, regarded disconnected graph. What Tress Minimum Spanning Trees? tree non-linear, hierarchical, undirected graph where exactly path exists between edges, more, less. subgraph graph that consists subset nodes edges. spanning tree graph subgraph graph tree whose nodes same graph A's. minimum spanning tree spanning tree whose weight edges minimum possible. Here point remembered that tree shouldn't formed cycle. Now, let's understand Boruvka's Algorithm Boruvka's Algorithm Boruvka's algorithm straightforward intuitive. greedy algorithm that constructs globally "optimal" solution using smaller, locally optimal solutions smaller problems. Greedy algorithms generally concerned with most optimal solution when smaller steps Let's breakdown algorithm couple steps: Take connected, weighted, undirected graph input. Initialize nodes individual components. Initialize empty graph minimum spanning tree (MST). will contain solution. Perform following operation, there more than component. Find minimum-weighted edge that connects this vertex other vertex. least weighted edge MST exists already. there vertex remaining, return minimum spanning tree. Let's take graph find minimum spanning tree using Boruvka's algorithm. above undirected graph, have nine vertices. let's following table weighted distribution. Vertices Smallest weight edge that connects other vertex Weight edge {4} {5} {6} {7} {8} graph will look like below highlighted line shows nearest vertices that bound together. see, have components: 1}, 5}. Again, apply algorithm find minimum-weight edges. Vertices Smallest weight edge that connects other vertex Weight edge graph will look like below observe, there only vertex graph, representing minimum spanning tree. weight this tree which after summing edges. have seen working Boruvka's algorithm. will implement this using Python. Implementation this section, will write code algorithm. Let's following code. Code class Graph: __init__(self, num_of_nodes): self.m_v num_of_nodes self.m_edges self.m_vertex add_edge(self, weight): self.m_edges.append([u, weight]) find_vertex(self, self.m_vertex[u] return return self.find_vertex(self.m_vertex[u]) set_vertex(self, self.m_vertex[u] return else: self.m_vertex.keys(): self.m_vertex[k] self.find_vertex(k) union(self, vertex_size, vertex_size[u] vertex_size[v]: self.m_vertex[u] vertex_size[v] vertex_size[u] self.set_vertex(u) elif vertex_size[u] vertex_size[v]: self.m_vertex[v] self.find_vertex(u) vertex_size[u] vertex_size[v] self.set_vertex(v) print(self.m_vertex) boruvka(self): vertex_size mst_weight minimum_weight_edge [-1] self.m_v node range(self.m_v): self.m_vertex.update({node: node}) vertex_size.append(1) num_of_vertexs self.m_v print("---------Forming MST------------") while num_of_vertexs range(len(self.m_edges)): self.m_edges[i][0] self.m_edges[i][1] self.m_edges[i][2] u_vertex self.m_vertex[u] v_vertex self.m_vertex[v] u_vertex v_vertex: minimum_weight_edge[u_vertex] minimum_weight_edge[u_vertex][2] minimum_weight_edge[u_vertex] minimum_weight_edge[v_vertex] minimum_weight_edge[v_vertex][2] minimum_weight_edge[v_vertex] node range(self.m_v): minimum_weight_edge[node] minimum_weight_edge[node][0] minimum_weight_edge[node][1] minimum_weight_edge[node][2] u_vertex self.m_vertex[u] v_vertex self.m_vertex[v] u_vertex v_vertex: mst_weight self.union(vertex_size, u_vertex, v_vertex) print("Added edge str(u) str(v) "]\n" "Added weight: str(w) "\n") num_of_vertexs minimum_weight_edge [-1] self.m_v print("----------------------------------") print("The total weight minimal spanning tree str(mst_weight)) Graph(9) g.add_edge(0, g.add_edge(0, g.add_edge(1, g.add_edge(1, g.add_edge(1, g.add_edge(2, g.add_edge(2, g.add_edge(3, g.add_edge(3, g.add_edge(4, g.add_edge(4, g.add_edge(4, g.add_edge(5, g.add_edge(6, g.add_edge(7, g.boruvka() Output: Added edge Added weight: Added edge Added weight: Added edge Added weight: Added edge Added weight: Added edge Added weight: Added edge Added weight: Added edge Added weight: Added edge Added weight: ---------------------------------- total weight minimal spanning tree Explanation above code, have created class named Graph, which holds data structure used complete program. constructor, passed num_of_nodes argument declared three fields. m_v represents number nodes graph. m_edges represents list edges. m_vertex dictionary that stores index vertex which node belongs defined function add_edge(self, weight) function Edge graph. add_edge(self, weight) function adds edge format [first, second, edge_weight] graph. Then, defined find_vertex() set_vertex() method. this method, treated dictionary tree. found root component. don't find root node, recursively search current node's parent. union(self, vertex_size, defined that unified components into one, given nodes which belong their respective components. Then, compared components terms size attached smaller large one. Then, size smaller size larger because they have component. Then implemented Boruvka's algorithm. Example boruvka(self): vertex_size mst_weight minimum_weight_edge [-1] self.m_v node range(self.m_v): self.m_vertex.update({node: node}) vertex_size.append(1) num_of_vertexs self.m_v print("---------Forming MST------------") while num_of_vertexs range(len(self.m_edges)): self.m_edges[i][0] self.m_edges[i][1] self.m_edges[i][2] u_vertex self.m_vertex[u] v_vertex self.m_vertex[v] u_vertex v_vertex: minimum_weight_edge[u_vertex] minimum_weight_edge[u_vertex][2] minimum_weight_edge[u_vertex] minimum_weight_edge[v_vertex] minimum_weight_edge[v_vertex][2] minimum_weight_edge[v_vertex] node range(self.m_v): minimum_weight_edge[node] minimum_weight_edge[node][0] minimum_weight_edge[node][1] minimum_weight_edge[node][2] u_vertex self.m_vertex[u] v_vertex self.m_vertex[v] u_vertex v_vertex: mst_weight self.union(vertex_size, u_vertex, v_vertex) print("Added edge str(u) str(v) "]\n" "Added weight: str(w) "\n") num_of_vertexs minimum_weight_edge [-1] self.m_v print("----------------------------------") print("The total weight minimal spanning tree str(mst_weight)) this method, initialized list components Boruvka's algorithm. created list list keep track their size initialized well list minimum weight edges. Then, find root node components that connect both sides that edge. using condition, look minimum edge that link these components. current minimum weight edge components doesn't exist, assign value edge monitoring least weight edge source. current minimum weight edge components doesn't exist, allocate value edge monitoring minimal weight destination. After finding minimal weight edges each component, them minimal spanning tree reduce number components correspondingly. time complexity this algorithm 0(ElogV), where represents number edges while represents number nodes. O(V+E) space complexity this algorithm. Conclusion There many other popular minimum spanning tree algorithms like Prim's Kruskal's algorithm. However, Boruvka's algorithm well-known different algorithm. gives pretty much same result they find minimum spanning tree, time complexity approximately same. Boruvka's algorithm provides more advantages than algorithm; doesn't need presort edges maintain priority queue find minimum spanning tree. this tutorial, discussed Boruvka's algorithm, graphs, types. Next TopicDifference between Property Attributes Python prev next