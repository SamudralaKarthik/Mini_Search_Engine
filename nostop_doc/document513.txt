next prev Provide Multiple Constructors Python Classes Sometimes, have create Python class with different ways building objects. Also, would help user object that several constructors. This type class useful situations where must create instances that various types arguments. tools that allow multiple constructors help write flexible classes that adapted changing requirements. Python, there variety methods tools that employ create classes. These include simulating multiple constructors using optional arguments, customizing creation through class methods, performing special dispatch using decorators. users looking know more about these methods tools, this tutorial them. this course, will learn Make alternative argument arguments well check type simulation multiple constructors Create multiple constructors with inbuilt classmethod decorator Overload class constructors using @singledispatchmethod decorator Also, users will glimpse into inside Python internally creates instances regular classes certain standard library classes offer several constructors. benefit most from this tutorial, recommended that users have basics object-oriented programming able define classes using @classmethod. Additionally, they must have some experience working using decorators Python. Instantiating Classes Python Python programming language that supports concept object-oriented programming providing classes that easy write utilize. Classes similar plans objects, also referred instances. Just construct multiple homes from design, could also build many instances from single class. Python classes provide powerful capabilities that allow write better software. defining class using Python, necessary define keyword class keyword, followed class's name: Defining Person class class Person: __init__(self, name): self.name name Python full specific methods that employ class. Python calls specific methods that automatically perform many different tasks instances. There specific methods making object iterable. They provide appropriate string representation objects, initialize instances attributes, much more. most well-known technique found .__init__(). instance initializer refers this method Python. function instances' attributes with appropriate values whenever create class. In-Person, .__init__() method's first argument referred self. argument contains current instance object implicitly passed this method's call. This argument shared instances technique that implemented Python. second argument .__init__() known name, will store name Person text string. After have defined class, able begin invoking That begin creating objects that particular class. accomplish this, will have syntax. Call class with parentheses that uses same syntax employ invoke Python function: Instantiating Person jonny Person("Jonny Joe") jonny.name Output: 'Jonny Joe' Python, class name language that other languages, like Java, known constructor classes. same way, Person, that causes instance class creation process, which runs with phases: Create entirely instance class that wish target. Initiate instance using appropriate instances attribute values. following example, data input form argument Person passed internally through .__init__() later assigned instance attribute .name. this way, initialize instance Person, jonny, with correct data, which verify visiting .name. Success! Jonny fact, name. Once users have mastered mechanism initialization objects mechanism object initialization, they ready understand what Python does prior getting this stage instantiation process. It's time explore another method that known .__new__(). This method responsible creation instances Python. .__new__() special method uses underlying class first argument returns object. object usually example class being input. However, instance belonging different class certain cases. object .__new__() returns instance class currently being called, This instance will immediately transferred .__init__() initialize class. These steps take place whenever invoke class. Python objects class default base version .__new__() .__init__(). Contrary .__init__() there need modify .__new__() custom classes. most cases count default implementation. lessons have learned far, Python instantiation process begins calling instance class using correct arguments. process then goes through phases creating objects using .__new__() method initialization object using it's .__init__() method. Once have mastered internal behaviour Python, able begin providing several constructors within classes. That will offer multiple methods create objects same Python class. Define Multiple Class Constructors Sometimes, would like write classes that allow build objects using arguments various data types even different numbers arguments. method provide different constructors within class question. Each constructor allows creation instances using entirely different arguments. Certain programming languages, like C++, Java, able support overloading methods functions. This feature lets offer multiple class constructors since allows write multiple methods functions that have same name with different implementations. Method overloading process deciding call method language will choose most appropriate implementation running. Thus, method could accomplish different tasks depending situation instruction. Unfortunately, Python doesn't support function overloading directly. Python classes store names their methods within internal dictionary known .__dict__ that holds class namespace. Similar other Python dictionary .__dict__ can't contain repeated keys, which means cannot have more than method with same name within same class. doing that, Python will only able remember most recent execution that method time: greetr.py class Greeterr: say_hello(self): print("Hello, Universe") say_hello(self): print("Hello, Javatpoint") this instance, build Greeterr name suggests this example. Python class using methods. Both methods share same name. However, they slight differences their implementations. find consequences having methods share same name class, save class greetr.py file directory work execute following code during this active session: from greetr import Greeterr greeter Greeterr() greeter.say_hello() Greeterr.__dict__ Output: Hello, Javatpoint mappingproxy({'__module__': 'greetr', 'say_hello': '__dict__': '__weakref__': '__doc__': None}) this instance, this example, invoke .say_hello() greeter. instance belonging Greeterr class. hello, Javatpoint place hello, Universe display, this proves that second version method wins over first. last line code scrutinizes contents .__dict__,uncovering that name method, say_hello, only used once namespace class. This line with dictionaries function Python. same thing happens when using functions within Python module interactivity session. implementation that most functions that have same name superior other implementations: say_hello(): print("Hello, Universe") say_hello(): print("Hello, Javatpoint") say_hello() Output: Hello, Javatpoint functions defined with identical title, say_hello(), identical interpreter session. second definition replaces previous one. When invoke function, will "Hello, Javatpoint", confirms first definition that prevails. Another method that certain programming languages employ offer numerous ways call operation method includes multiple dispatches. This technique allows create multiple versions same method function then dynamically dispatch implementation want based type other attributes arguments used within request. possible variety programs from standard library incorporate this technique into code write Python code. Python very versatile feature-rich language. offers methods multiple constructors, making classes more adaptable. next section, will able simulate multiple constructors using additional arguments examine arguments determine various behaviour initializers. Simulate Multiple Constructors Classes method that quite useful simulate multiple constructors within Python class would supply .__init__() with optional arguments using default arguments. This way, able class constructor variety ways experience same behaviour every time. Another option verify data format that pass passed .__init__() offer different behaviours based data pass during call. This method lets simulate several constructors within same class. This section will help discover fundamentals simulate different ways build objects providing correct default values arguments .__init__() method examining type data used argument method. Both methods require just method .__init__(). Optional Argument Values .__init__() simple Pythonic method simulate multiple constructors implementing .__init__() method that uses optional argument. possible this specifying appropriate default arguments. this end, need code factory class called CumulativePowerFactory. This class creates callable objects that calculate specific powers using stream numerical values input. also necessary class keep track total power consecutive powers. Additionally, class should accept argument that holds that there initial amount power. Create powers.py file directory currently Then type following code implement CumulativePowerFactory: powerr.py class CumulativePowerFactory: __init__(self, exponent start self._exponent exponent self.total start __call__(self, base): power base self._exponent self.total power return power initializer CumulativePowerFactory takes optional arguments, exponent, start. first argument contains exponent will using calculate powers. default value most commonly used value computing power. symbol star asterisk following exponent signifies that begin only keyword argument. order pass value into argument that only keywords, necessary specify argument's name specific. example, change argument value value, necessary enter word "arg value" explicitly. Start Argument: beginning argument initial value used calculate cumulative power. default value zero, which best value those instances where don't have calculated value power sum. special method .__call__() turns instances CumulativePowerFactory into callable objects. other words, call instances CumulativePowerFactory like call regular function. Within .__call__(), first calculate power base that have raised exponent. Then, apply resultant number value currently .total. end, return power computed. give CumulativePowerFactory try, open Python interactive session directory containing powerr.py following code: from powerr import CumulativePowerFactory square CumulativePowerFactory() square(26) Output: Input: square(36) Output: 1296 Input: square.total Output: 1972 Input: cube CumulativePowerFactory(exponent cube(31) Output: 29791 Input: cube(36) Output: 46656 Input: cube.total Output: 76447 Input: initialized_cube CumulativePowerFactory(3, start=2205) initialized_cube(26) Output: 17576 Input: initialized_cube(46) Output: 97336 Input: initialized_cube.total Output: 117117 These examples show CumulativePowerFactory simulates multiple constructors. instance, initial constructor doesn't accept arguments. lets create instances class that compute powers which will standard value exponent argument. .total instance attribute contains power computing power work. second example illustrates operator that takes exponent argument. this instance, .total works exactly previous example. produces callable instance that calculates cubes. third example shows CumulativePowerFactory seems have another constructor that allows create instances providing exponent starting arguments. Now, .total starts with initial number 1972, which initial value power sum. Utilizing optional arguments when using .__init__() classes simple Pythonic method creating classes that emulate multiple constructors. Check Argument Types .__init__() determine nature variable Python, common inbuilt isinstance() function. function will return True when object object particular class False otherwise. Another method emulate multiple constructors create .__init__() method that performs differently based type argument. isinstance(46, int) Output: True Input: isinstance(42, float) Output: False Input: isinstance(47, (list, int)) Output: True first argument "isinstance()" object want type-check. Another argument will class kind reference. also possible provide number data types this case. users using Python 3.10 later, they also make Union syntax using pipes |). Then, would like work creating class that require class accept date birth person. code will show that birth date time object; however, make things easier users, they have option giving birth dates string using appropriate format. this instance, could implement something like this: from datetime import date class Person: __init__(self, name, birth_date): self.name name isinstance(birth_date, date): self.birth_date birth_date elif isinstance(birth_date, str): self.birth_date date.fromisoformat(birth_date) jonny Person("Jonny Joe", "1993-12-19") jonny.birth_date Output: datetime.date(1993, Input: jammy Person("Jammy Joe", date(1991, 25)) jammy.birth_date Output: datetime.date(1991, Within .__init__() first necessary define standard .name attribute. clause conditional statement determines birth date object. yes, then create .birth_date store current date. elif clause tests whether determine birth_date arguments string types. yes, .birth_date date object derived from supplied string. important note that birth_date argument must string containing date with format. Such YYYYY-DD-MM. That's have .__init__() method that simulates type that multiple constructors. constructor accepts argument date type. other constructor accepts arguments type string. approach used above illustration disadvantage that isn't scalable. using several arguments that used represent various types data, application could quickly become issue. Therefore, this approach regarded anti-pattern within Python. instance, what would occur user entered date time amount birth date? Take look following code snippet. lucky Person("Lucky Sam", 1033222000) lucky.birth_date Output: --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) lucky Person("Lucky Sam", 1033222000) ----> lucky.birth_date AttributeError: 'Person' object attribute 'birth_date' attempt connect .birth_date, receive error message indicating that attribute unavailable because conditional statement does have branches that consider alternative format dates. resolve this problem, continue elif clauses include possible formats dates that users use. also possible include another alternative clause detect supported date formats: from datetime import date class Person: __init__(self, name, birth_date): self.name name isinstance(birth_date, date): self.birth_date birth_date elif isinstance(birth_date, str): self.birth_date date.fromisoformat(birth_date) else: raise ValueError(f"unsupported date format: {birth_date}") lucky Person("Lucky Sam", 1033222000) Output: --------------------------------------------------------------------------- ValueError Traceback (most recent call last) ---> lucky Person("Lucky Sam", 1033222000) __init__(self, name, birth_date) self.birth_date date.fromisoformat(birth_date) else: ---> raise ValueError(f"unsupported date format: {birth_date}") ValueError: unsupported date format: 1033222000 this case, otherwise clause. executed number birthday_date isn't actual object string that contains legitimate date. This way, unique scenario does happen silence. Provide Multiple Constructors With @classmethod Python effective method provide several Python constructors utilizing @classmethod decorator. This decorator lets convert normal method into actual Class Method. opposed normal method, class does make this instance self argument. Instead, they consider entire class, typically included argument. Utilizing word identify argument become well-known practice within Python community. This preliminary syntax used define classes: class Demo_Class: @classmethod class_method(cls): print(f"This class method from {cls.__name__}!") Demo_Class.class_method() Output: This class method from Demo_Class! Input: demo Demo_Class() demo.class_method() Output: This class method from Demo_Class! Demo class class method that uses built-in @classmethod decorator. first argument .class_method() class's name. With this argument, able access class inside class itself. this instance, will need have access using .__name__ attribute, which records information about class text string. It's important know that invoke class method using class specific example that class question. primary reason using classes constructors class method that don't require instance invoke instance class method. However, call .class_method(), will Demo_Class first argument. @classmethod allows include number explicit constructors require particular class. It's Pythonic well-known method multiple constructors. also possible call this kind constructor alternative constructor Python, such Raymond Hettinger uses PyCon presentation Python Class Development Toolkit. What class method alter instantiation process Python? Instead tweaking .__init__() initialization object, possible control both stages: creation objects initialization. following example, will taught accomplish this. Construct Circle from Diameter first class constructor, using @classmethod, Let's programming geometric-related program require circle class. first, will define class following manner: circle1.py import math class Circle: __init__(self, radius): self.radius radius area(self): return m.pi self.radius perimeter(self): return m.pi self.radius __repr__(self): return f"{self.__class__.__name__}(radius {self.radius})" class implements methods calculate perimeter area Circle with Python mathematical module. initializer, Circle uses radius number form argument then stores that attribute instance called .radius. procedure .__repr__() provides appropriate expression string that appropriate class. Create circle1.py file directory work After that, open Python interpreter following program test Circle: from circle1 import Circle circle Circle(52) circle Output: Circle(radius Input: circle.area() Output: 8494.8665353068 Input: circle.perimeter() Output: 326.7256359733385 Cool! class functioning properly! imagine that would like create circle using diameter. It's possible this using Circle (diameter 2.), that's exactly Pythonic well intuitive. It's best alternative constructor that create circles simply using diameter Circle directly. following class method Circle just middle .__init__(): circle.py import math class Circle: __init__(self, radius): self.radius radius area(self): return m.pi self.radius perimeter(self): return m.pi self.radius __repr__(self): return f"{self.__class__.__name__}(radius {self.radius})" @classmethod from_diameter(cls, diameter): return cls(radius=diameter this case, code defines .from_diameter() example class method. method's first argument will class that part Class called Circle. second argument size Circle wish make. process, first determine radius using input value diameter. Then, create circle calling using radius calculated using diameter argument. this manner, complete control defining initializing instances Circle with diameter used argument. function that calls argument runs initialization creation procedures that Python requires create class. Then, .from_diameter() returns newly created instance user. Here's brand-new constructor that have created create circles making radius: from circle import Circle Circle.from_diameter(84) Output: Circle(radius=42.0) Input: circle.area() Output: 5541.769440932395 Input: circle.perimeter() Output: 263.89378290154264 method .from_diameter() Circle produces fresh brand instance this class. Creating that instance utilizes actual diameter, radius. remainder function part Circle same before. @classmethod, similar above example, most commonly used method specify multiple constructors classes. This way, able choose appropriate name each constructor that offer help make making code more understandable manageable. Build Polar Point from Cartesian Coordinates more detailed example implementing multiple constructors with class methods, suppose that have class representing polar spot concept math-related program. necessary allow class more flexible that build instances with Cartesian coordinates addition. Here's create constructor satisfy this need: pointt.py import math class PolarPoint: __init__(self, distance, angle): self.distance distance self.angle angle @classmethod from_cartesian(cls, distance m.dist((0, angle m.degrees(m.atan2(y, x)) return cls(distance, angle) __repr__(self): return f"{self.__class__.__name__}" f"(distance={self.distance:.1f}, angle={self.angle:.1f})" this instance, .from_cartesian() accepts arguments that represent area's coordinates: well Cartesian coordinates. method then calculates needed distance angle create appropriate PolarPoint objects. Then, .from_cartesian() produces newly created instance class. Here's class functions using coordinate systems. from pointt import PolarPoint With polar coordinates PolarPoint(16, 21.6) Output: PolarPoint(distance 16.0, angle 21.6) Input: With cartesian coordinates PolarPoint.from_cartesian(x Output: PolarPoint(distance 26.6, angle 34.3) these instances, will employ standard instantiation method alternate constructor .from_cartesian(), which allows generate PolarPoint instances that conceptually distinct initialization arguments. Explore Multiple Constructors Existing Python Classes Utilizing @classmethod decorator offer several constructors class common practice Python. There numerous examples standard built-in classes that make this method offer multiple different constructors. Within this article, will able learn details about renowned cases this class: dict, datetime .date pathlib.Path. Construct Dictionaries from Keys Dictionaries most fundamental kind data Python. They present every part Python code, whether directly indirectly. They're also integral part language since significant parts that comprise Python's CPython application depend them. There many methods identifying dictionary instances Python. Dictionary literals used that key-value pairs that curly bracketed {}). also possible call "dict()" explicitly with keyword arguments sequence tuples with items, example. This well-known class also provides alternative constructor, called .fromkeys(). This class method uses form array keys well option number keys optional value. value argument optional. Value defaulted None, same value keys resulting dictionary. What users think .fromkeys() help them their program? they manage animal sanctuary look develop that will track number animals currently their shelter. application makes alphabetical dictionary record animal's inventory. Because user know what species animal they accommodate their shelter, they build inventory dictionary from scratch, such following code example: allowed_animals ["Tiger", "lion", "Cobra", "donkey"] animal_inventory dict.fromkeys(allowed_animals, animal_inventory Output: {'Tiger': 'lion': 'Cobra': 'donkey': this instance, have constructed initial dictionary using .fromkeys() that takes keys from animals that allowed system. inventory create that each animal zero supplying this number second argument .fromkeys(). have already learned, value defaults None, which appropriate first value keys dictionary certain situations. instance below, zero ideal value dealing with number individuals each species. other mappings within standard library have constructor named .fromkeys(). This true OrderedDict well defaultdict UserDict. instance UserDict's software source UserDict offers this implementation .fromkeys(). @classmethod fromkeys(cls, iterable, value None): cls() iterable: d[key] value return This because .fromkeys() uses from iterable amount form arguments. method creates brand-new dictionary using method. Then, loops over keys within iterative assigns each value value None normal way. end, method returns newly created dictionary. Create datetime.date Objects datetime.date class from standard library another class that utilizes numerous constructors. This class number alternatives constructors, including .today(), .fromtimestamp(), .fromordinal() .fromisoformat(). them permit create datetime.date objects using same arguments with different concepts. Here some examples constructors mentioned above construct datetime.date objects: from datetime import date from time import time Standard constructor date (2021, Output: datetime.date(2021, Input: date.today() Output: datetime.date(2021, Input: date.fromtimestamp(1632520000) Output: datetime.date(2021, Input: date.fromtimestamp(time()) Output: datetime.date(2022, Input: date.fromordinal(738128) Output: datetime.date(2021, Input: date.fromisoformat("2021-12-23") Output: datetime.date(2021, first example employs standard constructor classes reference. second example demonstrates utilize .today() construct time object based current day's date. remaining examples demonstrate datetime.date uses several classes offer multiple constructors. variety constructors available allows instantiation procedure robust flexible covers variety scenarios. This also enhances accessibility code providing explicit method names. Find Path Home Python pathlib module that part standard library offers modern efficient tools efficiently handling system path your program. user have never heard this module before, they should through Python 3's pathlib module: Taming File System. most efficient tool available pathlib library found Path class. This class lets manage system's Path cross-platform basis. Path different standard library class that several constructors. instance, will come across Path.home(), which creates object called path from home directory from pathlib import Path Path.home() Output: WindowsPath('C:/Users/User Name') .home() constructor produces brand path object which represents user's home directory. This alternative constructor could beneficial when dealing with settings files within Python applications project. Conclusion Writing Python classes that have several constructors will help code become more flexible adaptable, allowing many different scenarios. Multiple constructors effective feature that lets create instances core class with arguments different kinds, different numbers arguments, both, depending needs users. this course, have learned Simulate multiple constructors using additional argument arguments along with type checking. Create multiple constructors with inbuilt @classmethod decorator Next TopicProfiling Python code prev next