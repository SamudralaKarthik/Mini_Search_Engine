next prev Advance Concepts Python Python Developer journey learning Python, through practice have deep understanding Python core concepts. Implementing learned topic will take effort dedication. Here mentioning some essential advanced Python concepts that will help gain more efficiency Python developer. Once hands-on experience these topics, implement complex solution. Below list Advance topics Python. Everything Object Python? Comprehension Closure Decorator Generator Iterators Protocol Context Managers Extended Keyword Arguments (*args, **kwargs) @staticmethod @classmethod Inheritance Encapsulation Operator Overloading Python Packages Program layout Let's move first topic. everything Python Object? read official documentation Python "Everything Python object." Strings objects, lists objects, functions objects, even modules objects. Everything object because assigned variable passed argument function. Anything place right-hand side equals sign creates) object Python. Example hello(): 	print("say hello") hello() "say hello" hello() "say hello" Objects object qualities Identity (id) value (mutable immutable) Mutable When modify item, won't change. example Dictionary, List, set. Immutable can't alter element. example String, Integer, Tuple. Comprehension Comprehensions Python allow write concise line create sequences (such lists, set, dictionary etc.) using sequences which have already been defined. Python provides following four types comprehensions: List Comprehensions Dictionary Comprehensions Comprehensions Generator Comprehensions List Comprehensions List Comprehension well-designed define lists. Below basic structure list comprehension. Syntax expr(item) item iterable Example Without list comprehension given_list output Using loop constructing output list given_list: output.append(i) print("Output List using loop:", output) Output: Output List using loop: Example With list comprehension given_list list_comp_example given_list print("Output List using list comprehensions:", list_comp_example) Output: Output List using list comprehensions: Dictionary Comprehension Python also allows comprehension with dictionary list comprehensions; also create dictionary using dictionary comprehensions. syntax dictionary comprehension looks like below. Example key_expr:value_expr item iterable Example Without Dictionary Comprehension given_list output Using loop constructing output list given_list: output[i] print("Output List using loop:", output) Output: Output List using loop: 216, 512, 1000} Comprehensions comprehensions quite similar list comprehensions. only difference between them that comprehensions curly brackets Let's look following example understand comprehensions. Example Without Comprehension given_list output set() Using loop constructing output list given_list: output.add(i) print("Output List using loop:", output) Output: Output List using loop: Example With Comprehension given_list output set() set_using_comp {var given_list print("Output using comprehensions:", set_using_comp) Output: Output using comprehensions: Generator Comprehension Generator Comprehensions very similar list comprehension. difference that generator comprehensions circular brackets, whereas list comprehensions square brackets. Let's look following example understand generator comprehension. Example given_list output_gen (var given_list output_gen: print(var, Output: Multiple Comprehensions values [(x,y) range(5) range(3)] values range(5): range(3): values.append((x,y)) Nested Comprehension values [[y*3 range(x)] range(10)] 	values 	for range(10): inner range(x): inner.append(y*3) values.append(inner) Extended Keyword Arguments arguments call function Python. Sometimes need keyword arguments positional arguments, Keyword arguments often used make function calls more explicit. Extended Format Argument Syntax Arguments function definition side Example hyper(*lengths): iter(lengths) next(i) length length return print(hyper(1, Output: Extended Actual Arguments Syntax Argument function calls side. Example argument print_args(arg1, arg2, *args): print(arg1) print(arg2) print(args) print_args(*argument) Output: Closure Decorators understanding closure decorators, should know about local functions Local Function function inside function value specialized, one-off functions. similar lambdas more general code organization readability. Scope resolution LEGB rule: Python, LEGB rule used decide order which namespaces searched scope resolution. scopes listed below terms hierarchy (highest lowest/narrowest broadest): Local (L) defines inside function/class. Enclosed (E) define inside enclosing functions (Nested function concept). Global (G) defines uppermost level. Built-in reverses names Python built-in modules. Let's understand following example Example func(): local_func(): 'hello, 'world' return return Returning Function outer(): inner(): print('inner') return inner Closures maintains references object from earlier scopes. Let's understand following example Example outer_function(x): inner_function(y): return return inner_funtion add_plus= outer_function(30) add_plus(20) Output: Decorators Decorators essential, powerful useful tool Python since allows programmers modify behaviour function class without changing actual definition. Decorators allow wrap another function extend behaviour wrapped function without permanently modifying Let's understand following example Example change_upper(f): print("change_upper") wrap(*args, **kwargs): print("wrap") f(*args, **kwargs) return x.upper() return wrap @change_upper my_name(name): print("my_name") return name Output: change_upper Generator Iterable Protocol Iterable object passed built-in iter() function iterator. Iterator object passed built-in next() function fetch next item. Example iterator iter(iterable) item next(iterator) Generators generator function defined like regular function, does with yield keyword rather than return whenever needs generate value. body contains yield, function automatically becomes generator function. yield statement used define generator; yield keyword different from return because suspends function execution, returns value, saves states, later continues successive calls. Example my_gen(): print('This printed first') Generator function contains yield statements yield print('This printed second') yield print('This printed last') yield Using loop item my_gen(): print(item) generators used Python? Easy Implement Memory Efficient Represent Infinite Stream Pipelining Generators Example PowTwoGen(max while max: yield Context Manager Context managers used manage resources. usage resources like file operations database connections widespread. Resources minimal, need manage them. Therefore, main problem lies making sure release these resources after usage. would very beneficial users mechanism automatic setup breakdown resources. Python, attained using context managers, simplifying proper handling resources. most common execute file operations using keyword shown below. Example Python program showing with keyword with open("test.txt") 	data f.read() @staticmethod @classmethod @classmethod allows access class attributes. don't need object, @static method. Python static method overridden subclass. Below difference between static method class method. Example Class Method Static Method class method takes (class) first argument. static method does take specific parameter. Class method access modify class state. Static Method cannot access modify class state. class method takes class parameter know about state that class. Static methods know about class state. These methods used some utility tasks taking some parameters. @classmethod decorator used here. @staticmethod decorator used here. Example from datetime import date class Employee: __init__(self, name, age): self.name name self.age @staticmethod isAdult(age): return True else: return False @classmethod emp_from_year(emp_class, name, year): return emp_class(name, dt.today().year year) __str__(self): return 'Employee Name: Age: {}'.format(self.name, self.age) Employee('Joshep', print(e1) Employee.emp_from_year('Peter', 1997) print(e2) print(Employee.isAdult(25)) print(Employee.isAdult(16)) Output: Employee Name: Joshep Age: Employee Name: Peter Age: True False Inheritance Encapsulation Inheritance technique which class takes property another class. example, child inherits some characteristics his/her parents. With inheritance, reuse fields methods existing class. Hence, inheritance simplifies Reusability important concept OOPs. single inheritance: subclass will acquire functionality parent class also adapt enhance. subclass initializer wants call base class initializer make sense that full object initialized. class SubClass(BaseClass): Multiple Inheritance: defines class with more than base class. Let's following syntax Example Class SubClass(Base1, Base2, â€¦): Operator Overloading Python Operator works built-in classes. same operator performs contrarily with different types. example, operator will, achieve arithmetic addition numbers, merge lists concatenate strings. Let's understand following example Example class Point: __init__(self, self.x self.y __str__(self): return "({0},{1})".format(self.x,self.y) __add__(self,other): self.x other.x self.y other.y return Point(x,y) Point(2,3) Point(-1,2) print(p1 Output: Python Package Program Layout Package module which contain other modules. PYTHONPATH Environment variable listing paths added sys.path. Packages modules that contain other modules. Packages generally implemented directories containing special __init__.py file. __init__.py file executed when package imported. Packages contain sub-packages that themselves implemented with __init__.py files directories. module objects packages have __path__ attribute. absolute imports: imports that full path module. Conclusion this tutorial, discussed some essential Python concepts which pretty valuable development. practicing these topics, gain write effective efficient code, these topics make Python beneficial popular programming language. Next TopicPycricbuzz Library Cricket Python prev next