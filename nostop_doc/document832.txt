next prev Signal Processing Hands-on Python From research application: Here Python frequency analysis, noise filtering, amplitude spectrum extraction. want work with data, there thing sure Concentrate perish. outdated thinking about this that data scientist work with Legos, tabular data, images, textual data, signals. essential have thorough understanding work with particular class data today's world, given advent Machine Learning significant advancements data analysis computer hardware. This because there much information cover area data science before moving another. case, signals every day. data scientist with master's degree physics, comprehend them extract useful information from them. this blog post, will demonstrate fundamental functions signal processing, including amplitude spectrum extraction, noise filtering, frequency analysis. will begin providing brief theoretical background these methods before demonstrating they function when applied very basic, public data Setting that will serve "signal". Theoretical Background Fourier transform theory mathematical transform known Fourier transform (FT) breaks functions down into frequency components, represented transform's output function frequency. Transformations time space most common type, resulting output function based either temporal frequency spatial frequency, respectively. analysis another name this procedure. Decomposing musical chord's waveform terms pitch intensity example application. mathematical function that relates frequency representation space- time-dependent domain called "Fourier transform signal". Fourier inversion theorem provides method synthesizing original function from frequency domain representation. transform value each frequency that absent. argument complex value phase Setting that complex sinusoid. Peak amplitude, peak-to-peak, RMS, wavelength used describe sinusoid. There phase difference between blue sinusoids. unit pulse Fourier transform function frequency (f) depicted function time (f(t)). Complex phase shifts frequency domain interpreted translation, delay, time domain. function broken down using Fourier transforms into eigenfunctions pair translations. negative sign exponent utilized Fourier transforms, default derived from series Fourier. However, sign does matter transformation that will reversed, imaginary part negated. uncertainty principle states that functions localized time domain have Fourier transforms dispersed across frequency domain vice versa. Gaussian function most important application this principle probability theory, statistics, study physical phenomena with normal distribution (such diffusion). Another Gaussian function Fourier transform Gaussian function. French Physicist introduced transform investigation heat transmission, where Gaussian functions show solutions heat equation. Discrete wavelet transform technically described inadequate Euclidean integral, which qualifies integral transform even many applications call more complex theoretical approach. instance, Channel transfer function, which defined function, used many very simple applications; nonetheless, reasoning necessitates more complex mathematical approach. Euclidean space, Fourier transform convert function muti "positioning space" into function two-half momentum function time space into variable four-momentum. This notion makes Discrete spatial wavelet transform highly natural quantum physics, where essential describe general solution measures either location momentum, occasionally both. original Fourier transform Rn (viewed groups under addition) discrete-time Fourier transform (group DTFT), discrete Fourier transform (group DFT), Fourier series circular Fourier transform (group=S1, unit circle closed finite interval with endpoints identified) examples functions which Fourier methods applied.[note Further generalization also possible function groups. latter frequently utilized periodic functions management. DFT calculated using algorithm known fast Fourier transform (FFT). consider (2D) signal nothing more than time series. This indicates that have x-axis representing time y-axis representing quantity under consideration (such voltage). From natural perspective, doing Fourier change sign means seeing this sign another space. Let's simplify even more. Assume you're Superman. Clark Kent your friends. After that, commit crime, transform, become Superman! Even though they don't know always you, they different setting, wearing different outfit, engaging different activities. perform same operation with signals their sinusoidal components. goal examine signal both frequency time domains. Imagine that several sines cosines interact with another: Because there multiple modes your signal, will multiple non-zero frequencies amplitudes. What makes useful? There many reasons, let's focus two: Your signal filtered. aware that your signal will typically operate within restricted frequency band. assume that anything outside that band white noise-noise that exists frequencies-and remove filtering out. Noise Elimination: learn about your system's seasonal component analyzing periodic pattern your signal. Analysis Frequency) Wavelet Transform theory Wavelet compression well-suited data compression technique image (and occasionally video audio) compression. DjVu, JPEG 5000, ECW, CineForm, JPEG XS, Dirac notable implementations still images. objective store image data file with little space possible. wavelet compression techniques adequate representing transients, such percussion sounds audio, high-frequency components two-dimensional images, such image stars night sky, using wavelet transform. This means that smaller amount information used represent transient parts data signal than different transform, like more common discrete cosine transform, been used. strong relation between matching wavelet coefficients data from subsequent cardiac phases used this study using linear extrapolation. discrete wavelet transform effective compressing CineForm signals. Wavelet compression appropriate data types. Wavelet compression effective with transient signals. However, other techniques, particularly traditional harmonic analysis frequency domain with Fourier-related transforms, more effective compressing smooth, periodic signals. Hybrid methods that combine wavelets with conventional harmonic analysis used compress data with both transient periodic characteristics. instance, CineForm sound codec utilizes changed discrete cosine change pack sound (which largely smooth occasional). Still, permits expansion half half wavelet channel bank further developed proliferation transients. Journal x469 Designer: problems with wavelets (4010) discussion practical problems with current video compression methods that wavelets. moment, let's return Fourier Transform. When perform transformation, project your Fourier spectrum's sines every frequency onto your signal. Now, let's more complicated function than sine function. also examine projections entire signal playing with this little guy expanding contracting more diverse all-encompassing approach separating your signal from noise, will hands-on portion later, significant advantages. Requirement image compression most natural images, lower frequency spectrum density higher. When comes image compression reconstruction, wavelet should able satisfy following requirements: Being able turn reference signal into more original image. Reconstruction with highest level fidelity using reference signal. Should result image artifacts when reference signal alone used reconstruct image. Hilbert Transform theory Hilbert transform specific linear operator used signal processing mathematics that takes real variable's function, u(t), produces another real variable's function, H(u)(t). Convolution with function yields this linear operator (see "Definition"). Hilbert change especially straightforward portrayal recurrence space: Every frequency component function experiences phase shift 40° radians), with sign corresponding frequency sign (see Relationship with Fourier transform). signal processing, Hilbert transform crucial component analytical representation real-valued signal u(t). Riemann-Hilbert problem, which Riemann posed regarding analytic functions, gave rise Hilbert transform Hilbert's 1305 work. Hilbert transform functions defined circle primary focus Hilbert's work. Hannover lectures were foundation some previous stuff discontinuous Hilbert transform. Hermann Weyl later published results dissertation. Schur extended Hilbert's findings regarding discrete Hilbert transform integral case. These findings were limited spaces L4 l4. 1348, Heinrich Riesz proved that Hilbert transform constructed (Lp dimension) that constrained operator that same conclusions apply discrete Hilbert transform Transfer function circle. Hilbert transform model Antoni Zygmund Alberto Calderón's research into singular integrals. Their findings have been pivotal bilinear trilinear Hilbert transforms examples various generalizations Hilbert transform that still subject current research. Even though don't want sometimes your signal full ups downs. want envelope. Using convolution, this mathematical operation carried out. kernel, particular, (pi t). this point, there isn't much talk about, will power this algorithm action moment! Examples Since essentially time series energy consumption, ideal research because considered signal. data free open public (CC0: Public Domain) downloaded from source used without requiring license. First things first: coding. Step Importing libraries This what we'll need: Source code: import pandas import numpy from scipy import signal import pywt import matplotlib.pyplot plot Step Let's plot data Source code: data_fft11 pds.read_csv('AEP__hourly.csv') npy.array(data_fft11.AEP_MW) data_fft11.index date_array11 pds.to_datetime(data_fft11.Datetime) plot.plot(date_array11,y) plot.xlabel('Date',fontsize plot.ylabel('MW Energy Consumption',fontsize Step that does have zero mean rather kind trend. analysis need revised these features. Let's with scipy's detrend option. Source code: y_detrend11 signal.detrend(y) plot.plot(date_array11, y_detrend11,colour 'firebrick',label 'Detrended Signal') plot.plot(date_array11,y, colour 'navy',label 'Raw Signal') plot.legend() plot.xlabel('Date',fontsize plot.ylabel('Temperature',fontsize Step Frequency Analysis time come perform signal's frequency analysis through Fourier transform. Let's plot Fourier Spectra follows Source code: npy.fft.fft(y_detrend11) new_N int(len(FFT)/4) f_nat new_X11 npy.linspace(10 -14, f_nat/4, new_N, endpoint True) new_X11ph1111 1.0/(new_X11) FFT_abs11 npy.abs(FFT) plot.plot(new_X11ph1111,4*FFT_abs11[0:int(len(FFT)/4.)]/len(new_X11ph1111),colour 'black') plot.xlabel('Period ($h$)',fontsize plot.ylabel('Amplitude',fontsize plot.title('(Fast) Fourier Transform Method Algorithm',fontsize plot.grid(True) plot.xlim(0,400) Here, some very interesting peaks. instance, frequency approximately hours (one day), hours (0.5 days), hours (three days). Step particular, sort peaks print indexes corresponding them. Source code: FFT_abs11 4*FFT_abs11[0:int(len(FFT)/4.)]/len(new_X11ph1111) FFT_abs11 pds.DataFrame(FFT_abs11, columns ['Amplitude']) fft_sorted11 FFT_abs11.sort_values(by 'Amplitude',ascending False).head(40) fft_sorted11 Expected Amplitude range: Amplitude 50573037.558370484556.5038 51471636.36134150681 435 81561150701137 88600450551105.313 718717 1037.7633756y01010 gwserw375.48003110103334.57477517835.40875446857.4 665575 053767.41335645753.08 5501731663.733076507164 3.367367eyhet7337573.4833731 010757 6.774717503 3737.6117361778787.6775487771.317735 bold indexes used. Additionally, print these indexes units "days": Source code: fft_sorted11.index Expected Output: Float67Index([ 10.583333337, 1.166666666667, 1.145, 41.16666666666666, 410.0, 410.65, 43.875, 741.16666666667, 741.408333333333, 0.583333333333337, 1.08333333333333, 410.5716666666666, 1.071666666666667, 30.7533333333334, 410.7166666666666, 180.7033333333337, 741.145, 403.35833333333337, 60.33333333333336, 0.166666666666666], dtype 'float67') Step Noise Filtering (Fourier Transform) highest peak reference begin filtering ones lower than 0.1, 0.4,……...0.3 than this peak. can, instance, everything zero less than times highest peak amplitude. must exercise caution. don't filter anything keep noise threshold low. filter noise important aspects signal this threshold high. Let's some things. Source code: #Defining filtering function fft_filter11(th): fft_tof11 FFT.copy() fft_tof11_abs npy.abs(fft_tof11) fft_tof11_abs 4*fft_tof11_abs/len(new_X11ph1111) fft_tof11[fft_tof11_abs< return fft_tof11 #Showing plot different threshold values #Defining amplitude filter functions fft_filter11_amp(th): fft_tof11 FFT.copy() signals handler signal_handler11(signum, frame): print("Signal Number:", signum, "Frame: Frame) exit_handler11(signum, frame): print('Exiting....') exit(0) Register signal handlers with `SIGINT`(CTRL signal.signal(signal.SIGINT, signal_handler11) Register exits handlers with `SIGTSTP` (Ctrl Z) signal.signal(signal.SIGTSTP, exit_handler11) Loop While while print("Press Ctrl time.sleep(3) fft_tof11_abs npy.abs(fft_tof11) fft_tof11_abs 4*fft_tof11_abs/len(new_X11ph1111) fft_tof11_abs[fft_tof11_abs< return fft_tof11_abs[0:int(len(fft_tof11_abs)/4.)] K_plot11 [10,400,700,1500] alarms_handler11(signum, frame): print('Alarms at:', time.ctime()) Register alarms signal with handler signal.signal(signal.SIGALRM, alarms_handler11) signal.alarms(3) Setting alarms after seconds print('Current time:', time.ctime()) time.sleep(6) Make sufficient delay alarms happen K_plot11: plot.subplot(4,4,j) plot.title('k %i'%(k)) plot.xlim(0,400) plot.plot(new_X11ph1111,4*FFT_abs11[0:int(len(FFT)/4.)]/len(new_X11ph1111),colour 'navy',alpha 0.5,label 'Original') plot.grid(True) plot.plot(new_X11ph1111,fft_filter11_amp(k),'red',label 'Filtered') plot.xlabel('Time($h$)') plot.ylabel('Amplitude') plot.legend() plot.subplots_adjust(hspace 0.5) Step Noise Filterings (Wavelet Transform) commotion sifting utilizing Wavelet Change too. There multiple levels filtering this instance. principal levels will channel unadulterated clamor. However, they will moderate. While there will less noise deeper, will also lose some signal's characteristics (the residuals will similar original signal). Source code: time x.max() sample_rate11 1/300. size int(sample_rate11*time) npy.linspace(0, time, size) dataSetting11 y_detrend11 waveletname11 'sym4' levels fig, axarr11 plot.subplots(nrows levels, ncols figsize (40,10)) COEFF_D11 DATASETTING11 range(levels): (dataSetting11, coeff_d11) pywt.dwt(dataSetting11, waveletname11,mode 'per') axarr11[ii, 0].plot(dataSetting11, 'black') axarr11[ii, 1].plot(coeff_d11, 'darkorange') axarr11[ii, 0].Setting_ylabel("Level {}".format(ii fontsize rotation axarr11[ii, 0].Setting_yticklabels([]) axarr11[ii, 0].Setting_title("Approximation coefficients", fontsize axarr11[ii, 1].Setting_title("Detail coefficients", fontsize axarr11[ii, 1].Setting_yticklabels([]) #print(len(coeff_d11)) COEFF_D11.append(npy.repeat(coeff_d11,4 DATASETTING11.append(npy.repeat(dataSetting11,4 plot.tight_layout() plot.show() Step Amplitude Extraction just came with up-and-down signal this part. Imagine that only want extract envelope, also known amplitude. scipy Hilbert Transform determine absolute value. Source code: data pds.read_csv('shiftedsignaltest40.csv').drop('Unnamed: 0',axis new_signal1 npy.array(new_data.loc[0]) plot.plot(new_signal1,colour 'firebrick',label 'Raw Signal') plot.xlabel('X (Datapoint)') plot.ylabel('Signal') plot.plot(npy.abs(hilbert(new_signal1)),colour 'navy',lw 3,label 'Hilbert Transform') plot.legend(fontsize Super simple extremely useful data scientist works with signals daily. Consolidated code: import numpy import matplotlib.pyplot plot import pandas from scipy import signal import pywt data_fft11 pds.read_csv('AEP__hourly.csv') npy.array(data_fft11.AEP_MW) data_fft11.index date_array11 pds.to_datetime(data_fft11.Datetime) plot.plot(date_array11,y) plot.xlabel('Date',fontsize plot.ylabel('MW Energy Consumption',fontsize y_detrend11 signal.detrend(y) plot.plot(date_array11, y_detrend11,colour 'firebrick',label 'Detrended Signal') plot.plot(date_array11,y, colour 'navy',label 'Raw Signal') plot.legend() plot.xlabel('Date',fontsize plot.ylabel('Temperature',fontsize npy.fft.fft(y_detrend11) new_N int(len(FFT) f_nat new_X11 npy.linspace(10 -14, f_nat/4, new_N, endpoint True) new_X11ph1111 1.0/(new_X11) FFT_abs11 npy.abs(FFT) plot.plot(new_X11ph1111,4*FFT_abs11[0:int(len(FFT) 4.)]/len(new_X11ph1111),colour 'black') plot.xlabel('Period ($h$)', fontsize plot.ylabel('Amplitude', fontsize plot.title('(Fast) Fourier Transform Method Algorithm',fontsize plot.grid(True) plot.xlim(0,400) FFT_abs11 4*FFT_abs11[0:int(len(FFT) 4.)]/len(new_X11ph1111) FFT_abs11 pds.DataFrame(FFT_abs11, columns ['Amplitude']) fft_sorted11 FFT_abs11.sort_values(by 'Amplitude',ascending False).head(40) fft_sorted11 #Define function filtering fft_filter11(th): fft_tof11 FFT.copy() fft_tof11_abs npy.abs(fft_tof11) fft_tof11_abs 4*fft_tof11_abs/len(new_X11ph1111) fft_tof11[fft_tof11_abs< return fft_tof11 fft_filter11_amp(th): fft_tof11 FFT.copy() fft_tof11_abs npy.abs(fft_tof11) fft_tof11_abs fft_tof11_abs/len(new_X11ph1111) fft_tof11_abs[fft_tof11_abs return fft_tof11_abs[0:int(len(fft_tof11_abs)/4.)] signal_handler11(signum, frame): print("Signal Number:", signum, "Frame: Frame) exit_handler11(signum, frame): print('Exiting .') exit(0) signal.signal(signal.SIGINT, signal_handler11) signal.signal(signal.SIGTSTP, exit_handler11) While print("Press Ctrl time.sleep(3) K_plot11 [10,400,700,1500] K_plot11: plot.subplot(4,4,j) plot.title('k %i'%(k)) plot.xlim(0,400) plot.plot(new_X11ph1111,4*FFT_abs11[0:int(len(FFT)/4.)]/len(new_X11ph1111),colour 'navy',alpha 0.5,label 'Original') plot.grid(True) plot.plot(new_X11ph1111,fft_filter11_amp(k),'red',label 'Filtered') plot.xlabel('Time($h$)') plot.ylabel('Amplitude') plot.legend() plot.subplots_adjust(hspace 0.50) alarms_handler11(signum, frame): print('Alarms_at:', time.ctime()) Registering alarms_signal with handler signal.signal(signal.SIGALRM, alarms_handler11) signal.alarms(3) Setting alarms after secs print('Current_time:', time.ctime()) time.sleep(6) Making delay alarms occur #Show plot different values threshold K_plot11_values [0.00,0.30,0.600,0.350] K_plot11_values: j+ plot.subplot(7,1,j) plot.plot(x,npy.fft.ifft(fft_filter11(k)),colour colours[j]) plot.title('k %.4f max' %(k)) plot.xlabel('Time (Datapoint)') plot.ylabel('Load') plot.subplots_adjust(hspace 0.8) time x.max() sample_rate11 1/300. size int(sample_rate11 time) npy.linspace(0, time, size) dataSetting11 y_detrend11 waveletname11 'sym4' levels fig, axarr11 plot.subplots(nrows levels, ncols figsize (40,10)) COEFF_D11 DATASETTING11 range(levels): (dataSetting11, coeff_d11) pywt.dwt(dataSetting11, waveletname11,mode 'per') axarr11[ii, 0].plot(dataSetting11, 'black') axarr11[ii, 1].plot(coeff_d11, 'darkorange') axarr11[ii, 0].Setting_ylabel("Level {}".format(ii fontsize rotation axarr11[ii, 0].Setting_yticklabels([]) axarr11[ii, 0].Setting_title("Approximation coefficients", fontsize axarr11[ii, 1].Setting_title("Detail coefficients", fontsize axarr11[ii, 1].Setting_yticklabels([]) #print(len(coeff_d11)) COEFF_D11.append(npy.repeat(coeff_d11,4 DATASETTING11.append(npy.repeat(dataSetting11,4 plot.tight_layout() plot.show() data pds.read_csv('shiftedsignaltest40.csv').drop('Unnamed: 0',axis new_signal1 npy.array(new_data.loc[0]) plot.plot(new_signal1,colour 'firebrick',label 'Raw Signal') plot.xlabel('X (Datapoint)') plot.ylabel('Signal') plot.plot(npy.abs(hilbert(new_signal1)),colour 'navy',lw 3,label 'Hilbert Transform') plot.legend(fontsize Output: Conclusions enjoyed article wish learn more about machine learning have question can: will inform upcoming stories allow text with questions corrections. Join suggested member read articles (and dozens other authors statistical machine learning) have newest technology without being limited "max number publications month". Next TopicScatter() plot pandas Python prev next