next prev Microservices Python Python Microservices with gRPC this tutorial, will learn about microservices, microservices important implement them using Python programming language. will also discuss gRPC with Python. current scenario, technologies more dedicated "microservices architecture" leaving behind "monolithic architecture". believe that "smaller things much easier handle", have microservices that suitably handled. need interact with different microservices. Here will learn running with Python microservices using gRPC, most popular frameworks. Let's briefly introduce Microservices them project. What Microservices? Microservices technique organizing complex software systems. similar breaking complex problem into smaller implementing Same microservices, microservices don't code, into app, developer breaks code into microservices that deployed independently communicate with each other. Implementing microservices framework essential. When plan develop framework provide critical applications, must ensure robust developer-friendly behavior. Microservices Important? Suppose developer working popular e-commerce website that sells multiple products online. several hundred workers working company. Each developer assigned write code back-end feature some product such adding item cart, generating recommendations, handling payment transaction, dealing with warehouse history. imagine, hard code giant application? hard would that understand? long would take test? definitely quite challenging especially business tries grow fast. would better have code corresponding modular product features well modular? cart microservice manage cart. inventory microservice manages inventory. Let's understand reason behind separate Python code into microservices. Modularity Modularity allows making changes with least resistance. Suppose wants feature, buy-two-books-get-one-free feature. part team that's asked launch quickly possible. code into single application, face some critical problems while implementing this feature. Here suppose solution team some code cart logic check there more than books cart. product manager also tells track this campaign's impact sales books. also simple. simply subtract cheapest book from cart total. Along with buy-two-books-get-one-free feature code, update line checkout column that updates column transaction database indicate sale part promotion buy_two_get_one_free_promo true. Done. Again another requirement comes; should valid customer. this feature, need hide this banner home page. After some years, transaction database grown large requires replacing with shared database. That might cause data loss. those references need changed. That's putting code into single application dangerous long run. best solution create transaction microservices, also scale future. Another part code communicated with transaction through abstract that hides implementation details. Flexibility Flexibility most important which comes with microservices. developer write code multiple languages. also expand microservices independently. will create sample microservices upcoming section. Robustness code into single application, also need deploy once. This could threat. When make change code, means down entire site. Ownership Microservices provide ownership their code. When single codebase shared with multiple employees where employees come There clear vision architecture code. Microservice helps give clear vision code, that code will remain clean organized. also clarifies who's responsible adding features code making changes when something goes wrong. Example Microservices will define some microservices online Books website. will create write Python code that implements them microservices. make things short easy, will define only microservices Marketplace will minimal that shows list books user. Recommendations will show books that user might interested user will interact with Marketplace microservices their browser, Marketplace microservice will interact with Recommendation microservices. Recommendation should have features User will random user Category will shirt category make more interesting. results don't want return every book stock, that will limit request. response will list books. Each book will have following data. Book numeric book. Book title: title book. have taken some limited features make simpler. define this more formally using protocol buffers. Example syntax "proto3"; enum BookCategory FICTIONAL ROMANCE SELF_HELP message RecommendationRequest int32 user_id BookCategory category int32 max_results message BookRecommendation int32 string title message RecommendationResponse repeated BookRecommendation recommendations service Recommendations Recommend (RecommendationRequest) returns (RecommendationResponse); create proto file that API. Protobuf buffers were developed Google, idea about protobuf, visit implement protobuf Python. might seem confusing first, let's break file line. First, define proto3 syntax instead older proto2 version. Then specify book categories, each category assigned numeric message contains fields each specific type. userID max_result fields int32, 32-bit integer. enum field BookCategory category type. After that, define request RecommendationRequest. Next, define message type BookRecommendation that book recommendation. consists 32-bit integer string-based title. Then define Recommendations microservice response with repeated keyword. last, define method API. understood function method class. brief idea about microservices using protobuf. will learn about popular microservice technique gRPC. What gRPC? According official documentation "gRPC Google Remote Procedure Call modern open-source high-performance framework that environment. efficiently connect services across data centers with pluggable support load balancing, tracing, health checking authentication." stands remote procedure calls which quite same normal function Python. They messages that server sends remote system task routine) completed. Google's provides facility smooth efficient communication between services. utilized different ways Generating efficient client libraries. Efficiently connecting polyglot services microservices style architecture. Connecting mobile devices, browser client backend services. gRPC? gRPC provides many advantages over other microservices. Let's understand some advantages. HTTP/2-based transport gRPC uses HTTP/2 protocol instead HTTP 1.1. HTTP/2 protocol offers various benefits over latter. provides multiple bidirectional streams that created sent over connections parallel. Documentation protocol buffer provides well-defined self-documented schema. using JSON structure, must document field type. When write code protocol buffer language, generates Python code automatically. code will never sync with documentation. document helps understand code, self-paced code better. Validation When generate basic code from protocol buffers, predefined validation. example generated code won't accept fields wrong type. generated code also built-in boilerplate. Developer-Friendliness most interesting feature that many people prefer gRPC over REST. define terms functions. Sometimes mapping functionality onto REST disturbing. have decide resources, construct path, which verbs use. REST gRPC turn into debate over preference. Protocol buffer refers serialization format data sent between microservices. Language independent communication services written various languages like Python Golang. gRPC ensures smooth communication between gRPC services gRPC client. also uses message interchange format. Protocol Buffers Protocol buffers same which provides efficient automated mechanism serializing structured data. They allow define structure data transmitted. Google claims they better than XML. features easy use. three times smaller. quite faster. less ambiguous. generates data access classes that make easier them programmatically. Protobuf defined .proto files. easy define them. Types gRPC implementation There four types gRPC implementation. Let's understand each implementation Unary RPCs simplest gRPC which executes normal function call. sends single request declared .proto file single response from server. HelloServer(RequestMessage) returns (ResponseMessage); </pre></div> <p><strong>2. Server streaming RPCs -</strong> returns streams message sequence read corresponding client message request. client reads from that stream messages until there messages.</p> <div class="codeblock"><textarea name="code" class="java"> HelloServer(RequestMessage) returns (stream ResponseMessage); </pre></div> <p><strong>3. Client Streaming RPCs -</strong> client writes message sequence using write stream sends same server. server reads message wait server read messages return response.</p> <div class="codeblock"><textarea name="code" class="java"> HelloServer(stream RequestMessage) returns (ResponseMessage); </pre></div> <p><strong>4. Bidirectional Streaming RCPs -</strong> Both gRPC client gRPC server read-write stream send message sequence. gRPC client gRPC server write read order they like.</p> <div class="codeblock"><textarea name="code" class="java"> HelloServer(stream RequestMessage) returns (stream ResponseMessage); </pre></div> class="h3">Implementation gRPC Python</h3> <p>However, gRPC supports many programming languages such Golang, C++, Java. this tutorial, will implement using Python.</p> <p>Follow below steps proceed further.</p> class="points"> <li>Create folder. Here create <strong>grpc_implementation.</strong> Open terminal direct <strong>grpc_implementation.</strong></li> <li>Create virtual environment using <strong>Python venv myenv</strong> command.</li> <li>Activate virtual environment using source myenv/bin/activate.</li> <li>Now install required dependency using <strong>pip install grpcio grpc-tools</strong>.</li> </ul> <p>We will <strong>Unary gRPC,</strong> where need define three files.</p> class="points"> <li><strong>Proto File -</strong> Proto file includes declaration service that used generate stubs (<package_name>_pb2.py <package_name>_pb2_grpc.py). These used gRPC client gRPC server.</package_name></package_name>.</li> <li><strong>gRPC client -</strong> gRPC client requests server gets some response.</li> <li><strong>gRPC Server -</strong> server sends response client.</li> </ul> <p>Let's create Unary service.</p> class="h3">Example -</h3> <div class="codeblock"><textarea name="code" class="java"> syntax "proto3"; package unary; service Unary{ simple RPC. Obtains MessageResponse given position. GetServerResponse(Message) returns (MessageResponse) message Message{ string message message MessageResponse{ string message bool received above code contains collection services. Here have implemented single service GetServerResponse(). This service takes input type Message returns MessageResponse. Once have done .proto file, need generate stubs using below command. python grpc_tools.protoc --proto_path=. ./unary.proto --python_out=. --grpc_python_out=. When press enter, will generate files. import grpc from concurrent import futures import time import unary.unary_pb2_grpc pb2_grpc import unary.unary_pb2 class UnaryService(pb2_grpc.UnaryServicer): __init__(self, *args, **kwargs): pass GetServerResponse(self, request, context): string from incoming request message request.message result f'Hello running received "{message}" message from you' result {'message': result, 'received': True} return pb2.MessageResponse(**result) 	def serve(): server grpc.server(futures.ThreadPoolExecutor(max_workers=10)) pb2_grpc.add_UnaryServicer_to_server(UnaryService(), server) server.add_insecure_port('[::]:50051') server.start() server.wait_for_termination() __name__ '__main__': server() above file, GetServerResponse() method takes 'Message' from client returns 'MessageResponse' defined proto file. have called server() function main() make sure that server listens request. Now, above server file. python3 unary_server.py Implementing Client Below implementation client. Example import grpc import unary.unary_pb2_grpc pb2_grpc import unary.unary_pb2 class UnaryClient(object): Client gRPC functionality __init__(self): self.host 'localhost' self.server_port 50051 instantiate channel self.channel grpc.insecure_channel( '{}:{}'.format(self.host, self.server_port)) bind client server self.stub pb2_grpc.UnaryStub(self.channel) get_url(self, message): Client function call GetServerResponse message pb2.Message(message=message) print(f'{message}') return self.stub.GetServerResponse(message) __name__ '__main__': client UnaryClient() result client.get_url(message="Hello Server! listening?") print(f'{result}') above code, __init__func stub variable using self.stub pb2_grpc.UnaryStub(self.channel)' have get_url() function which calls server using above initialized stub. have completed Unary gRPC service. service check output. python unary_client.py Output: message: "Hello Server listening?" message: "Hello running. Received 'Hello Server there?' message from you" received: true Bidirectional Implementation also define bidirectional services below. Example syntax "proto3"; package bidirectional; service Bidirectional Bidirectional streaming RPC. Accepts stream Message sent while route being traversed, GetServerResponse(stream Message) returns (stream Message) message Message string message above code, have declared Birectional named service. contains collection services. Currently, have implemented only service GetServerResponse(). This service accepts input type Message returns Message. follow same process generate stubs. generate stub, need below command. python grpc_tools.protoc --proto_path=. ./bidirecctional.proto --python_out=. --grpc_python_out=. above command will generate files bidirectional_pb2.py bidirectional_pb2_grpc.py. These files will used generate gRPC server client. implement this service taking above example reference also refer official documentation. Advantages Disadvantages Microservices have discussed important aspect microservices, what microservices are, also discussed importance using microservices software architecture project. Below short descriptions cons microservices. Pros Cons Each service independent runs own. shows latency communication between services response. takes less development time services modularity. hard perform testing between multiple microservices. Infrastructure scaling depends individual services. cost supporting multiple instances scale quickly. features added remove easily. There information barriers additional layer data provisioning. code organized business logic. Some cases span across multiple services. independence from code stack. supports multiple code stacks system. Awesome failure isolation. Additional work needed create DTOs failure mechanisms. Conclusion Microservices most appropriate manage complex system. They provide natural organize code. Once familiar with gRPC implement microservices Python effectively, become step ahead development field. this tutorial, have discussed microservices, implement Python microservices effectively with gRPC, types microservices, advantages disadvantages microservices. have also discussed gRPC, emerging framework that makes communication between microservices smooth effective. Next TopicFunctools Module Python prev next