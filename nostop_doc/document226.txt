next prev Python Module this tutorial, will learn understand code. What Module? stands Abstract Syntax Tree, which potent tool Python programming language. allows interact with Python code itself modify Have ever thought about Python code gets run? there magic behind those don't know, Python interpreter responsible running Python code. follows pre-written instructions that translate Python code into instructions that machine run. Following process converting Python code into machine code. When code, code parsed into smaller chunks called tokens. These tokens created predefined instructions that should treat differently. example keyword else different keyword than numeric value like tokens stored list transformed build Abstract Syntax tree, AST. collection more nodes linked together based grammar Python language. compiler produce lower-level instruction known binary code from AST. This code very generic that computer easily. When interpreter gets instructions-like byte code, interpreter code. byte code responsible calling function operating system, which will eventually interact with memory program. above description rough sketch interpreter runs Python code using AST. Mode Code Compilation There three modes available compile code. They given below. exec This mode used execute normal Python code. eval This mode used evaluate Python's expression will return result after evaluation. single This mode works Python shell that executes statement time. Executing Python Code Using module, Python code. Let's understand following example. Example import code ast.parse("print('Hello Learner Welcome JavaTpoint')") print(code) exec(compile(code, filename="", mode="exec")) Output: <_ast.Module object 0x0000010B889A6AC0> Hello Learner! Welcome JavaTpoint Evaluate Python Expression module allows evaluate Python expression return result from expression. Let's understand following example. Example import expression '6 8' code ast.parse(expression, mode='eval') print(eval(compile(code, mode='eval'))) print(ast.dump(code)) Output: Expression(body=BinOp(left=Constant(value=6, kind=None), op=Add(), right=Constant(value=8, kind=None))) Creating Multi-line ASTs previous example, have seen single line dump them. Now, will learn create multi-line AST. First, let's understand following example. Example import tree_ast ast.parse(''' subjects ['computer science', 'alorithm'] name 'Ricky' subjects: print('{} learn {}'.format(name, subjects)) ''') print(ast.dump(tree_ast)) Output: Module(body=[Assign(targets=[Name(id='subjects', ctx=Store())], value=List(elts=[Constant(value='computer science', kind=None), Constant(value='alorithm', kind=None)], ctx=Load()), type_comment=None), Assign(targets=[Name(id='name', ctx=Store())], value=Constant(value='Ricky', kind=None), type_comment=None), For(target=Name(id='fruit', ctx=Store()), iter=Name(id='fruits', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{} learn {}', kind=None), attr='format', ctx=Load()), args=[Name(id='name', ctx=Load()), Name(id='subjects', ctx=Load())], keywords=[])], keywords=[]))], orelse=[], type_comment=None)], type_ignores=[]) NodeTransformer NodeVisitor NodeTransformer class used take different types modify according requirement. module also provides NodeVisitor class, which helps call visit function every time through tree. that more control nodes, let's understand following example. Example import class Visitor(ast.NodeVisitor): visit_Str(self, node): print('String Node: "' node.s '"') class MyTransformer(ast.NodeTransformer): visit_Str(self, node): return ast.Str('str: node.s) parsed ast.parse("print('Hello World')") MyTransformer().visit(parsed) Visitor().visit(parsed) Output: Welcome Javatpoint Explanation above code, have imported module that parses code. Then have defined Visitor class that inherits NodeVisitor class. Every time finds string node; gets transformed adding that prefix. also module when directly source code. Let's understand following example. Example import from pprint import pprint main(): with open("ast_module.py", "r") source: ast_tree ast.parse(source.read()) analysis Analyzer() analysis.visit(ast_tree) analysis.report() class Analyzer(ast.NodeVisitor): __init__(self): self.stats {"import": "from": node_visit(self, node): alias node.names: self.stats["import"].append(alias.name) self.generic_visit(node) node_visitFrom(self, node): alias node.names: self.stats["from"].append(alias.name) self.generic_visit(node) report(self): pprint(self.stats) __name__ "__main__": Output: {'from': ['pprint'], 'import': ['ast']} Explanation above code converts Python file into abstract syntax tree. Then analyze tree helpful information. have opened Python file read mode then create named ast_tree. Then, parse() function processed tokens, followed language rules, build tree data structure that consists much useful information. tree nothing collection nodes, where tree variable referenced "root" node. Thus, visit each node tree perform operations. But, first, visit each node processing data. Analyze Once tree, Analyzer follows visitor pattern. Using NodeVisitor class, track node Python. need implement method visit_<node type> visit particular node type. previous example, used below script. Example class Analyzer(ast.NodeVisitor): node_visit(self, node): alias node.names: self.stats["import"].append(alias.name) self.generic_visit(node) node_visitFrom(self, node): alias node.names: self.stats["from"].append(alias.name) self.generic_visit(node) code accepts name module stores list statistics. With help NodeVisitor class, analyze tree. analyzer Analyzer() analyzer.visit(tree) visit() method will work same visit_<node type> method. Using Analysis Tool After Python code turned into byte code, can't readable humans. makes interpreter fast, which means byte code designed machine, humans. consists enough structured information, which makes them helpful learning about Python code. However, ASTs still user-friendly, they much understandable than byte code representation. When Python module? Abstract Syntax Tree quite helpful code coverage tools. parses source code finds possible flaws errors code. also used custom Python interpreter. used analyze static code. makes IDEs intelligent, which known IntelliSense. Conclusion have learned about module Python, which responsible running Python code. Then, have built tree from Python code perform analysis using NodeVisitor class. Next TopicPython Requests Module HTTP Request prev next