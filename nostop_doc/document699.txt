next prev Tkinter Application Switch Between Different Page Frames Python There other frameworks Python, only Tkinter included core library. Tkinter number advantages. same code runs Windows, macOS, Linux since cross-platform. Since Tkinter uses native operating system components produce visual elements, applications created with appear though they belong platform being used them. Despite being facto Python framework, Tkinter without detractors. noteworthy complaint that GUIs created using Tkinter appear antiquated. Tkinter might what you're searching want sleek, contemporary interface. contrast other frameworks, Tkinter lightweight generally simple use. This makes appealing option creating apps Python, especially those where modern polish unnecessary constructing something cross-platform functionally sound rapidly goal. Python provides variety choices development (Graphical User Interface). Tkinter approach used most frequently among approaches. typical Python interface Python-supplied toolkit. fastest simplest approach construct apps with Python Tkinter. Tkinter makes building simple process. Importing tkinter module create tkinter application. Make primary window (container). many widgets like main window. Apply widgets' event triggers. Tkinter imported into Python code just like other module. Keep mind that module's name "tkinter" Python "Tkinter" Python 2.x. import tkinter occasion, must develop application with numerous pop-up dialogue windows, also known Page Frames. Here step-by-step tutorial join multiple Tkinter Page Frames together! more complicated Python applications, such building user interfaces Virtual Laboratories experiments, classrooms, etc., this used boilerplate. first, let's know brief about concepts which used tkinter programs. Significant Concepts Even example ahead will also demonstrate following crucial ideas Widgets components Tkinter user interface called widgets. Each widget represented instance Python class, such ttk.Frame, ttk.Label, ttk.Button. Widget hierarchy There hierarchy widget placement. frame, which itself contained within root window, held label button. Each child widget created with parent widget first argument, which then supplied widget function constructor. Options configuration Widgets include configuration settings that change they look behave, like text that appears labels buttons. There will several possibilities various classes widgets. Geometry control When they generated, widgets immediately added user interface. Where they positioned within user interface controlled geometry manager like grid. Event loop Only when event loop actually being executed Tkinter does respond user input, changes made your programme, even refreshes display. Your user interface won't change your software isn't using event loop. These some steps that followed Make three distinct pages. start page serves home page followed pages two. Design enclosure each page frame. Four classes available. first tkinterApp class, where three frames were created function show_frame defined. This function executed each time button clicked user. StartPage straightforward buttons Page Page buttons Page Page going back using Back home Page. buttons Page also returning StartPage Page This straightforward Tkinter frame navigation programme. Several features added, this used boilerplate applications that more complicated. illustrated class tkinterApp, StartPage serves app's initial page. There buttons this area StartApp. access button's associated Page clicking These pages include graphs, graphics, sophisticated functionality. buttons also included pages. When button pressed, show_frame function executed, displaying corresponding Page. Explaining code steps First, just need make minor change SeaofBTCapp class. This complete class class SeaofBTCapp(tk.Tk): __init__(self, *args, **kwargs): tk.Tk.__init__(self, *args, **kwargs) container tk.Frame(self) container.pack(side="top", fill="both", expand True) container.grid_rowconfigure(0, weight=1) container.grid_columnconfigure(0, weight=1) self.frames (StartPage, PageOne, PageTwo): frame F(container, self) self.frames[F] frame frame.grid(row=0, column=0, sticky="nsew") self.show_frame(StartPage) show_frame(self, cont): frame self.frames[cont] frame.tkraise() used configure() function call widget learn what configuration options available. This method produces dictionary with detailed information about each widget, including default current values. obtain only names each option, keys(). Observe this important change being made here (StartPage, PageOne, PageTwo): frame F(container, self) self.frames[F] frame frame.grid(row=0, column=0, sticky="nsew") Here, fill this tuple with potential pages application. These pages will load result. We're using StartPage show first __init__ method, later call show frame raise additional frame window want. Similar HTML tables function, grid() method used determine label's relative layout (position) within widget that contains came with Pages Two. Here StartPage class because need access these pages from StartPage class StartPage(tk.Frame): __init__(self, parent, controller): tk.Frame.__init__(self,parent) label tk.Label(self, text="Start Page", font=LARGE_FONT) label.pack(pady=10,padx=10) button tk.Button(self, text="Visit Page command=lambda: controller.show_frame(PageOne)) button.pack() button2 tk.Button(self, text="Visit Page command=lambda: controller.show_frame(PageTwo)) button2.pack() Here, widget's appearance within container behaviour when main application window resized controlled keyword-option/value pairs that passed pack() method. NOTE Keep mind that widgets don't show until their geometry been using geometry manager. Leaving geometry specification common early error that leads surprise when widget generated does show widget won't show until, instance, packer's pack() method been used We've included buttons that controllers above. PageOne PageTwo passed inputs show frame function. only thing left create PageOne PageTwo classes. These simple create almost identical StartPage class PageOne(tk.Frame): __init__(self, parent, controller): tk.Frame.__init__(self, parent) label tk.Label(self, text="Page One!!!", font=LARGE_FONT) label.pack(pady=10,padx=10) button1 tk.Button(self, text="Back Home", command=lambda: controller.show_frame(StartPage)) button1.pack() button2 tk.Button(self, text="Page Two", command=lambda: controller.show_frame(PageTwo)) button2.pack() class PageTwo(tk.Frame): __init__(self, parent, controller): tk.Frame.__init__(self, parent) label tk.Label(self, text="Page Two!!!", font=LARGE_FONT) label.pack(pady=10,padx=10) button1 tk.Button(self, text="Back Home", command=lambda: controller.show_frame(StartPage)) button1.pack() button2 tk.Button(self, text="Page One", command=lambda: controller.show_frame(PageOne)) button2.pack() Here, buttons places they lead only significant modifications. Ultimately, mainloop() method displays everything keeps running until programme finished. Complete Code #Python program creating application switch pages using trinket. import tkinter LARGE_FONT= ("Verdana", class SeaofBTCapp(tk.Tk): __init__(self, *args, **kwargs): tk.Tk.__init__(self, *args, **kwargs) container tk.Frame(self) container.pack(side="top", fill="both", expand True) container.grid_rowconfigure(0, weight=1) container.grid_columnconfigure(0, weight=1) self.frames (StartPage, PageOne, PageTwo): frame F(container, self) self.frames[F] frame frame.grid(row=0, column=0, sticky="nsew") self.show_frame(StartPage) show_frame(self, cont): frame self.frames[cont] frame.tkraise() class StartPage(tk.Frame): __init__(self, parent, controller): tk.Frame.__init__(self,parent) label tk.Label(self, text="Start Page", font=LARGE_FONT) label.pack(pady=10,padx=10) button tk.Button(self, text="Visit Page command=lambda: controller.show_frame(PageOne)) button.pack() button2 tk.Button(self, text="Visit Page command=lambda: controller.show_frame(PageTwo)) button2.pack() class PageOne(tk.Frame): __init__(self, parent, controller): tk.Frame.__init__(self, parent) label tk.Label(self, text="Page One!!!", font=LARGE_FONT) label.pack(pady=10,padx=10) button1 tk.Button(self, text="Back Home", command=lambda: controller.show_frame(StartPage)) button1.pack() button2 tk.Button(self, text="Page Two", command=lambda: controller.show_frame(PageTwo)) button2.pack() class PageTwo(tk.Frame): __init__(self, parent, controller): tk.Frame.__init__(self, parent) label tk.Label(self, text="Page Two!!!", font=LARGE_FONT) label.pack(pady=10,padx=10) button1 tk.Button(self, text="Back Home", command=lambda: controller.show_frame(StartPage)) button1.pack() button2 tk.Button(self, text="Page One", command=lambda: controller.show_frame(PageOne)) button2.pack() SeaofBTCapp() app.mainloop() Output Next TopicAppend (key: value) Pair Dictionary prev next