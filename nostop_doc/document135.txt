next prev Python Unit Testing this tutorial, will implement unit testing using Python. Unit testing using Python huge topic itself, will cover essential concepts. What Python unittest? Unit testing technique which particular module tested check developer himself whether there errors. primary focus unit testing test individual unit system analyze, detect, errors. Python provides unittest module test unit source code. unittest plays essential role when writing huge code, provides facility check whether output correct not. Normally, print value match with reference output check output manually. This process takes lots time. overcome this problem, Python introduces unittest module. also check application's performance using will learn create basic test, finds bugs, execute before code delivers users. Testing Code test code using many ways. this section, will learn basic steps towards advanced methods. Automate Manual Testing Manual testing another form, which known exploratory testing. testing which done without plan. manual testing, need prepare list application; enter different inputs wait expected output. Every time give inputs change code, need through every single feature list check most common testing also time-consuming process. other hand, automated testing executes code according code plan which means runs part code that want test, order which want test them script instead human. Python offers tools libraries which help create automated tests application. Unit Tests Integration Tests Suppose want check lights might test them. would turn light outside friend that lights not. turning light will consider test step, outside friend will know test assertion. integration testing, test multiple components once. These components anything code, such functions, classes module that have written. there limitation integration testing; what integration test doesn't give expected result. this situation, will very hard recognize which part system falling. Let's take previous example; light didn't turn battery might dead, blub broken, car's computer have failed. That's consider unit testing know exact problem tested code. Unit testing smaller test, checks single component that working right not. Using unit test, separate what necessities fixed system. have seen types testing far; integration test checks multiple components; where unit test checks small component application. Let's understand following example. apply unit testing Python built-in function sum() against known output. check that sum() number equals assert sum([ "Should Above line will return right result because values correct. pass wrong arguments will return Assertion error. example assert sum([1, "Should Traceback (most recent call last): File "<stdin>", line <module> AssertionError: Should above code into file execute again command line. test_sum(): assert sum([2, should __name__ "__main__": test_sum() print("Everything passed") Output: python sum.py Everything correct following example, will pass tuple testing purpose. Create file named test_sum2.py. Example test_sum2(): assert sum([2, should test_sum_tuple(): assert sum((1, should __name__ "__main__": test_sum2() test_sum_tuple() print("Everything correct") Output: Everything correct Traceback (most recent call last): File "<string>", line <module> File "<string>", line test_sum_tuple AssertionError: should Explanation above code, have passed wrong input test_sum_tuple(). output dissimilar predicted result. above method good what there multiple errors. Python interpreter would give error immediately first error encountered. remove this problem, test runners. Test runner applications specially designed testing output, running test give tools fixing diagnosing tests applications. Choosing Test Runner Python contains many test runners. most popular build-in Python library called unittest. unittest portable other frameworks. Consider following three most test runners. unittest nose nose2 pytest choose them according requirements. Let's have brief introduction. unittest unittest built into Python standard library since 2.1. best thing about unittest, comes with both test framework test runner. There requirements unittest write execute code. code must written using classes functions. sequence distinct assertion methods TestCase class apart from built-in asserts statements. Let's implement above example using unittest case. Example import unittest class TestingSum(unittest.TestCase): test_sum(self): self.assertEqual(sum([2, 5]), should 10") test_sum_tuple(self): self.assertEqual(sum((1, 5)), should 10") __name__ '__main__': unittest.main() Output: FAIL: test_sum_tuple (__main__.TestingSum) Traceback (most recent call last): File "<string>", line test_sum_tuple AssertionError: should ---------------------------------------------------------------------- tests 0.001s FAILED (failures=1) Traceback (most recent call last): File "<string>", line <module> File "/usr/lib/python3.8/unittest/main.py", line 101, __init__ self.runTests() File "/usr/lib/python3.8/unittest/main.py", line 273, runTests sys.exit(not self.result.wasSuccessful()) SystemExit: True output, shows dot(.) successful execution failure. nose Sometimes, need write hundreds thousands test lines application; becomes difficult understand. nose test runner suitable replacement unittest test runners because compatible with tests writing using unittest framework. There types nose nose nose2. recommend using nose2 because latest version. Working with nose2, need install using following command. install nose2 following command terminal test code using nose2. python nose2 output follows. FAIL: test_sum_tuple (__main__.TestSum) Traceback (most recent call last): File "test_sum_unittest.py", line test_sum_tuple self.assertEqual(sum((2, 5)), should 10") AssertionError: should tests 0.001s FAILED (failures=1) nose2 provides many command line flags filtering test. learn more from official documentation. pytest pytest test runner supports execution unittest test cases. actual benefit pytest writing pytest test cases. pytest test cases generally sequence methods Python file starting. pytest provides following benefits supports built-in assert statement instead using special assert*() methods. also provides support cleaning test cases. rerun from last cases. ecosystem hundreds plugin extend functionality. Let's understand following example. Example test_sum(): assert sum([2, should test_sum_tuple(): assert sum((1, should Writing First Test Here will apply concepts that have learned earlier section. First, need create file name test.py anything. Then make inputs execute code being tested, capturing output. After successfully code, match output with expected result. First, create file my_sum file write code sum(arg): total arg: total return total initialized total variable which iterates over values arg. Now, create file name test.py with following code. Example import unittest from my_sum import class CheckSum(unittest.TestCase): test_list_int(self): data result sum(data) self.assertEqual(result, __name__ '__main__': unittest.main() Output: ---------------------------------------------------------------------- test 0.000s Explanation: above code, imported sum() from my_sum package that created. have defined Checkclass, which inherits from unittest.TestCase. There test methods .test_list_int(), test integer. After running code, returns dot(.) which means there error code. Let's understand another example. Example class Person: name1 set_name(self, user_name): self.name1.append(user_name) return len(self.name1) get_name(self, user_id): user_id len(self.name1): return such user Find' else: return self.name1[user_id] __name__ '__main__': person Person() print('Peter Decosta been added with person.set_name('Peter')) print('The user associated with person.get_name(0)) Output: Peter Decosta been added with user associated with Peter Python Basic Functions Unit Test Output unittest module produces three possible outcomes. Below potential outcomes. tests passed, will return Failure will raise AssertionError exception, tests failed. Error errors occur instead Assertion error. Let's following basic functions. Method Description .assertEqual(a, .assertTrue(x) bool(x) True .assertFalse(x) bool(x) False .assertIs(a, .assertIsNone(x) None .assertIn(a, .assertIsInstance(a, isinstance(a, .assertNotIn(a, .assertNotIsInstance(a,b) isinstance(a, .assertIsNot(a, Python Unit Test Example import unittest First import class which want test. import Person1 PerClass class Test(unittest.TestCase): basic class that inherits unittest.TestCase person PerClass.Person() instantiate Person Class user_id This variable stores obtained user_id user_name This variable stores person name test case function check Person.set_name function test_0_set_name(self): print("Start set_name test\n") range(4): initialize name name 'name' str(i) name into list variable self.user_name.append(name) extraxt user obtained from function user_id self.person.set_name(name) check obtained user null self.assertIsNotNone(user_id) store user list self.user_id.append(user_id) print("The length user_id len(self.user_id)) print(self.user_id) print("The length user_name len(self.user_name)) print(self.user_name) print("\nFinish set_name test\n") Second test case function check Person.get_name function test_1_get_name(self): print("\nStart get_name test\n") total number stored user information length len(self.user_id) print("The length user_id length) print("The lenght user_name len(self.user_name)) range(6): exceed total length then verify returned name length: name matches will fail test case self.assertEqual(self.user_name[i], self.person.get_name(self.user_id[i])) else: print("Testing get_name user test") length exceeds then check such user' type message self.assertEqual('There such user', self.person.get_name(i)) print("\nFinish get_name test\n") __name__ '__main__': begin unittest.main() unittest.main() Output: Start set_name test length user_id length user_name ['name0', 'name1', 'name2', 'name3'] Finish set_name test Start get_name test length user_id lenght user_name Testing get_name user test ====================================================================== FAIL: test_1_get_name (__main__.Test) ---------------------------------------------------------------------- Traceback (most recent call last): File "C:/Users/DEVANSH SHARMA/PycharmProjects/Hello/multiprocessing.py", line 502, test_1_get_name self.assertEqual('There such user', self.person.get_name(i)) AssertionError: 'There such user' such user Find' There such user such user Find ---------------------------------------------------------------------- tests 0.002s FAILED (failures=1) Advance Testing Scenario must follow given step while creating test application. Generate necessary input Execute code, taking output. Match output with expected result. Creating inputs such static value input like string numbers slightly complex task. Sometimes, need create instance class context. input data that create known fixture. reuse fixtures application. When code repeatedly pass different values each time expecting same result, this process known parameterization. Handling Expected Failures earlier example, pass integer number test sum(); what happens pass value, such single integer string? sum() will throw error expected. would happen failed test. .assertRaises() handle expected errors. used inside with statement. Let's understand following example. Example import unittest from my_sum import class CheckSum(unittest.TestCase): test_list_int(self): Test that list integers data sum(data) self.assertEqual(res, test_bad_type(self): data "Apple" with self.assertRaises(TypeError): sum(data) __name__ '__main__': unittest.main() Output: ---------------------------------------------------------------------- tests 0.006s Python unittest Skip Test skip individual test method TestCase using skip test technique. fail will count failure TestResult. Consider following example skip method unconditionally. Example import unittest add(x,y): return class SimpleTest(unittest.TestCase): @unittest.skip("The example skipping method") testadd1(self): self.assertEquals(add(10,5),7) __name__ '__main__': unittest.main() Output: ---------------------------------------------------------------------- test 0.000s (skipped=1) Explanation: above example, skip() method prefixed @token. takes argument message where describe reason skip. character denotes that test been successfully skipped. skip particular method block based specific condition. Example import unittest class suiteTest(unittest.TestCase): test_add(self): self.a self.b self.assertEqual(res, 100) @unittest.skipIf(a "Skip because greater than test_sub(self): self.a self.b self.assertTrue(res -10) @unittest.skipUnless(b "Skip because eqaul zero") test_div(self): self.a self.b self.assertTrue(res @unittest.expectedFailure test_mul(self): self.a self.b self.assertEqual(res __name__ '__main__': unittest.main() Output: Fsx. ====================================================================== FAIL: test_add (__main__.suiteTest) ---------------------------------------------------------------------- Traceback (most recent call last): File "C:/Users/DEVANSH SHARMA/PycharmProjects/Hello/multiprocessing.py", line 539, test_add self.assertEqual(res, 100) AssertionError: ---------------------------------------------------------------------- tests 0.001s FAILED (failures=1, skipped=1, expected failures=1) Explanation: output, conditions true test_mul() method skipped. other hand, test_mul been marked expected failure. Conclusion have discussed all-important concept related Python unit testing. beginner, need write smart, maintainable methods validate code. Once decent command over Python unit test, switch other frameworks such pytest leverage more advanced features. Next TopicPython Forensics Virtualization prev next