next prev Data Structures Algorithms Python Data structures algorithms concept programming that every programmer perfect create code efficiently making best available resources. Irrespective programming language, more general concept. This tutorial covers basic foundation using Python programming language. Data structures: "Data structures" says all. data structure structures data. storage unit that organizes stores data programmer easily access. real world, programmer/ coder's work involves huge amounts data. Analyzing using data made easy programmer when arranged right way. Apart from organizing data, Data structures also makes processing accessing data easy. This tutorial covers Python's Data structures. There built-in data structures well user-defined data structures. Let's first look built-in ones: Lists list like dynamic heterogeneous array. Arrays used languages like Unlike arrays, lists dynamically-sized store data different types. sequential data types Python. Important points about Lists: Lists mutable, meaning that after creation, modify their elements. consists data separated commas inside square braces-[]. Lists allow duplicate elements. indexing access list elements length negative indexing allowed -length). nest another data structure element inside list. Nesting another list makes multi-dimensional list. Using Slicing, sub-lists list which need slice operator [:]. List comprehension used create lists from existing lists other data structures. faster than creating list using regular loop. functions like max(), min() sum() find maximum, minimum elements list. concatenate lists using repeat elements using operators. take list input, input() then split(separator) convert string into list. Most used Functions Methods: List.len() find length list List.append() element list. List.insert() element specified index. List.remove() remove specified element from list. List.reverse() Returns reverse ordered list. List.index() Returns first-found index specified element. List.extend() Adds elements another list elements specified list. List.pop() Removes returns last element specified list. String.split() Converts given string into list Example: #Creating list emptylist mylist [20, 'H', "Hello"] nestedlist [[1, mylist] print("Created lists:") print("emptylist:", emptylist) print("mylist:", mylist) print("nestedlist:", nestedlist) print("Concatenating mylist nestedlist:", mylist nestedlist) print("Repeating elements list:", mylist*3) #List input print("\nList input:",end="") inputlist list(map(int, input("Enter elements(separate space):").split())) print(inputlist) #Accessing elements print("In nested list: print("(Normal)nestedlist[0]:", nestedlist[0]) print("(Negative)nestedlist[-2]:", nestedlist[-2]) #adding elements print() print("Adding elements into empty list:") emptylist.append(1) range(3, emptylist.append(i) print("emptylist:", emptylist) emptylist.insert(1, print("Adding index emptylist[1]:", emptylist) print("Extending mylist with emptylist:", mylist.extend(emptylist)) #Using Slicing print("Slicing mylist[:]:", mylist[:]) print("Reverse using slicing[::-1]:", mylist[::-1]) print("Slicing using indices[1:3]:", mylist[1:3]) #list comprehension print() print("Creating newlist[] using list comprehension:") newlist emptylist i%2 print("newlist with even elements emptylist:", newlist) #Using built-in functions print("\nUsing functions:") print("Length using len():", len(mylist)) print("Removing element using remove:", mylist.remove(20)) print("Removing last element using pop:", mylist.pop()) print("Using index():",mylist.index(3)) print("Using reverse on",emptylist,":") emptylist.reverse() print(emptylist) Output: Created lists: emptylist: mylist: [20, 'H', 'Hello'] nestedlist: [[1, [20, 'H', 'Hello']] Concatenating mylist nestedlist: [20, 'H', 'Hello', [20, 'H', 'Hello']] Repeating elements list: [20, 'H', 'Hello', 'H', 'Hello', 'H', 'Hello'] List input: Enter elements(separate space):8 nested list: (Normal)nestedlist[0]: (Negative)nestedlist[-2]: Adding elements empty list: emptylist: Adding index emptylist[1]: Extending mylist with emptylist: None Using Slicing Slicing mylist[:]: [20, 'H', 'Hello', Reverse using slicing[::-1]: 'Hello', 'H', Slicing using indices[1:3]: [20, 'H'] Creating newlist[] using list comprehension: newlist with even elements emptylist: Using functions: Length using len(): Removing element using remove: None Removing last element using pop: Using index(): Using reverse Tuples: Tuple like immutable list. also sequence data type Python store data different data types, like list, unlike list, cannot alter tuple once created; Python raises error try. Example: nestedtuple ([1, mytuple) nestedtuple.append(1) print(nestedtuple[0]) Output: nestedtuple.append(1) AttributeError: 'tuple' object attribute 'append.' above tuple nested tuple with list first element. can't modify tuple, modify list inside Example: nestedtuple[0].append(1) print(nestedtuple[0]) print(nestedtuple) Output: ([1, 'h', 'Hello')) Important points about Tuples: tuple consists data separated commas inside parenthesis, although parenthesis mandatory followed readability convention. Creating tuple without parenthesis called "Tuple packing" access tuple, also "Tuple unpacking". Tuples allow duplicate elements like lists. indexing access tuple elements length negative indexing allowed -length). nest another data structure element inside tuple. Nesting another tuple makes multi-dimensional tuple. Using Slicing, sub-tuples tuple which need slice operator [:]. concatenate tuples, repeat, reassign delete whole tuple once created, can't perform operations like append, remove, insert elements delete elements which means cannot disturb original elements from when created-Tuples immutable. perform operations can't perform tuple, generally convert tuple into list using list(), what want then convert back tuple using tuple(). tuple immutable, used dictionaries. Iterating through tuple much faster than iterating through list. Most used Functions Methods: Tuple.len() find length tuple sorted(Tuple) Sorts specified tuple max(Tuple) find maximum valued element tuple. min(Tuple) find minimum valued element tuple. sum(Tuple) find elements tuple. Tuple.index() Returns first-found index specified element. all(Tuple) Returns True elements tuple True. any(Tuple) Returns true atleast element tuple True. Tuple.count(element) Returns number occurrences specified element tuple. len(), sorted(), max(), min(), sum(), all(), any() work iterable data type Python. confuse sort() with sorted(). sort() limited lists. Example: #Creating tuple emptytuple mytuple 'h', "Hello") nestedtuple ([1, mytuple) print("Emptytuple:",emptytuple) print("mytuple:",mytuple) print("nestedtuple:",nestedtuple) mytuple1 1,'Hi' print("By Tuple packing:", mytuple1) list1 print("Using tuple():", tuple(list1)) tuple2 (1,) print("Tuple with element:", tuple2) print("Concatenating nestedtuple mytuple:", nestedtuple mytuple) print("Repeating elements tuple:", mytuple*3) #Tuple input print("\nTuple input:",end="") inputtuple tuple(map(int, input("Enter elements(separate space):").split())) print(inputtuple) #Using Slicing print("\nSlicing mytuple[:]:", mytuple[:]) print("Reverse using slicing[::-1]:", mytuple[::-1]) print("Slicing using indices[1:3]:", mytuple[1:3]) #Accessing elements print("\nAcccessing elements:") print("In nestedtuple[0]:", nestedtuple[0]) print("In nestedtuple[-2]:", nestedtuple[-2]) mytuple print("By tuple unpacking:",a,b,c) #Using built-in functions print("\nUsing built-in functions: print("Length mytuple:", len(mytuple)) print("Sorting tuple using sorted():", sorted((2, 0))) print("Using max():", max((8, 1))) print("Using min():", min((3, 2))) print("Using sum():", sum((3, 3))) print("Using all():", all((3, 9))) print("Using any():", any((2, 9))) print("Using count():", 1).count(1)) Output: Emptytuple: mytuple: 'h', 'Hello') nestedtuple: ([1, 'h', 'Hello')) Tuple packing: 'Hi') Using tuple(): Tuple with element: (1,) Concatenating nestedtuple mytuple: ([1, 'h', 'Hello'), 'h', 'Hello') Repeating elements tuple: 'h', 'Hello', 'h', 'Hello', 'h', 'Hello') Tuple input: Enter elements(separate space):3 Slicing mytuple[:]: 'h', 'Hello') Reverse using slicing[::-1]: ('Hello', 'h', Slicing using indices[1:3]: ('h', 'Hello') Accessing elements: nestedtuple[0]: nestedtuple[-2]: tuple unpacking: Hello Using built-in functions: Length mytuple: Sorting tuple using sorted(): Using max(): Using min(): Using sum(): Using all(): False Using any(): True Using count(): Sets: collection unique elements which does support duplicate elements like lists tuples. Another important point about Sets that they unordered, which makes accessing their elements using indexes impossible. Important points about Sets: enclosed mutable data type iterable. Even though mutable, duplicates policy unordered nature, elements immutable. delete elements from set, can't perform slicing indexing operations set. There another category immutable sets called Frozen sets. Internally, elements arranged based hashing hash tables. more than element placed index, values arranged linked list that index position. Every index position acts key, members/ values index stored values inside dictionary. internal working makes more time-optimized. won't allow mutable items elements like lists: set1 {[1, print(set1) Output: set1 {[1, 3}	 TypeError: unhashable type: 'list' Most used Functions Methods Sets: Function/ method Equivalent operator Explanation Set.add(value) Adds specified element into set. Set1.union(Set2) Set1 Set2 Merges given sets Set1.intersection(Set2) Set1 Set2 Finds common elements given sets. Set1.difference(Set2) Set1 Set2 Finds elements Set1 that Set2 Set.clear() Empties given set. set() create convert other data types into set. Set1.isdisjoint(Set2) check Set1 Set2 have elements common. Operators: Equality: Set1 Set2 Set1 Set2 Checks Set1 equal Set2 Set1 equal Set2 Subset: Set1 Set2 Set1 Set2 Checks if:1. Set1 subset Set2 Set1 proper subset Set2 Superset: Set1 Set2 Set1 Set2 Checks Set1 superset Set2 Set1 proper subset Set2 Set1 Set2 Returns elements either Set1 Set2 both sets. Example: #Creating print("Creating set:") emptyset set() print("Empty set:", emptyset) myset print("Myset:", myset) nestedset {(1, print("Nestedset:", nestedset) set1 set([1, print("Removing duplicacy using set():", set1, inputset set(map(int, input("Enter elements: ").split())) print("inputset:", inputset) #Frozen sets myfrozenset frozenset([1, print("\nFrozen set:", myfrozenset) #Using functions emptyset.add('a') print("\nAdding emptyset:",emptyset) print("Union of", myset,"and", nestedset,":") print(myset.union(nestedset)) print("Intersection of", myset,"and", nestedset,":") print(myset.intersection(nestedset)) print("Difference of", myset,"and", nestedset,":") print(myset.difference(nestedset)) emptyset.clear() print("Clearing emptyset:", emptyset) #Set operators print("\nMembership operator check nestedset:",(1, nestedset) print("Equivalency myset nested set:", myset nestedset) print("Subset operator check subset nestedset:", nestedset) print("proper subset operator check proper subset nestedset:", nestedset) print("Superset operator check nestedset superset {1}:", nestedset {1}) print("proper superset operator check nestedset proper superset {1}:", nestedset {1}) print("Elements either myset nestedset both:", myset nestedset) Output: Creating set: Empty set: set() Myset: Nestedset: Removing duplicacy using set(): Enter elements: inputset: {10, 12} Frozen set: ({1, Adding emptyset: {'a'} Union Intersection Difference Clearing emptyset: set() Membership operator check nestedset: True Equivalency myset nested set: False Subset operator check subset nestedset: False proper subset operator check proper subset nestedset: False Superset operator check nestedset superset {1}: False proper superset operator check nestedset proper superset {1}: False Elements either myset nestedset both: write emptyset dictionary will created create empty set. Hence, need set(). add(element) will cause error frozen mutable. Dictionary dictionary collection {key: value} pairs. Keys values, access values, places indexes, need keys. unordered collection data. Important points about Dictionary: Keys identify values. Hence, unique immutable. Only immutable data types accepted keys. data type used make value data. There cannot duplicate keys, duplicate values allowed. also dictionary comprehension create dictionary like list comprehension. dictionary's keys like Roll numbers students, values students' names. Most used dict Functions Methods: keys() Returns list keys dictionary values() Returns list values dictionary items() Returns list key, value pairs tuples dictionary pop() Deletes returns value specified dict() Creates dictionary converts list key-value tuples into dictionary. get() Returns value given update() Extends dictionary with given key: value pairs. Example: #Creating dictionary emptydict mydict1 'A', 'B', 'C'} mydict2 'D', 'E': mydict3 dict([(6, 'F'), 'G')]) nesteddict mydict1, mydict2} inputdict #Taking dict input keys keys map(int, input("Enter keys: ").split(" keys: inputdict[i] input("Enter value str(i) +": print("Created dictionaries:") print("Emptydict:", emptydict) print("mydict1:", mydict1) print("mydict2:", mydict2) print("mydict3:", mydict3) print("nesteddict:", nesteddict) print("inputdict:", inputdict) #Operations dictionary mydict2['E'] mydict2[5] mydict2['E'] mydict2['E'] print("\nAltering mydict2:", mydict2) mydict3[8] 'H' mydict3[9] 'I', 'J', 'K' print("Adding elements mydict3:", mydict3) #Using built-in functions print("\nUsing get() access: mydict1.get(1): mydict1.get(1)) print("Using keys() on",mydict1,":", mydict1.keys()) print("using values() on",mydict1,":", mydict1.values()) print("Using items() on",mydict1,":", mydict1.items()) print("Updating",mydict1,"with",mydict2,":") mydict1.update(mydict2) print(mydict1) print("Deleting value using pop():", mydict1.pop(2), mydict1) Output: Enter keys: Enter value Enter value Enter value Created dictionaries: Emptydict: mydict1: 'A', 'B', 'C'} mydict2: 'D', 'E': mydict3: 'F', 'G'} nesteddict: 'A', 'B', 'C'}, 'D', 'E': 5}} inputdict: 'a', 'b', 'c'} Altering mydict2: 'D', 'E'} Adding elements mydict3: 'F', 'G', 'H', ('I', 'J', 'K')} Using get() access: mydict1.get(1): Using keys() 'A', 'B', 'C'} dict_keys([1, using values() 'A', 'B', 'C'} dict_values(['A', 'B', 'C']) Using items() 'A', 'B', 'C'} dict_items([(1, 'A'), 'B'), 'C')]) Updating 'A', 'B', 'C'} with 'D', 'E'} 'A', 'B', 'C', 'D', 'E'} Deleting value using pop(): 'A', 'C', 'D', 'E'} Strings: string array bytes/ characters. declare string character array. Python, there character data type. Characters exist, they recognized strings with length string immutable, meaning can't modify once created. Important points about Strings: string enclosed single, double, even triple quotes. Generally, triple quotes used create multi-line string. bytes/ characters string accessed using indices length-1). Negative indexing also allowed -length). Accessing character string range causes IndexError. Only integers indices, using other data type causes TypeError. Using Slicing, obtain copies sub-strings from original string. Deleting manipulating string's characters causes error string immutable data type. Using keyword, delete whole string. also reassign strings existing string variables. quotes enclose string, Python won't able print quote part string printed. assumes reached string. Hence, need "Escape sequences". Using {}.format() method, hold space formatting printing variables following order. update/ manipulate characters string: string "Hello" string[2] Output: TypeError: 'str' object does support item assignment Example: string "Hello" string[2] Output: TypeError: 'str' object doesn't support item deletion style string formatting done using operator. Using formatting, even change representation value string. Example: represent floating-point number, %a.bf where represents number digits want representation represents number digits want after decimal point. number 0.2567 print("%3.2f" %number) Output: 0.26 Example: #Creating string string1 'Hi' string2 "Hi" string3 """Hello Man""" print("Created strings:") print(string1) print(string2) print(string3) #Accessing characters print("\nThe first character string1[0]:", string1[0]) print('The first character string[-2]:', string1[-2]) #Slicing print("\nSubstrings string3:") print("string3[0:6]:", string3[0:6], print("string3[-6:-1]:", string3[-6:-1]) print("Reversing using slicing-string3[::-1]:", string3[::-1]) #Taking input inputstring input("Enter string: print("inputstring::", inputstring) #Updation print("\nReassigning string2 Hello:") print("Present:", string2) string2 'Hello' print("After reassigning:", string2) #Escape sequences print('\nUsing escape sequences escape single quotes, double quotes backslashes') print('Hi it\'s pen') print("I read book called \"It ends with us\" yesterday") print("The file stored path: C:\\Media\\Documents\\") print("Printing line: Hi\nman") print("Urging space: Hi\tman") #String formatting print("\nThe {1}: {2}".format(4,5,4+5)) print("The difference between {a} {b}: {c}".format(a=5, b=4, c=5+4)) print("The product %d: %d"%(a,b,a*b)) Output: Created strings: Hello first character string1[0]: first character string[-2]: Substrings string3: string3[0:6]: Hello string3[-6:-1]: Ma Reversing using slicing-string3[::-1]: naM olleH Enter string: What's inputstring:: What's Reassigning string2 Hello: Present: After reassigning: Hello Using escape sequences escape single quotes, double quotes backslashes it's read book called ends with us" yesterday file stored path: C:\Media\Documents\ Printing line: Urging space: Hi	man difference between product Strings most used data types Python. Hence, number concepts, methods functions strings adequate libraries Python. Some very important Functions Methods: String.split(separator) Splits string concerning specified separator returns list separated substrings. default separator white space. String.strip() Returns string eliminating leading trailing unnecessary spaces. "string".join() Joins elements iterable with specified string converts string. String.upper String.lower Converts lowercase characters uppercase. Converts uppercase characters lowercase. String.replace(substring1, substring2) Replaces substring1 with substring2 string. String.find(substring) Searches character substring returns index first occurrence. String.count(substring) Returns number times substring occurred string. Bytearray: First: byte bits(varies system-wise). bytearray, name suggests, array bytes. collection bytes. represent integers ranging from 256. sequence data types Python. string sequence Unicode characters, bytearray sequence bytes. Important points about Bytearray: bytearray mutable, while another similar data type Python-bytes immutable. bytearray constructed using predefined function bytearray(). same function used convert other data types into bytearray. Indexing bytearray faster than other sequences, given direct access bits array element. Bytearray mostly used optimization code memory usage. Example: #Creating bytearray list1 bytearray(list1) print("Created bytearray:", print("Type:", type(BA)) #Accessing iterating print("\nElements bytearray:") BA: print(i) print("BA[2]:", BA[2]) #Manipulating BA[2] print("\nModifying BA[2] 20:", BA.append(7) print("Adding elements:", Output: Created bytearray: bytearray(b'\x01\x02\x03\x04') Type: <class 'bytearray'> Elements bytearray: BA[2]: Modifying BA[2] bytearray(b'\x01\x02\x06\x04') Adding elements: bytearray(b'\x01\x02\x06\x04\x07') bytearray(): function construct bytearray object convert other objects bytearray object. syntax function: have three optional parameters: bytearray(source, encoding, error_aid) Example: bytearray() print(BA) Output: bytearray(b'') Summary: this tutorial, learned about built-in data structures Python: Lists Tuples Sets, Frozen sets Strings Dictionaries Bytearrays second part this tutorial, we'll learn about user-defined data structures like Linked lists, Trees, heaps Python. Next TopicGaussian Elimination Python prev next