next prev Data Structures Algorithms Python This lesson serves simple introduction Python's data structures algorithms. With practical thoroughly explained illustrations, will over built-in data structures like lists, sets, dictionaries, tuples, etc., well other user-defined data structures like linked trees, lists, graphs, well some commonly used algorithms. Lists Likewise, arrays other computer languages lists Python collections items arranged manner. permits many data types elements list. Python's version lists comparable C++'s vectors Java's array lists. components must relocated, adding removing member from list's head most expensive operation. pre-allocated memory used insertion deletion element list also become costly. Code Python program show create Python List some operations Creating Python list List ["Python", "Data", "Structures", "Tutorial"] print("The created Python list print(List) Creating multi-dimensional list using nested lists (list inside list) List_ [["Python", "Data"], ["Structures", "Tutorial"]] print("The multi-Dimensional list print(List_) access list elements using index element print("Single element: List[1]) print("Multiple elements (slicing): List[0:2]) print("For nested lists: List_[1][0]) access elements using negative indices also printing last element list print("Last element: List_[-1]) Slicing list using negative indexing print("Last elements: List[-1:-3:-1]) Last first order Output created Python list ['Python', 'Data', 'Structures', 'Tutorial'] multi-Dimensional list [['Python', 'Data'], ['Structures', 'Tutorial']] Single element: Data Multiple elements (slicing): ['Python', 'Data'] nested lists: Structures Last element: ['Structures', 'Tutorial'] Last elements: ['Tutorial', 'Structures'] Tuple Lists Python tuples equivalent, unlike lists, tuples immutable, meaning that once formed, cannot change them. Tuple include components several types, just like List. Python tuples made grouping together series values. These values delimited "comma", regardless whether parenthesis used. Code Python program show create Python Tuple access elements Creating Python tuple Tuple ("Python", "Data", "Structures", "Tutorial") print("The Python tuple print(Tuple) Create tuple using Python list list print("Tuple using List: Tuple_ tuple(list) Accessing tuple elements using indices print("Single element: Tuple[1]) print("Multiple elements (slicing): Tuple[0:2]) Using negative indexing printing last element list print("Last element: Tuple[-1]) Trying modify tuple try: Tuple[1] "Tuple" print(Tuple) except Exception print("Exception raised: Output Python tuple ('Python', 'Data', 'Structures', 'Tutorial') Tuple using List: Single element: Data Multiple elements (slicing): ('Python', 'Data') Last element: Tutorial Exception raised: 'tuple' object does support item assignment Python data structure non-duplicate data collection that modifiable. Sets mainly used membership screening removing redundant entries. These processes Hashing data structure, popular method traversal, insertion, deletion elements that typically takes O(1) time. Code Python program show create Python operations Creating Python {"Python", "Data", "Structures", "Tutorial"} print("The Python print(Set) Accessing elements ind, enumerate(Set): print(ind, Finding intersection sets Set_ "Python", "Data"} print("Intersection: Set.intersection(Set_)) Union sets print("Union: Set.union(Set_)) Output Python {'Python', 'Data', 'Tutorial', 'Structures'} Python Data Tutorial Structures Intersection: {'Python', 'Data'} Union: 'Structures', 'Python', 'Tutorial', 'Data'} Dictionary key-value pair-formatted data collection called Python dictionary used store data. temporal complexity this data structure O(1), much like hash tables other coding languages. Python Dictionary indexed with help keys. values keys type, i.e., constant item like string, integer, sequence, etc. build dictionary using curly brackets dictionary comprehension. Code Python program show create Python Dictionary operations Creating Python Dictionary Dict {"1": "Python", "2": "Data", "3": "Structures", "4": "Tutorial"} print("The Python Dictionary print(Dict) accessing dictionary element using keys print("Value Dict["2"]) accessing elements using built-in method print("Using method: Dict.get("2")) Output Python Dictionary {'1': 'Python', '2': 'Data', '3': 'Structures', '4': 'Tutorial'} Value Data Using method: Data Linked List linear data structure called linked list elements that kept consecutive locations memory. linked list's elements connected pointers. pointer first node linked list serves representation linked list. head refers node. head's value NULL linked list empty. list, each node least components: Data Pointer (Or Reference) next node Code Python program show implementation linked list Creating node class class Node: __init__(self, value): self.value value self.next None Creating linked list class class LinkedList: __init__(self): self.head None Initializing linked list list_ LinkedList() Creating nodes list_.head Node("Python") second_node Node("Tutorial") third_node Node("Data Structures") Connecting nodes list_.head.next second_node second_node.next third_node Printing linked list while list_.head None: print(list_.head.value, "\n") list_.head list_.head.next OutputPython Tutorial Data Structures Linked lists important data structures. Here essential operations linked list. Code Python programs show linked list operations Creating node class class Node: __init__(self, value): self.value value self.next None Creating linked list class class Linked_List: __init__(self): self.head None Inserting node beginning list insertInBeginning(self, value): insertion_node Node(value) insertion_node.next self.head self.head insertion_node Inserting node after particular node insertAfterNode(self, previous_node, value): previous_node None: print("There previous node. Make head.") return insertion_node Node(value) insertion_node.next previous_node.next previous_node.next insertion_node Inserting node list insertInEnd(self, value): insertion_node Node(value) self.head None: self.head insertion_node return last_node self.head while (last_node.next): last_node last_node.next last_node.next insertion_node Deleting particular node deleteANode(self, pos): self.head None: return temporary self.head self.head temporary.next temporary None return Finding which deleted range(pos temporary temporary.next temporary None: break list temporary None: return temporary.next None: return next_ temporary.next.next temporary.next None temporary.next next_ Searching element list search(self, key): current_node self.head while current_node None: current_node.value key: return True current_node current_node.next return False Sorting linked list sortList(self, head): current_node head index_node Node(None) head None: return else: while current_node None: index_node current_node.next while index_node None: current_node.value index_node.value: current_node.value, index_node.value index_node.value, current_node.value index_node index_node.next current_node current_node.next Printing linked list printLinkedList(self): temporary self.head while (temporary): print(str(temporary.value) temporary temporary.next __name__ '__main__': listt Linked_List() listt.insertInEnd(7) listt.insertInBeginning(4) listt.insertInBeginning(9) listt.insertInEnd(2) listt.insertAfterNode(listt.head.next, print('Linked list:') listt.printLinkedList() print("\nAfter deleting node:") listt.deleteANode(2) listt.printLinkedList() value_to_find listt.search(value_to_find): print("\n", value_to_find, found list") else: print("\n", value_to_find, found list") listt.sortList(listt.head) print("Sorted Linked List: listt.printLinkedList() Output Linked list: After deleting node: found list Sorted Linked List: Stack stack linear data structure that uses either first-in last-out (FILO) last-in first-out (LIFO) ordering store objects. stack, item deleted only from while item other. Push common names actions insert deletion. Basic Operations Stack carry various activities stack using fundamental operations. Push: This method adds item stack Pop: This method will remove item from stack IsEmpty: This method checks whether stack empty not. IsFull: This method checks whether stack full not. Peek: This method will return element remove Code Python program show create stack implement operations Creating stack create(): new_stack return new_stack check empty stack check(stack): len(stack) return True else: return False Adding elements stack push(stack, value): stack.append(value) print("New stack after pushing: stack) Eleminating item from stack pop(stack): (check(stack)): return "Given Stack Empty." stack.pop() print("New stack after popping: stack) Peeking into stack peek(stack): print("Last element stack: stack[-1]) Driver code above methods stack create() push(stack, push(stack, push(stack, push(stack, pop(stack) peek(stack) Output stack after pushing: stack after pushing: stack after pushing: stack after pushing: stack after popping: Last element stack: Queue queue, which holds objects First First (FIFO) order, another linear data structure similar stack. queue removes items order that most recently added them. line users waiting access service where user arrived first serviced first excellent illustration queue. Operations Linked Queue Include: Enqueue: Adds piece content queue. Overflow conditions defined when queue filled. time complexity adding element queue: O(1) Dequeue: Takes something queue. things popped same sequence that values enqueued. It's called underflow condition queue empty. Getting first item queue O(1) time complexity. Rear: Obtain last item queue. time complexity last item queue O(1). Code Python program create queue implement operations queue Creating class queue class Queue: Initializing queue __init__(self): self.queue Adding element queue enqueue(self, element): self.queue.append(element) print("New queue after enqueuing: self.queue) Removing element queue dequeue(self): len(self.queue) return None else: return self.queue.pop(0) print("New queue after dequeuing: self.queue) rear(self): print("Last element: self.queue[-1]) Drivers code above methods queue Queue() queue.enqueue(6) queue.enqueue(3) queue.dequeue() queue.enqueue(9) queue.rear() Output queue after enqueuing: queue after enqueuing: queue after enqueuing: Last element: Heap heap data structure, which mainly designed describe priority queue, provided Python heapq module. characteristic heap data structure that anytime item popped, always returns smallest item (min-heap). Items always pushed popped while heap structure preserved. Additionally, heap[0] item consistently returns smallest value. enables O(log n)-time retrieval insertion lowest value element. Heaps often come varieties: Max-Heap: Max-Heap data structure's root node's must rank highest amongst child's keys. same condition should recursively true every sub-tree Binary Tree. Min-Heap: Min-Heap's root node's should least common child's keys. same condition should recursively true every sub-tree Binary Tree. Code Python program implement heap data structure Python Defining method create heap heapify(array, largest array[j] array[a]: largest array[largest] array[b]: largest largest array[j],array[largest] array[largest], array[j] heapify(array, largest) insert_element(array, value): len(array) array.append(value) else: array.append(value); range((s//2)-1, -1): heapify(array, delete(array, value): len(array) range(0, array[j]: break array[j], array[s array[s array[j] array.remove(value) range((len(array)//2)-1, -1): heapify(array, len(array), Drivers code above methods heap insert_element(heap, insert_element(heap, insert_element(heap, insert_element(heap, insert_element(heap, print("Heap array: heap) delete(heap, print("After deleting item: heap) Output Heap array: After deleting item: Binary Tree nonlinear hierarchy data structure called tree comprises nodes edges. Python tree data structure known binary tree allows each parent node have maximum children. binary tree three components each node: data element address left child address right child Code Python program show create binary tree traverse Python Creating class Node tree class Node: __init__(self, value): self.left None self.val value self.right None Method transverse pre-order manner traverseAsPreOrder(self): print(self.val, self.left None: self.left.traverseAsPreOrder() self.right None: self.right.traverseAsPreOrder() Method transverse in-order manner traverseAsInOrder(self): self.left None: self.left.traverseAsInOrder() print(self.val, self.right None: self.right.traverseAsInOrder() Method transverse post-order manner traverseAsPostOrder(self): self.left None: self.left.traverseAsPostOrder() self.right None: self.right.traverseAsPostOrder() print(self.val, Drivers code above binary tree class root_node Node(4) root_node.left Node(5) root_node.right Node(7) root_node.right.left Node(2) root_node.right.left.right Node(9) root_node.left.right Node(0) root_node.left.left Node(10) root_node.left.left.right Node(1) Transferring tree print("Pre-order traversal tree: root_node.traverseAsPreOrder() print("\nIn-order traversal tree: root_node.traverseAsInOrder() print("\nPost-order traversal tree: root_node.traverseAsPostOrder() Output Pre-order traversal tree: In-order traversal tree: Post-order traversal tree: Bubble Sort Algorithm sorting method known bubble sort analyses nearby items swaps those until desired order achieved. Each item list moves list each iteration. This similar behaviour bubbles liquid that come surface. Consequently, known bubble sort. Code Python program implement Bubble Sort Algorithm Creating method perform bubble sort bubbleSort(listt): looping over each element list range(len(listt)): looping over remaining elements compare with current element range(0, len(listt) comparing adjacent elements sorting descending order listt[n] listt[n 1]: Swapping elements they correct order temporary listt[n] listt[n] listt[n listt[n temporary Drivers code above method listt bubbleSort(listt) print('Sorted List Descending Order:') print(listt) Output Sorted List Descending Order: Selection Sort Algorithm sorting algorithm known selection sort chooses maximum element unsorted list every iteration inserts start list. Code Python program implement Selection Sort Defining method perform Selection Sort selectionSort(listt, size): range(size): max_index range(s size): sorting descending order Selecting maximum element listt listt[i] listt[max_index]: max_index putting maximum value beginning list (listt[s], listt[max_index]) (listt[max_index], listt[s]) Drivers code listt [20, size len(listt) selectionSort(listt, size) print('Sorted List Descending Order:') print(listt) Output Sorted List Descending Order: [97, Quicksort Algorithm array split into smaller arrays using divide-and-conquer strategy sorting algorithm known Quicksort (item taken from array). When splitting given array, pivot component should that items value greater than pivot component located right side, components with value less than pivot value stored left side. same method used divide right left subarrays. This procedure repeated until only element remains each subarray. elements have already been sorted this point. combination items creates sorted array end. Code Python program perform Quick Sort Algorithm Defining function search pivoting position pivot(listt, low, high): selecting right-most element pivot pivot listt[high] greater item transversing through elements range(low, high): listt[i] pivot: value smaller, will swap with pointer swap elements (listt[g], listt[i]) (listt[i], listt[g]) swapping pivot with element greater value (listt[g listt[high]) (listt[high], listt[g returning position from where pivot done return defining function perform Quick Sort quickSortAlgo(listt, low, high): high: searching pivot which elements left smaller elements right greater pivot(listt, low, high) calling left pivot recursively quickSortAlgo(listt, low, calling right pivot recursively quickSortAlgo(listt, high) Drivers code listt size len(listt) quickSortAlgo(listt, size print('Sorted List Ascending Order:') print(listt) Output Sorted List Ascending Order: Counting Sort Algorithm sorting method known counting sort arranges given array elements according number times every distinct element appears given array. Sorting done mapping count elements array index another array made This array stores count elements. Code Python program perform Counting Sort Defining function perform Counting Sort countingSort(listt): len(listt) size Initializing counting list Creating list counts elements range(0, c[listt[i]] Storing cumulative count range(1, 10): c[j] c[j Finding indices every item initial list count list placing elements counting list while o[c[listt[j]] listt[j] c[listt[j]] Copying sorted list elements into original list range(0, listt[k] o[k] Drivers code listt countingSort(listt) print("Sorted list: print(listt) Output Sorted list: Binary Search Algorithm Binary Search searching algorithm finding element's position sorted array. this approach, element always searched middle portion array. Code Python program perform Binary Search Defining function perform Binary Search binarySearch(listt, h): will pointers iteration find element while h: mid_element (h l)//2 listt[mid_element] return mid_element elif listt[mid_element] mid_element else: mid_element return Drivers code listt index binarySearch(listt, len(listt)-1) index print("The element searched present str(index)) else: print("Not found") Output element searched present Next TopicGUI Shut Down, Restart, computer using Tkinter Python prev next