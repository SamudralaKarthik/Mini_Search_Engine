next prev Functools Module Python functools module, which included Python's standard library, provides essential functionality working with high-order functions function that returns function takes another function argument reuse enhance utility your functions callable objects without having rewrite them using these capabilities. This simplifies process building reusable maintainable code. functools module functions current stable release, Python series, although some these accessible work differently prior later editions. They follows: reduce() lru_cache() partial() partialmethod() singledispatch() singledispatchmethod() cached_property() total_ordering() update_wrapper() wraps() cmp_to_key() Reduce(): We'll start with classic. function iterable passed reduce(function, sequence) function. applies supplied function members iterable cumulative manner from left right before returning single value. Simply said, first applies argument function iterable's first items, value returned this initial call becomes function's first argument, while third element iterable becomes second argument. This method done until iterable tables. lru_cache(): cache() decorator that wraps function memoizing callable that saves maximize results function call returns stored value when function called again with same inputs. When expensive bound function called repeatedly with same arguments, save time. primarily employs data structures: dictionary function's parameters output linked list maintain track function's call history. Cache stands Least-Recently-Utilized Cache full, refers cache that eliminates least recently used element when maximum number entries reached. maxsize None, feature disabled, typed True, feature caches arguments various data types separately, e.g., f(3) f(3.0) will cached separately. general, cache should only used when previously computed values need reused. result, caching functions that produce different mutable objects each call isn't good idea. positional keyword inputs function must also hashable, dictionary required cache results. partial(): Partial functions derived functions with some input parameters that have already been assigned. function takes parameters, "b," partial function with prefilled argument built from then called with only parameter. partial() method Functool used construct partial functions/objects, which important feature because allows for: Replication existing functions with some parameters already set. well-documented manner, create newer version existing function. partial function also valuable characteristics that used track partial functions objects. These some them: args Returns preassigned positional arguments partial function. keywords Returns pre-assigned keyword arguments partial function. func Returns name parent function well location. partialmethod(): partialmethod() method provides partial method descriptor, which similar partial intended used method specification rather than callable method. think method's partial(). singledispatch(): Before into detail about this function, it's crucial first review concepts: first generic function, which function made numerous functions that perform same task different types. dispatch algorithm determines which implementation will utilized during call. second Single dispatch, which type generic function dispatch which implementation determined single argument's type. With this mind, singledispatch decorator functool converts basic function into generic function whose behavior determined type first parameter. used function overloading plain English. singledispatchmethod(): It's decorator that works same @singledispatch, methods instead functions. cached_property(): cached property() decorator changes class method into property whose value calculated only once then cached normal attribute throughout life instance, name suggests. Except caching functionality, it's comparable @property. It's handy attributes instances that normally functionally permanent computationally expensive. total_ordering(): Given class that defines more rich comparison ordering methods (equivalent ==), such __lt__(), __le__(), __gt__(), __ge__(), __eq__()). define comparison methods, @total ordering will supply rest based definitions provide. It's critical that class includes __eq__() method. want make class that compares different numbers, example. rich comparison methods would almost certainly need implemented. However, because this likely tiresome unnecessary, just implement __eq__ __gt__ methods rely @total ordering fill gaps. update_wrapper(): makes wrapper function's metadata look like wrapped function. case partial functions, update wrapper(partial, parent) will update partial function's documentation( name( name match parent function's. wraps(): It's just shortcut calling update wrapper() decorated function. It's same calling partial(update wrapper, wrapped=wrapped, assigned=assigned, updated=updated, wrapped=wrapped). cmp_to_key(); converts function from old-style comparison function. callable that accepts parameters, compares them returns negative number less-than, zero equality, positive number greater-than referred comparison function. operator.itemgetter() function example callable that accepts argument returns another value used sort key. Tools like sorted(), min(), max(), itertools.groupby functions cmp key() mostly used transition Python scripts with comparison functions. look code: Code: sample program understand case scenario various functions which offered this Python module, this program have written class which have separate functions which some functions main caller functions represent various case scenarios different functions which provided this Python module. these different functions used represent particular case scenario these functions uses these functions vary according need requirement user. functions which actually called showcase scenario actually calling inbuilt functions this module that actually implements functionality those functions #All required functions imported from package that those functions later section code from functools import lru_cache, singledispatch from time import time from functools import singledispatchmethod from functools import reduce import from functools import partial this sample class which have number function representing different case areas multiple methods which provided this module, each function required prompts user appropriate input perform respective calculations provided data prints output. class my_functools_class: sample constructor written that used initialize class variable above-written class. 	def __init__(self): 		pass this first function that explains least recently used cache registers actually change sequential execution code parallel execution. this function, calling different functions first function that calling implemented with inbuilt least recently used cache register functionality with this inbuilt function code execution time reduced drastically whereas other hand side calling another function which using this inbuilt functionality other function which calling execution time will much greater compared first one. Both these called functions performing operation calculating Fibonacci series difference between both these functions that first function implemented with inbuilt least recently used cache register functionality whereas, other hand, second function just normal function. both these functions also making recursion. user asked each these functions many iterations wants run. entering number iterations calculations performed specific time difference also displayed between time taken both these functions. 	def use_lru_cache(self): 		start_time time() 		result 		print("For many iterations want calculate::") 		iters int(input()) 		for range(iters): 			result result self.calculate_with_lru_cache(i) 		print("Function with lru_cache took seconds calculate fibonacci iterations.".format( start_time-time(), iters)) 		start_time time() 		result 		for range(iters): 			result result self.calculate_without_lru_cache(i) 		print("Function without lru_cache took seconds calculate fibonacci iterations.".format( start_time-time(), iters)) #This function that making least recently used cache resistor functionality which provided this Python module, with help this functionality code execution time reduced drastically observe this reduction time when printing time taken this function calculate Fibonacci series. 	@lru_cache(maxsize=128) 	def calculate_with_lru_cache(self, num): 		if 			return 		else: 			return(self.calculate_with_lru_cache(num-1) self.calculate_with_lru_cache(num-2)) Where other hand side this simple function that simply making recursion calculate Fibonacci series since there registers used this function time taken this function calculate Fibonacci series comparatively very high compared what have seen last function. 	def calculate_without_lru_cache(self,num): 		if 			return 		else: 			return(self.calculate_without_lru_cache(num-1) self.calculate_without_lru_cache(num-2)) this simple function that prints division numbers which integer type return type result float type. only condition calling this function that both parameters that passed arguments this function must integer type after performing division these input parameters result returned back floating value 	@singledispatchmethod 	def divide_the_numbers(self,number_1:int,number_2:int)->float: return number_1/number_2 this function kind exception handling above Return function which actually takes input strings number returns string output main difference between above Return function this function that input parameters above Return function integer type input parameters this functions string type returning value above Return function floating value whereas this function returning value also string 	@divide_the_numbers.register(str) 	def _(self,number_1:str,number_2:str)->str: return f"{number_1}/{number_2}" this caller function above written functions division operation this function first calling divide numbers function with integer parameters that resultant value that received floating value that printed after calling this calling same function this time parameters same function string type, passing string parameters input arguments this function that returning value this function been changed string value verify this observation comparing result both function calls with different input parameters with integer types other with strings 	def use_single_dispatch(self): 		print("calling divide function with integer parameters( divide_the_numbers(6/4) result 		print(self.divide_the_numbers(6,4)) 		print("calling divide function with string parameters( divide_the_numbers('12'/'7') result 		print(self.divide_the_numbers('12','7')) this function will usage reduced functionality offered this Python module this function first user asked length list, entering length list user asked elements list entering elements list user printed with list elements which user entered using reduce function print elements entered list resultant stored variable printed user, after calculating elements list next calculating maximum element present entered list resultant maximum element stored variable printed user. point noted this function that different operations like calculation elements finding maximum element from entered list using same reduce function which offered Python module just changing parameters this same function getting different results different operations 	def use_reduce(self): 		print("Enter length list ::") 		lens int(input()) 		list_obj list() 		for range(lens): 			list_obj.append(int(input())) 		print("entered list {}".format(list_obj)) 		print("Using reduce find elements list:: 		resultant_sum reduce(lambda x,y: x+y, list_obj) 		print("Result {}".format(resultant_sum)) 		print("Using reduce find maximum among elements list:: 		maxer reduce(max, list_obj) 		print("Max element {}".format(maxer)) This simple function which accepts string parameters where first parameter occupation second parameter articles gadgets used that occupation, this function simply prints string saying that particular gadgets used this occupation 	def print_occupation_and_gadgets(self,occupation,used_gadgets): 		print("{} used {}".format(used_gadgets,occupation)) this caller function which represents case scenario partial function which offered this Python module, this function, calling above-written function which having string parameters, calling this above-written function each time have pass string variables with help partial function functionality which offered this Python module, input parameters which required this function. this function first were calling power button function without partial function this case user asked occupation gadgets twice. after this, calling above-written function with help partial show with help partial first fixing occupation parameter above-written functions, asking user occupation only once call this function given times just taking gadgets input device. main difference between needs observe here that during first call need take input times both occupation gadgets, whereas with help partial function need take input gadget twice occupation, only input good which have fixed with help partial function which offered this Python module. 	def use_of_partial(self): 		print("Calling function twice without partial") 		for range(2): 			print("Enter occupation::") 			occ input() 			print("Enter gadgets used::") 			gads input() 			self.print_occupation_and_gadgets(occ,gads) 		print("Calling function twice with partial") 		print("Enter occupation::") 		occ input() 		new_caller_obj partial(self.print_occupation_and_gadgets,occ) 		for range(2): 			print("Enter gadgets used::") 			gads input() 			new_caller_obj(gads) After writing function definitions have written main function that used call above-written functions. object above-written class created which used call different functions written this class. first user printed with five options from which select which operation functionality this module wants test observe, entering appropriate choice respective function called with help class object created, similarly, this operation performed recursive manner till user wants exit code there some unhandled exception encountered.	 main(): class_obj my_functools_class() while(True): print("Enter your choice according below-listed options::") print("1. lru_cache() function compare time difference between function with without lru_cache().") print("2. singledispatch() function compare time usage functions with without singledispatch().") print("3. reduce() function understand various use-cases reduce().") print("4. partial() function compare usage functions with without partial().") print("5. exit from code execution.") menu_choice input() menu_choice int(menu_choice) menu_choice class_obj.use_lru_cache() elif menu_choice class_obj.use_single_dispatch() elif menu_choice class_obj.use_reduce() elif menu_choice class_obj.use_of_partial() elif menu_choice sys.exit() print("To move ahead with code execution enter else [n]") continue_or_exit input() continue_or_exit continue_or_exit 'Y': pass elif continue_or_exit continue_or_exit 'N': sys.exit() __name__ '__main__': main() Output: Enter your choice according below-listed options:: lru_cache() function compare time difference between function with without lru_cache(). singledispatch() function compare time usage functions with without singledispatch(). reduce() function understand various use-cases reduce(). partial() function compare usage functions with without partial(). exit from code execution. many iterations want calculate:: Function with lru_cache took -2.7494192123413086 seconds calculate Fibonacci iterations. Function without lru_cache took -1.7327818870544434 seconds calculate Fibonacci iterations. move ahead with code execution enter else Enter your choice according below-listed options:: lru_cache() function compare time difference between function with without lru_cache(). singledispatch() function compare time usage functions with without singledispatch(). reduce() function understand various use-cases reduce(). partial() function compare usage functions with without partial(). exit from code execution. calling divide function with integer parameters( divide_the_numbers(6/4) result calling divide function with string parameters( divide_the_numbers('12'/'7') result 12/7 move ahead with code execution enter else Enter your choice according below-listed options:: lru_cache() function compare time difference between function with without lru_cache(). singledispatch() function compare time usage functions with without singledispatch(). reduce() function understand various use-cases reduce(). partial() function compare usage functions with without partial(). exit from code execution. Enter length list:: 230 entered list [100, 234, 665, 230, 874] Using reduce find elements list:: result 2103 Using reduce find maximum among elements list:: element move ahead with code execution enter else Enter your choice according below-listed options:: lru_cache() function compare time difference between function with without lru_cache(). singledispatch() function compare time usage functions with without singledispatch(). reduce() function understand various use-cases reduce(). partial() function compare usage functions with without partial(). exit from code execution. Calling function twice without partial Enter occupation:: Driver Enter gadgets used:: Cars Cars used Driver Enter occupation:: Electrician Enter gadgets used:: Screwdriver Screwdrivers used Electrician Calling function twice with partial Enter occupation:: Teacher Enter gadgets used:: Books Books used Teacher Enter gadgets used:: Pens Pens used Teacher move ahead with code execution enter else Enter your choice according below-listed options:: lru_cache() function compare time difference between function with without lru_cache(). singledispatch() function compare time usage functions with without singledispatch(). reduce() function understand various use-cases reduce(). partial() function compare usage functions with without partial(). exit from code execution. Enter length list:: 87732 34853 3421 45214 entered list [87732, 34853, 3421, 45214] Using reduce find elements list:: result 171220 Using reduce find maximum among elements list:: element 87732 move ahead with code execution enter else Enter your choice according below-listed options:: lru_cache() function compare time difference between function with without lru_cache(). singledispatch() function compare time usage functions with without singledispatch(). reduce() function understand various use-cases reduce(). partial() function compare usage functions with without partial(). exit from code execution. sample program understand case scenario various functions which offered this Python module, this program have written class which have separate functions which some functions main caller functions represent various case scenarios different functions which provided this Python module. these different functions used represent particular case scenario these functions uses these functions vary according need requirement user. functions which actually called showcase scenario actually calling inbuilt functions this module that actually implements functionality those functions have look some advantages Functools Module Python: Caching: Let's start with functools module's most basic most powerful functions. cache, cache, cached property caching functions (and also decorators). first cache, which provides least recently used cache function results, other words, result memoization want more granular caching, typed=true argument, which caches arguments different types individually. function called cache another caching decorator functools. It's simple wrapper cache that omits size option, making smaller after doesn't need evict data, doesn't need evict values. also cached property, which another decorator caching. This used caching class attribute results, might expect. This particularly beneficial have property that both expensive compute immutable. advantage cached property that only executes lookups, allowing change attribute. previously cached value will used after attribute updated; instead, value will computed cached. Clearing cache likewise possible; have delete attribute. Comparing Ordering: presumably already know that __lt__, __gt__, __eq__ implement comparison operators like Python. pain implement __eq__, __lt__, __le__, __gt__, __ge__ functions. Fortunately, functools module offers @total ordering decorator, which assist with this have implement __eq__ remaining methods, decorator will take care rest. Overloading: were probably taught that function overloading isn't feasible Python, it's actually quite simple using functions from functools module: singledispatch and/or singledispatchmethod. These methods implementation Multiple Dispatch algorithm, which allows dynamically typed programming languages like Python distinguish between types runtime. Support asynchronous operations: variety external libraries frameworks, many them have functions interfaces that require pass callback functions, such asynchronous actions event listeners. That's new, what also need give other arguments addition callback function? This where functools come partial useful because used freeze some all) arguments function, resulting object with simpler function signature. usually wish iterate over lines when reading file, case binary data, might prefer traverse over fixed-sized records instead. This accomplished writing partial callable that reads defined chunk data passes iter, which generates iterator from This iterator then executes read method until file reached, always accepting only data indicated RECORD SIZE parameter. When file's reached, sentinel value (b") returned, loop ends. Decorators: We've already discussed several decorators prior parts, decorators purpose constructing more decorators. functools.wraps such decorator. this article, have understood Functools Module Python. Next TopicPlotting Google using gmplot package Python prev next