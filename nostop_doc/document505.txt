next prev PyQt library Python Even mobile applications seem overtake market software development, there still demand traditional Graphical User Interface (GUI) desktop applications. developers fascinated creating these kinds applications Python programming language, there large variety libraries select from, involving Tkinter, PyQt, wxPython, PySide2, many others. following tutorial, will understand develop desktop applications using Python programming language PyQt. Understanding PyQt library Python PyQt Graphical User Interface widgets toolkit. works Python interface most prominent famous cross-platform libraries. PyQt library developed RiverBank Computing Ltd. download latest edition PyQt from official website https://riverbankcomputing.com/software/pyqt/download. PyQt library available versions: PyQt4: version that built against PyQt5: version that only built against Even though PyQt4 built against 5.x, only small subset that also compatible with will supported. This statement implies that decide utilize PyQt4, will probably miss features improvements PyQt5 library. also refer official documentation PyQt4 more information this topic https://www.riverbankcomputing.com/static/Docs/PyQt4/qt_v5.html. will covering PyQt5 library following tutorial, appears future library. From onwards, consider mention PyQt reference PyQt5. PyQt5 based version contains classes that cover Graphical User Interfaces well network communication, threads, multimedia, handling, regular expressions, databases, multimedia, browsing, other technologies available PyQt5 library top-level Python package that implement over thousand these classes Python modules. PyQt5 library compatible with many operation systems like Windows, Unix, Linux, macOS, Android, iOS. This attractive feature looking library framework order develop applications that multiple platforms with native appearance feel each platform. PyQt5 library available under licenses: Riverbank Commercial License General Public License (GPL), version want utilize PyQt5 create commercial applications, then will require commercial license installation. PyQt5 license must compatible with license working code must also utilize GPL-compatible license utilize version. install PyQt library? There multiple options available choose from while installing PyQt system development environment. first option build from source. This complicated, might want avoid want build from source, refer official documentation library. Another option would binary wheels. Wheels very popular manage installation Python packages. However, must consider that wheels PyQt5 only available Python above. There wheels available different operating systems like: Linux (64-bit) macOS Windows (32-bit 64-bit) These wheels involve copies subsequent libraries; thus, won't require installing them individually. third option utilize package managers Linux distributions macOS. Windows, utilize binary .exe file. fourth final option Anaconda distribution order install PyQt library system. consider following section where have opted above options install PyQt5. Installing PyQt5 using order install Python module, need 'pip', framework manage packages required install modules from trusted public repositories. Once have 'pip', install pyqt5 module using command from Windows command prompt (CMD) terminal shown below: Syntax: python.exe install pyqt5 Verifying Installation Once module installed, verify creating empty Python program file writing import statement follows: File: verify.py import pyqt5 Now, save above file execute using following command terminal: Syntax: python verify.py above Python program file does return error, module installed properly. However, case where exception raised, reinstalling module, also recommended refer official documentation module. create first PyQt Application Creating first PyQt Application Since have installed PyQt library successfully, start some coding. about create "Hello, World!" application with Python PyQt. consider some steps will follow: Step Importing QApplication required widgets from PyQt5.QtWidgets. Step Creating object QApplication. Step Creating object application's GUI. Step Displaying application. Step Executing event loop main loop) application. will begin creating Python project file intro.py present working directory importing required widgets. following snippet code demonstrates same: File: intro.py importing library import importing `QApplication` required widgets from PyQt5.QtWidgets import QApplication from PyQt5.QtWidgets import QLabel from PyQt5.QtWidgets import QWidget Explanation: above snippet code, have imported library, which will allow manage exit status application. have also imported class widgets like QApplication, QLabel, QWidget from QtWidgets module PyQt5 library. will create object QApplication class. consider following snippet code demonstrating same: File: intro.py creating object QApplication class myApp QApplication(sys.argv) Explanation: above snippet code, have instantiated QApplication class. Since QApplication object (myApp) does much initialization, should create before creating other object associated with GUI. object QApplication class also deals with general command line arguments, also required pass sys.argv parameter while creating myApp. Note: sys.argv consists list command-line arguments passed into Python script. application does accept command-line arguments, utilize empty list rather than using sys.argv. perform something like myApp QApplication([]). Step three consists creating application. this example, will based QWidget, base class user interface objects PyQt. consider following snippet code that illustrates creation GUI: File: intro.py creating object application's myWindow QWidget() myWindow.setWindowTitle('PyQt5 Application') myWindow.setGeometry(100, 100, 615, myWindow.move(60, firstMsg QLabel('<h1>Hello, World! Welcome Javatpoint.</h1>', parent myWindow) firstMsg.move(60, Explanation: above snippet code, have created instance QWidget, which offers features that will need order create window form) application. Using help setWindowTitle() function, have added title window. have then utilized setGeometry() function define size window where place screen. first parameters y-coordinates which window will placed screen. third fourth parameters width height window. Every practical application requires widgets! Here have used QLabel object (firstMsg) display message window application. QLabel objects accept HTML text, have used HTML element '<h1>Hello, World! Welcome Javatpoint</h1>' format text h1 header. last, have used move() function place firstMsg coordinates (60, window application. Note: PyQt5, utilize widget subclass QWidget) top-level window even button label. only condition that pass parent When utilize widget like this, PyQt5 automatically provides title turns into normal window. parent-child relationship utilized complementary purposes: widget that does have parent main top-level window. widget with parent (always another widget) stored displayed) within parent. This relationship also defines ownership, with parents owning their children. PyQt5 ownership model ensures that delete parent (for instance, top-level window), children (widgets) automatically removed. should ensure that QWidget object parent with sole exception top-level windows order avoid memory leaks. that done with step three, code last steps first PyQt application ready live: File: intro.py displaying application's myWindow.show() executing event loop main loop) application sys.exit(myApp.exec_()) Explanation: above snippet code, have called show() function myWindow. call show() function schedules paint event. other words, inserts event into event queue application. cover event loop later section. Note: paint event request paint widgets that compose GUI. last, have initiated event loop application calling myApp.exec_() function. call exec_() function wrapped call sys.exit(), which allows exit Python cleanly release memory resources when application terminates. intro.py with following command: Command: python3 intro.py Output: Explanation: above output, application displays window (based QWidget) with message. utilize QLabel that consists message HTML format show message. Understanding Fundamentals PyQt will require master fundamental concepts PyQt logic utilize library applications development efficiently. Some these concepts involve: Widgets Layout managers Dialogs Main windows Applications Event loops Signals Slots These elements will considered building blocks PyQt applications. Most them represented Python classes. QtWidgets module PyQt library provides these classes. These elements extremely significant will cover them following section. Understanding Widgets QWidget base class objects user interface widgets. These rectangular-shaped graphical components that place windows application order construct GUI. Widgets consist attributes methods that enable model their appearance behavior. They also paint depiction themselves screen. Widgets also receive mouse clicks, keypresses, other events from user, window system, many other sources. Every time widget catches event, emits signal announce state change. PyQt5 rich modern collection widgets that serves different purposes. Some most common helpful widgets follows: Buttons Labels Line edits Combo boxes Radio buttons understand these widgets brief. Buttons create button instantiating QPushButton, class that offers classical command button. Some typical buttons Apply, Cancel, Yes, Close. Buttons like these perhaps most utilized widget Graphical User Interface. Whenever click them, command computer perform actions. even perform activities response user clicking button. Labels create labels instantiating QLabel. Labels provide with method show helpful information form text images. Labels used like these better illustrate purpose usage GUI. tweak their appearance different ways, they even accept HTML text, earlier. also labels specify focus mnemonic another widget. Line edits line edit another common widget single-line text that create using QLineEdit. Line edits helpful when requiring user insert edit data plain text format. Line edits like these offer basic editing operations such copy, paste, undo, redo, drag, drop, many more. Combo boxes combo another useful widget that create using QComboBox. combo helps present list options user manner that accepts minimal amount screen space. These combo boxes consist pixmaps, strings, both. combo boxes read-only editable. read-only combo boxes allow users select different options cannot their own. However, editable combo boxes allow users options. Radio buttons last widget will cover here radio button, which create using QRadioButton. Radio buttons useful when requiring user select many options. QRadioButton object option button that switched (checked) (unchecked). PyQt5 large collection widgets. time this writing, there over forty available utilize order create Graphical User Interface Application. widgets have covered above only small sample; however, they display power flexibility PyQt5 library. next section, will cover layout different widgets order create modern functional GUIs applications. Understanding Layout Managers know meaning widgets along with their building GUIs. However, arrange widgets create coherent functional GUI? There range techniques that utilize layout widgets form window. example, utilize resize() move() functions absolute sizes positions. However, this have some drawbacks: will need perform various manual calculations determine every single widget's correct size position forms. will need perform extra calculations respond form size changes (resize event) accurately. will need redo calculations whenever change layout forms remove widgets. also alternative resizeEvent() dynamically calculate size position widget. However, most efficient alternative might utilize Layout managers, which will boost production improve maintainability code. Layout managers classes that enable size position widgets places want them application form. Layout managers automatically adapt resize events content changes. They also control size widgets within them. This implies that widgets layout automatically resized whenever form resized. Note: develop international applications, have observed translated labels short. This specifically likely when target language more verbose than original language. However, this ability tricky sometimes fail with specifically wordy languages. Layout managers useful avoiding this common pitfall. PyQt offers four fundamental layout manager classes: QHBoxLayout QVBoxLayout QGridLayout QFormLayout first layout manager class QHBoxLayout which allows arrange widgets horizontal manner from left right. widgets will appear after other, beginning from left. consider following snippet code demonstrating QHBoxLayout class order arrange buttons horizontally. Example: """Example Horizontal Layout""" importing required modules import from PyQt5.QtWidgets import QApplication from PyQt5.QtWidgets import QHBoxLayout from PyQt5.QtWidgets import QPushButton from PyQt5.QtWidgets import QWidget creating instance QApplication class myApp QApplication(sys.argv) creating window myWindow QWidget() setting title myWindow.setWindowTitle('QHBoxLayout') creating instance QHBoxLayout class h_layout QHBoxLayout() adding widgets layout h_layout.addWidget(QPushButton('Left Widget')) h_layout.addWidget(QPushButton('Center Widget')) h_layout.addWidget(QPushButton('Right Widget')) setting layout myWindow.setLayout(h_layout) displaying window myWindow.show() sys.exit(myApp.exec_()) Output: Explanation: above snippet code, have imported required modules. have then instantiated QApplication class created window. have then title window instantiated QHBoxLayout class. added some widgets layout used setLayout() function horizontal layout Application's window. last, have used show() function display window sys.exit(myApp.exec_()) function exit execution Application. above output, have added three buttons horizontal arrangement. Notice that buttons displayed from left right same order added them code. next layout manager class QVBoxLayout which allows arrange widgets vertical manner, starting from bottom: Each widget will appear beneath earlier one. utilize this class order construct objects vertical layout organize widgets from bottom. consider following snippet code demonstrating QVBoxLayout class: Example: """Example Vertical Layout""" importing required modules import from PyQt5.QtWidgets import QApplication from PyQt5.QtWidgets import QVBoxLayout from PyQt5.QtWidgets import QPushButton from PyQt5.QtWidgets import QWidget creating instance QApplication class myApp QApplication(sys.argv) creating window myWindow QWidget() setting title myWindow.setWindowTitle('QVBoxLayout') creating instance QVBoxLayout class v_layout QVBoxLayout() adding widgets layout v_layout.addWidget(QPushButton('Top Widget')) v_layout.addWidget(QPushButton('Center Widget')) v_layout.addWidget(QPushButton('Bottom Widget')) setting layout myWindow.setLayout(v_layout) displaying window myWindow.show() sys.exit(myApp.exec_()) Output: Explanation: above snippet code, have imported required modules. have then instantiated QApplication class created window. have then title window instantiated QVBoxLayout class. added some widgets layout used setLayout() function vertical layout Application's window. last, have used show() function display window sys.exit(myApp.exec_()) function exit execution Application. above output, have added three buttons vertical arrangement. Notice that buttons displayed from bottom same order added them code. third layout manager class QGridLayout, which allows arrange widgets into grid rows columns. Every widget will have relative position grid. define position widget passing pair coordinates form (row, column). These coordinates should valid numbers. They define which cell grid about place widget grid layout works follows: QGridLayout takes space made available parent, divides into rows columns, places each widget into cell. consider following snippet code that demonstrates QGridLayout GUI: Example: """Example Grid layout""" importing required modules import from PyQt5.QtWidgets import QApplication from PyQt5.QtWidgets import QGridLayout from PyQt5.QtWidgets import QPushButton from PyQt5.QtWidgets import QWidget creating instance QApplication class myApp QApplication(sys.argv) creating window myWindow QWidget() setting title myWindow.setWindowTitle('QGridLayout') creating instance QGridLayout class gridLayout QGridLayout() gridLayout.addWidget(QPushButton('Button 0)'), gridLayout.addWidget(QPushButton('Button 1)'), gridLayout.addWidget(QPushButton('Button 2)'), gridLayout.addWidget(QPushButton('Button 3)'), gridLayout.addWidget(QPushButton('Button 0)'), gridLayout.addWidget(QPushButton('Button 1)'), gridLayout.addWidget(QPushButton('Button 2)'), gridLayout.addWidget(QPushButton('Button 3)'), gridLayout.addWidget(QPushButton('Button 0)'), gridLayout.addWidget(QPushButton('Button Columns Span'), gridLayout.addWidget(QPushButton('Button 3)'), gridLayout.addWidget(QPushButton('Button Columns Span'), gridLayout.addWidget(QPushButton('Button 2)'), gridLayout.addWidget(QPushButton('Button 3)'), setting layout myWindow.setLayout(gridLayout) displaying window myWindow.show() sys.exit(myApp.exec_()) Output: Explanation: above snippet code, have imported required modules. have then instantiated QApplication class created window. have then title window instantiated QGridLayout class. added some widgets layout using addWidget() function. Notice that, above case, second third parameters pass this function parameters that define position each widget. lines added more parameters addWidget() function. These parameters known rowSpan columnSpan, they fourth fifth parameters passed function. utilize them order make widget occupy multiple rows columns with QPushButton('Button Columns Span') here. have then used setLayout() function Grid layout Application's window. last, have used show() function display window sys.exit(myApp.exec_()) function exit execution Application. above output shows that widgets arranged grid rows columns. widgets also occupied more than cell. last layout manager class QFormLayout, which arranges widgets two-column layout. first column generally shows messages labels. second column usually consists widgets like QLineEdit, QComboBox, QSpinBox, many more. These widgets enable user enter edit data associated with information first column. following diagram displays working form layouts practice: left column contains labels, right column contains field widgets. dealing with database application, this kind layout attractive option increased productivity when creating forms. consider following snippet code that demonstrates QFormLayout object arrange widgets Application. Example: """Example Grid layout""" importing required modules import from PyQt5.QtWidgets import QApplication from PyQt5.QtWidgets import QFormLayout from PyQt5.QtWidgets import QLineEdit from PyQt5.QtWidgets import QWidget creating instance QApplication class myApp QApplication(sys.argv) creating window myWindow QWidget() setting title myWindow.setWindowTitle('QFormLayout') creating instance QFormLayout class formLayout QFormLayout() formLayout.addRow('Roll Number:', QLineEdit()) formLayout.addRow('First Name:', QLineEdit()) formLayout.addRow('Last Name:', QLineEdit()) formLayout.addRow('Class:', QLineEdit()) formLayout.addRow('E-mail ID:', QLineEdit()) formLayout.addRow('Mobile Number:', QLineEdit()) setting layout myWindow.setLayout(formLayout) displaying window myWindow.show() sys.exit(myApp.exec_()) Output: Explanation: above snippet code, have imported required modules. have then instantiated QApplication class created window. have then title window instantiated QFormLayout class. notice that QFormLayout convenient method known addRow(). utilize this method two-widget layout. first parameter addRow() should label, second parameter should other widget that enables user enter edit data. above output displays that utilizes form layout. first column consists labels asking user some information. second column displays widgets allowing user enter edit information asked from them. Understanding Dialogs develop types desktop applications using PyQt. Depending class utilize order create main form window, will have following: Main Window-Style application: main window application inherits from QMainWindow. Dialog-Style application: main window application inherits from QDialog. will begin with Dialog-Style applications first. next section, will cover Main Window-Style applications. need create class that inherits from QDialog, which base class dialog windows, order develop Dialog-Style application. Dialog window always top-level window that utilize main window Dialog-Style application. Note: Dialog windows also usually utilized Main Window-Style applications brief communication interaction with user. When dialog windows utilized communicating with user, they Modal Dialogs: These dialogs block input other visible windows same application. show modal dialog using exec_() Modeless dialogs: These dialogs operate independently other windows same application. show modeless dialog calling show() Dialog windows also offer return value have default buttons (OK Cancel). dialog often top-level widget. parent, default location centered parent's top-level widget. This kind dialog will also share taskbar entry parent. parent given dialog, then dialog will entry taskbar system. consider following snippet code demonstrating QDialog development Dialog-Style application: Example: """Example Dialog-Style Application""" importing required modules import from PyQt5.QtWidgets import QApplication from PyQt5.QtWidgets import QDialog from PyQt5.QtWidgets import QDialogButtonBox from PyQt5.QtWidgets import QFormLayout from PyQt5.QtWidgets import QLineEdit from PyQt5.QtWidgets import QVBoxLayout defining class that inherits QDialog class myDialog(QDialog): """Dialog""" __init__(self, parent None): """Initializer""" super().__init__(parent) self.setWindowTitle('QDialog Application') dialog_layout QVBoxLayout() form_layout QFormLayout() form_layout.addRow('Roll Number:', QLineEdit()) form_layout.addRow('First Name:', QLineEdit()) form_layout.addRow('Last Name:', QLineEdit()) form_layout.addRow('Class:', QLineEdit()) form_layout.addRow('E-mail Address:', QLineEdit()) form_layout.addRow('Mobile Number:', QLineEdit()) dialog_layout.addLayout(form_layout) myButtons QDialogButtonBox() myButtons.setStandardButtons( QDialogButtonBox.Cancel QDialogButtonBox.Ok dialog_layout.addWidget(myButtons) self.setLayout(dialog_layout) executing application __name__ '__main__': QApplication(sys.argv) my_dialog myDialog() my_dialog.show() sys.exit(app.exec_()) Output: Explanation: above snippet code, have imported required modules defined class GUI, which inherits from QDialog. have then assigned QVBoxLayout object dialog_layout QVFormLayout object form_layout. have then added widgets form_layout. Later have used dialog_layout arrange these widgets form. have then added standard buttons application. last, have wrapped boilerplate code __name__ '__main__': idiom. This considered best practice Pythonistas. Note: observe line code block above, then will notice that layout managers nested inside another. nest layouts calling addLayout() function container layout passing nested layout parameter this method. Understanding Main Windows Most time, application will Main Window-Style. This means that these applications consist menu bar, some toolbars, status bar, central widget that will main element Graphical User Interface. also common that applications will have several dialog windows accomplish secondary actions that depend user input. will utilize class QMainWindow order develop Main Window-Style applications. QMainWindow offers framework that allows build application. have inherit from QMainWindow create main class. object class derived from QMainWindow considered main window. class built-in layout, which utilize place following: menu present window. menu consists main menu application. Several toolbars present sides window. Toolbars suitable containing tool buttons other widgets like QComboBox, QSpinBox, many more. central widget present center window. central widget type, composite widget. Several dock widgets present around central widget. Dock widgets small, movable windows. status present bottom window. status displays information associated with general status application. cannot create main window without setting central widget first. just need central widget, even just placeholder. utilize QWidget object central widget when this case. main window's central widget using setCentralWidget() function. layout main window will enable have only central widget; however, either single widget composite one. consider following snippet code, demonstrating QMainWindow creation Main Window-Style application: Example: """Example Main Window-Style application""" importing required modules import from PyQt5.QtWidgets import QApplication from PyQt5.QtWidgets import QLabel from PyQt5.QtWidgets import QMainWindow from PyQt5.QtWidgets import QStatusBar from PyQt5.QtWidgets import QToolBar defining class class myWindow(QMainWindow): """Main Window""" __init__(self, parent None): """Initializer""" super().__init__(parent) self.setWindowTitle('QMainWindow Application') self.setCentralWidget(QLabel("This Central Widget")) self.create_menu() self.create_tool_bar() self.create_status_bar() creating menu create_menu(self): self.menu self.menuBar().addMenu("&Menu") self.menu.addAction('&Exit', self.close) creating toolbar create_tool_bar(self): myTools QToolBar() self.addToolBar(myTools) myTools.addAction('Exit', self.close) creating status create_status_bar(self): myStatus QStatusBar() myStatus.showMessage("This Status Bar") self.setStatusBar(myStatus) executing application __name__ '__main__': myApp QApplication(sys.argv) the_window myWindow() the_window.show() sys.exit(myApp.exec_()) Output: Explanation: above snippet code, have imported required module defined class myWindow that inherits from QMainWindow. have then initialized some functions title window. have then QLabel central widget. have then called private methods that follow create different elements GUI. Later, created methods create main menu, toolbar, status bar. last, have instantiated class executed application. Note: Whenever implement different components their methods, making code more readable more manageable. However, this necessary, free organize code prefer best. observe that Main Window-Style application components shown below: main menu, known Menu toolbar with functional Exit tool button central widget QLabel Object) status bottom window far, have covered more significant graphical components PyQt5's widgets. following sections, will cover some other significant concepts associated with PyQt applications. Understanding Applications most fundamental class will utilize while developing PyQt applications QApplication. This class core PyQt application. manages control flow application main settings. PyQt, object QApplication application. Every PyQt application must have QApplication object. Some responsibilities application involve: Managing process initialization finalization. Offering event loop event handling. Controlling most system-wide well application-wide settings. Offering access global information, like directory application, screen size, Parsing general command-line parameters. Defining appearance experience application. Offering localization capabilities. From above core responsibilities QApplication, conclude that this fundamental class that helps development PyQt applications. most significant responsibilities QApplication offer event loop complete mechanism event handling. have closer look event loop now. Understanding Event Loops applications event-driven. This statement implies that methods functions executed with respect user actions. example, clicking button, selecting element from combo box, inserting updating text text editor, pressing keyboard, many more. These user actions usually known events. Events generally handled event loop (also known main loop). event loop infinite loop which events from user, window system, other sources processed dispatched. event loop waits event happen then dispatches order some tasks. event loop continues work until application terminated. Event loops utilized applications. event loop infinite loop that waits occurrences events. Suppose event occurs, then loop checks event Terminate event. that case, loop terminated, application quits. Else, event sent event queue application further processing, loop begins again. PyQt, execute event loop application calling exec_() function QApplication object. event trigger response action, have connect event with action want executed. PyQt5, establish that connection with help signals slot mechanism. Signals Slots widgets PyQt library event-catchers. This statement means that every widget catch particular number events, such mouse clicks, keypresses, many more. response these events, widgets always emit signal, kind message that announces change state. signal does task. want signal trigger action, have connect slot. This method function that will perform action whenever connecting signal emitted. utilize Python callable callback) slot. signal connected slot, then slot called whenever signal emitted. signal connected slot, nothing occurs, signal ignored. Here some most supportable features this mechanism: signal connected single multiple slots signal also connected another signal. slot connected single multiple signals. utilize following syntax order connect signal slot: Syntax: widget.signal.connect(slot_func) Whenever signal emitted, slot_func() will called. This will connect slot_func widget.signal function. consider following snippet code, demonstrating same: Example: """Example Signals slots""" importing required modules import from PyQt5.QtWidgets import QApplication from PyQt5.QtWidgets import QLabel from PyQt5.QtWidgets import QPushButton from PyQt5.QtWidgets import QVBoxLayout from PyQt5.QtWidgets import QWidget defining slot function greetings(): """Slot function""" the_msg.text(): the_msg.setText("") else: the_msg.setText("Hello, World! Welcome Javatpoint.com") creating application myApp QApplication(sys.argv) the_window QWidget() the_window.setWindowTitle('Signals slots Application') myLayout QVBoxLayout() initializing button myButton QPushButton('Greet') myButton.clicked.connect(greetings) Using connect() function adding widgets myLayout.addWidget(myButton) the_msg QLabel('') myLayout.addWidget(the_msg) setting layout the_window.setLayout(myLayout) executing application the_window.show() sys.exit(myApp.exec_()) Output: Explanation: above snippet code, have imported required modules defined slot function. have created object QApplication class initialized button. have then added widgets layout. last, have displayed window. Moreover, observe that button triggers action that connects greetings() function. signals slots mechanism what will utilize give life PyQt5 applications. This mechanism will allow turn user events into concrete actions. Next TopicHow Prettify Data Structures with Pretty Print Python prev next