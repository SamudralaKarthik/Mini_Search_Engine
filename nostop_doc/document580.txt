next prev Differences between Flatten() Ravel() Numpy Functions There kinds methods convert Ndarray into array flatten() well Ravel() import numpy nmp.array( (1,8,4,5),(4,3,5,1) #OUTPUT: print( P.flatten() 1,8,4,5,4,3,5,1 print P.ravel() 1,8,4,5,4,3,5,1 question here what reason there distinct roles perform same job? Differences between Flatten() Ravel() P.ravel(): Returns only reference/view original array event that alter array, will able that value original array changes too. Ravel faster than flatten() because doesn't take memory. Ravel library-level function library level. P.flatten(): Return duplicate initial array When alter value this array, original array's value changed. Flatten() considerably faster that ravel() because takes memory. Flatten method used ndarray. Let's difference between flatter() ravel() function using this code. Code: import numpy Here, will create numpy array nmp.array([(3,4,5,6),(5,3,6,7)]) Now, will print array print ("Original array:\n print(P) checking dimension array (dimension type numpy.ndarray print ("Dimension array: (P.ndim)) print("\n output RAVEL \n") Here, will convert ndarray array P.ravel() ravel() only passes view original array array print(Q) Q[0]=1000 print(Q) note here that value original array also P[0][0] becomes 1000 print(P) Just checking dimension i.e. type same numpy.ndarray print ("Dimension array" ,(Q.ndim)) print("\n output FLATTEN \n") Here, will convert ndarray array P.flatten() Flatten passes copy original array print(R) R[0] print(R) Here, note that changing value there affect value original array print(P) print ("Dimension array (R.ndim)) Output: Original array: Dimension array: output RAVEL [1000 [[1000 Dimension array output FLATTEN [1000 [[1000 Dimension array Next TopicLearning Vector Quantization prev next