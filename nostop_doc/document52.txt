next prev Python Decorator Decorators most helpful powerful tools Python. These used modify behavior function. Decorators provide flexibility wrap another function expand working wrapped function, without permanently modifying Decorators, functions passed argument into another function then called inside wrapper function. also called meta programming where part program attempts change another part program compile time. Before understanding Decorator, need know some important concepts Python. What functions Python? Python most interesting feature that everything treated object even classes variable define Python also assumed object. Functions first-class objects Python because they reference passed variable returned from other functions well. example given below: func1(msg): print(msg) func1("Hii") func2 func1 func2("Hii") Output: above program, when code give same output both functions. func2 referred function func1 function. need understand following concept function: function referenced passed variable returned from other functions well. functions declared inside another function passed argument another function. Inner Function Python provides facility define function inside another function. These types functions called inner functions. Consider following example: func(): print("We first function") func1(): print("This first child function") func2(): print(" This second child function") func1() func2() func() Output: first function This first child function This second child function above program, doesn't matter child functions declared. execution child function makes effect output. These child functions locally bounded with func() they cannot called separately. function that accepts other function argument also called higher order function. Consider following example: add(x): return x+1 sub(x): return x-1 operator(func, temp func(x) return temp print(operator(sub,10)) print(operator(add,20)) Output: above program, have passed sub() function add() function argument operator() function. function return another function. Consider below example: hello(): hi(): print("Hello") return hello() new() Output: Hello above program, hi() function nested inside hello() function. will return each time call hi(). Decorating functions with parameters Let's have example understand parameterized decorator function: divide(x,y): print(x/y) outer_div(func): inner(x,y): if(x<y): return func(x,y) return inner divide1 outer_div(divide) divide1(2,4) Output: Syntactic Decorator above program, have decorated out_div() that little bulky. Instead using above method, Python allows decorator easy with @symbol. Sometimes called "pie" syntax. outer_div(func): inner(x,y): if(x<y): return func(x,y) return inner syntax generator @outer_div divide(x,y): print(x/y) Output: Reusing Decorator reuse decorator well recalling that decorator function. Let's make decorator module that used many other functions. Creating file called mod_decorator.py with following code: do_twice(func): wrapper_do_twice(): func() func() return wrapper_do_twice import mod_decorator.py other file. from decorator import do_twice @do_twice say_hello(): print("Hello There") say_hello() Output: Hello There Hello There Python Decorator with Argument want pass some arguments function. Let's following code: from decorator import do_twice @do_twice display(name): print(f"Hello {name}") display() Output: TypeError: display() missing required positional argument: 'name' that, function didn't accept argument. Running this code raises error. this error using *args **kwargs inner wrapper function. Modifying decorator.py follows: do_twice(func): wrapper_function(*args,**kwargs): func(*args,**kwargs) func(*args,**kwargs) return wrapper_function wrapper_function() accept number argument pass them function. from decorator import do_twice @do_twice display(name): print(f"Hello {name}") display("John") Output: Hello John Hello John Returning Values from Decorated Functions control return type decorated function. example given below: from decorator import do_twice @do_twice return_greeting(name): print("We created greeting") return f"Hi {name}" hi_adam return_greeting("Adam") Output: created greeting created greeting Fancy Decorators Let's understand fancy decorators following topic: Class Decorators Python provides ways decorate class. Firstly, decorate method inside class; there built-in decorators like @classmethod, @staticmethod @property Python. @classmethod @staticmethod define methods inside class that connected other instance class. @property generally used modify getters setters class attributes. Letâ€™s understand following example: Example: @property decorator using class function attribute. Consider following code: class Student: __init__(self,name,grade): self.name name self.grade grade @property display(self): return self.name grade self.grade Student("John","B") print("Name:", stu.name) print("Grade:", stu.grade) print(stu.display) Output: Name: John Grade: John grade Example:2 @staticmethod decorator- @staticmethod used define static method class. called using class name well instance class. Consider following code: class Person: @staticmethod hello(): print("Hello Peter") Person() per.hello() Person.hello() Output: Hello Peter Hello Peter Singleton Class singleton class only instance. There many singletons Python including True, None, etc. Nesting Decorators multiple decorators using them each other. Let's consider following example: @function1 @function2 function(name): print(f "{name}") above code, have used nested decorator stacking them onto another. Decorator with Arguments always useful pass arguments decorator. decorator executed several times according given value argument. consider following example: Import functools repeat(num): #Creating returning wrapper function decorator_repeat(func): @functools.wraps(func) wrapper(*args,**kwargs): range(num): value func(*args,**kwargs) return value return wrapper return decorator_repeat #Here passing argument which repeats print function @repeat(num=5) function1(name): print(f"{name}") Output: JavatPoint JavatPoint JavatPoint JavatPoint JavatPoint above example, @repeat refers function object that called another function. @repeat(num will return function which acts decorator. above code look complex most commonly used decorator pattern where have used additional that handles arguments decorator. Note: Decorator with argument frequently used programming, provides flexibility. with without argument. Stateful Decorators Stateful decorators used keep track decorator state. consider example where creating decorator that counts many times function been called. Import functools count_function(func): @functools.wraps(func) wrapper_count_calls(*args, **kwargs): wrapper_count_calls.num_calls print(f"Call{wrapper_count_calls.num_calls} {func.__name__!r}") return func(*args, **kwargs) wrapper_count_calls.num_calls return wrapper_count_calls @count_function say_hello(): print("Say Hello") say_hello() say_hello() Output: Call 'say_hello' Hello Call 'say_hello' Hello above program, state represented number calls function stored .num_calls wrapper function. When call say_hello() will display number call function. Classes Decorators classes best maintain state. this section, will learn class decorator. Here will create class that contains __init__() take func argument. class needs callable that stand decorated function. making class callable, implement special __call__() method. import functools class Count_Calls: __init__(self, func): functools.update_wrapper(self, func) self.func func self.num_calls __call__(self, *args, **kwargs): self.num_calls print(f"Call{self.num_calls} {self.func.__name__!r}") return self.func(*args, **kwargs) @Count_Calls say_hello(): print("Say Hello") say_hello() say_hello() say_hello() Output: Call 'say_hello' Hello Call 'say_hello' Hello Call 'say_hello' Hello __init__() method stores reference function other required initialization. Next TopicPython Generators prev next