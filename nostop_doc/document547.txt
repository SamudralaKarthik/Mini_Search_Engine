next prev Monitoring Devices using Python following tutorial, will understand monitor devices using Python programming language. before started, briefly discuss importance monitoring system resources. Significance Monitoring System Resources Monitoring System Resources allows evaluate performance critical system resources regular basis, such Memory RAM, Swap space, Hard Disk space Network Utilization Utilization Monitoring essential identifying process that utilizes most resources reason behind helps understand resources current system sufficient running rogue process consuming many resources. Having limiting threshold system resources will prevent further escalation issues identify appropriate root cause analysis order issue. this tutorial, will explore psutil (process system utilities) library Python, cross-platform library retrieving information running processes system utilization resources such CPU, memory, disks, network, sensors. psutil library currently supports following platforms: Linux Windows MacOS FreeBSD, OpenBSD, NetBSD Solaris AIX GPUtil library Python module getting status from NVIDIA GPUs with help nvidia-smi. System profiling Profiling system necessary order know name system, version Operating System (OS), architecture system, whether 64-bit 32-bit, number physical virtual cores, frequency CPU. Python platform library allows retrieve platform-identifying data such name device, version, release version, node, processor, more. consider following snippet code that demonstrate usage above libraries. Code: importing required libraries import psutil import platform getting username username platform.uname() printing details print(f"System: {username.system}") print(f"Node Name: {username.node}") print(f"Release: {username.release}") print(f"Version: {username.version}") print(f"Machine: {username.machine}") print(f"Processor: {username.processor}") print("Physical cores:", psutil.cpu_count(logical False)) print("Total cores:", psutil.cpu_count(logical True)) frequencies cpu_freq psutil.cpu_freq() print(f"Max Frequency: {cpu_freq.max .2f}Mhz") print(f"Min Frequency: {cpu_freq.min .2f}Mhz") print(f"Current Frequency: {cpu_freq.current .2f}Mhz") Output: System: Windows Node Name: MANGO-HOME Release: Version: 10.0.22000 Machine: AMD64 Processor: Intel64 Family Model 165 Stepping GenuineIntel Physical cores: Total cores: Frequency: 2496.00Mhz Frequency: 0.00Mhz Current Frequency: 2496.00Mhz Explanation: have imported psutil platform libraries above snippet code. then username platform using uname() method platform library. have then printed details like system name, node name, release, version, machine, processor, physical cores, total cores. then frequencies using cpu_freq() method psutil library printed details like maximum, minimum, current frequencies. Monitoring Limiting Resources monitor temperatures different physical cores. current temperature physical cores above threshold limit core, then give alert. psutil.sensors_temperatures(fahrenheit True) method offers current, high, critical temperatures various physical cores. This method does apply Windows. consider following snippet code demonstrating usage above method. Code: importing required libraries import psutil monitoring temperature range(len(psutil.sensors_temperatures(fahrenheit True)[ 'coretemp' ])): print(str(psutil.sensors_temperatures(fahrenheit True)[ 'coretemp' ][n].label) temperature str(psutil.sensors_temperatures(fahrenheit True)[ 'coretemp' ][n].current) "F") psutil.sensors_temperatures(fahrenheit True)[ 'coretemp' ][n].current psutil.sensors_temperatures(fahrenheit True)[ 'coretemp' ][n].high: print("Temperature high") Explanation: above snippet code, imported psutil library, used sensors_temperatures(fahrenheit True) method, printed required details associated with current temperature different physical cores. Monitoring Limiting Memory virtual memory combination disk space used processes running CPU. contrast, Swap space portion virtual memory hard disk utilized running processes when full. consider following snippet code demonstrating same: Code: importing psutil library import psutil defining function getSize(bytes, suffix "B"): Scaling bytes proper format- the_factor 1024 the_unit ["", "K", "M", "G", "T", "P"]: bytes the_factor: return f"{bytes:.2f}{the_unit}{suffix}" bytes the_factor print("Virtual memory") sv_mem psutil.virtual_memory() print(f"Total: {getSize(sv_mem.total)}") print(f"Available: {getSize(sv_mem.available)}") print(f"Used: {getSize(sv_mem.used)}") print(f"Percentage: {sv_mem.percent} print("SWAP memory") getting swap memory details exists) swap_mem psutil.swap_memory() print(f"Total: {getSize(swap_mem.total)}") print(f"Free: {getSize(swap_mem.free)}") print(f"Used: {getSize(swap_mem.used)}") print(f"Percentage: {swap_mem.percent} Output: Virtual memory Total: 7.84GB Available: 1.76GB Used: 6.07GB Percentage: 77.5 SWAP memory Total: 3.88GB Free: 908.48MB Used: 2.99GB Percentage: 77.1 Explanation: above snippet code, have imported required library. have then defined function return size. then used psutil.virtual_memory() method that returns statistics associated with system memory utilization named tuple. have then calculated total, available, used, percentage virtual memory. Similarly, have also used psutil.swap_memory() method provides information regarding swap memory statistics tuple. last, have calculated total, available, used, percentage swap memory. Limiting Threshold Virtual Memory Swap Memory consider following snippet code demonstrating limiting threshold virtual memory swap memory. Code: importing psutil library import psutil VIRTUAL_MEMORY_THRESHOLD 1024 1024 100MB SWAP_MEMORY_THRESHOLD psutil.virtual_memory().available VIRTUAL_MEMORY_THRESHOLD: print("Low Virtual Memory warning") psutil.swap_memory().percent SWAP_MEMORY_THRESHOLD: print("Low Swap Memory warning") Output: Swap Memory warning Explanation: above snippet code, imported required module defined constant threshold values virtual swap memory. have then checked available virtual memory equal below threshold virtual memory printed warning with respect same. have then again checked percentage swap memory equal above threshold swap memory printed warning with respect same. Monitoring Limiting Hard Disk Space disk_partitions() method psutil library allows return mounted disk partitions, including device, mount point, type file system. consider following snippet code demonstrating usage this method. Code: importing psutil library import psutil defining function getSize(bytes, suffix "B"): Scaling bytes proper format- the_factor 1024 the_unit ["", "K", "M", "G", "T", "P"]: bytes the_factor: return f"{bytes:.2f}{the_unit}{suffix}" bytes the_factor print( "Hard Disk Information\nPartitions Usage:") getting disk partitions device the_partitions psutil.disk_partitions() the_partition the_partitions: print("Device: the_partition.device) print("Partition Mount point: the_partition.mountpoint) print("Partition File system type: the_partition.fstype) try: partitionUsage psutil.disk_usage(the_partition.mountpoint) except PermissionError: continue print("Total Size: getSize(partitionUsage.total)) print("Used Space: getSize(partitionUsage.used)) print("Free hard disk Space", getSize(partitionUsage.free)) print("Hard disk Used Percentage: partitionUsage.percent, "%") if(partitionUsage.percent 82): print("Disk space nearing full") Output: Hard Disk Information Partitions Usage: Device: Partition Mount point: Partition File system type: NTFS Total Size: 329.34GB Used Space: 195.17GB Free hard disk Space 134.17GB Hard disk Used Percentage: 59.3 Device: Partition Mount point: Partition File system type: NTFS Total Size: 146.48GB Used Space: 26.46GB Free hard disk Space 120.02GB Hard disk Used Percentage: 18.1 Explanation: above snippet code, have imported required library defined function return size. have then used disk_partitions() method list mounted disk partitions. have then used for-loop iterate through each partition print required details such device, partition mount point, partition file system type, total space, used space, free hard disk space, hard disk used percentage. have used try-except method check disk space capacity. Monitoring Limiting Network Usage network protocols linked with particular address family. address family offers services such packet fragmentation reassembly, routing, addressing, transporting. address family offers inter-process communication between processes that execute same system different systems. address family generally comprised some protocols, socket type. This list different networks with their address families: AF_INET IPv4 Internet Protocols AF_INET6 IPv6 Internet Protocols AF_NETLINK Kernel User Interface Device AF_PACKET Low-Level Packet Interface consider following snippet code demonstrating same: Code: importing psutil library import psutil print( "Network Information") getting network interfaces (virtual physical) ifAddrs psutil.net_if_addrs() interfaceName, interfaceAddresses ifAddrs.items(): address interfaceAddresses: print(" Interface: interfaceName) str(address.family) 'AddressFamily.AF_INET': print(" Address: address.address) print(" Netmask: address.netmask) print(" Broadcast IPv4: address.broadcast) elif str(address.family) 'AddressFamily.AF_PACKET': print(" Address: {address.address}") print(" Netmask: {address.netmask}") print(" Broadcast MAC: {address.broadcast}") elif str(address.family) 'AddressFamily.AF_INET6': print(" Address: address.address) print(" Netmask: address.netmask) print(" Broadcast IPv6: address.broadcast) Output: Network Information Interface: Ethernet Interface: Ethernet Address: 169.254.65.123 Netmask: 255.255.0.0 Broadcast IPv4: None Interface: Ethernet Address: fe80::dc05:fc5a:2b3f:417b Netmask: None Broadcast IPv6: None Interface: Local Area Connection* Interface: Local Area Connection* Address: 169.254.196.107 Netmask: 255.255.0.0 Broadcast IPv4: None Interface: Local Area Connection* Address: fe80::3ce0:aa56:980:c46b Netmask: None Broadcast IPv6: None Interface: Local Area Connection* Interface: Local Area Connection* Address: 169.254.235.211 Netmask: 255.255.0.0 Broadcast IPv4: None Interface: Local Area Connection* Address: fe80::1caa:5f5b:a099:ebd3 Netmask: None Broadcast IPv6: None Interface: Wi-Fi Interface: Wi-Fi Address: 192.168.0.196 Netmask: 255.255.255.0 Broadcast IPv4: None Interface: Wi-Fi Address: fe80::f199:be8:532e:b02d Netmask: None Broadcast IPv6: None Interface: Bluetooth Network Connection Interface: Bluetooth Network Connection Address: 169.254.16.59 Netmask: 255.255.0.0 Broadcast IPv4: None Interface: Bluetooth Network Connection Address: fe80::c18b:b59f:f426:103b Netmask: None Broadcast IPv6: None Interface: Loopback Pseudo-Interface Address: 127.0.0.1 Netmask: 255.0.0.0 Broadcast IPv4: None Interface: Loopback Pseudo-Interface Address: ::1 Netmask: None Broadcast IPv6: None Explanation: above snippet code, have imported psutil library. then retrieve information regarding network interfaces (virtual physical) using net_if_addrs() method. then used for-loop iterate through these details printed required information users. will understand usage net_io_counters() method that returns system-wide network statistics such bytes sent, bytes received, incoming packets dropped, outgoing packets dropped. consider following snippet code demonstrating same: Code: importing psutil library import psutil defining function getSize(bytes, suffix "B"): Scaling bytes proper format- the_factor 1024 the_unit ["", "K", "M", "G", "T", "P"]: bytes the_factor: return f"{bytes:.2f}{the_unit}{suffix}" bytes the_factor netIO psutil.net_io_counters() print("Total Bytes Sent: getSize(netIO.bytes_sent)) print("Total Bytes Received: getSize(netIO.bytes_recv)) print("Total outgoing packets dropped: netIO.dropin) print("Total incoming packets dropped:", netIO.dropout) print("Total outgoing errors: netIO.errout) print("Total incoming errors:", netIO.errin) Output: Total Bytes Sent: 89.37MB Total Bytes Received: 5.66GB Total outgoing packets dropped: Total incoming packets dropped: Total outgoing errors: Total incoming errors: Explanation: above snippet code, have imported required library defined function return size. have then used net_io_counters() method return system-wide statistics printed some required details users. Monitoring monitor using GPUtil library provided Python programming language. This library allows retrieve status from NVIDIA GPUs. shows NVIDIA GPUs available device, free memory available, memory used, temperature Centigrade. consider following snippet code demonstrating usage Python GPUtil library. Code: import GPUtil the_gpus GPUtil.getGPUs() gpu_list the_gpu the_gpus: print(the_gpu.name) print('gpu.id:', the_gpu.id) print 'Total GPU:', the_gpu.memoryTotal) print(f"Memory free {the_gpu.memoryFree}MB") print 'GPU usage:', the_gpu.memoryUsed) print 'GPU proportion:', the_gpu.memoryUtil 100) print(str(the_gpu.temperature) gpu_list.append([ the_gpu.id, the_gpu.memoryTotal, the_gpu.memoryUsed, the_gpu.memoryUtil THRESHOLDGPU the_gpu the_gpus: print(the_gpu.name, gpu.id:', the_gpu.id) the_gpu.memoryTotal the_gpu.memoryUsed THRESHOLDGPU: print f"GPU memory usage currently {the_gpu.memoryUtil 100}% which exceeds threshold {THRESHOLDGPU}%" Output: GeForce 1650 gpu.id: Total GPU: 4096.0 Memory free 3962.0MB usage: 134.0 proportion: 3.271484375 47.0 GeForce 1650 gpu.id: memory usage currently 3.271484375% which exceeds threshold Explanation: above snippet code, have imported GPUtil library used getGPUs() method list GPUs. have then created empty list. have then used for-loop iterate through details objects list append empty list. have then printed information regarding memory usage. Monitoring Sensors monitor (Internet Things) Sensors, retrieve hardware temperature, fans speed, battery information. also identify threshold raise error threshold reached. following memory accomplish same: sensors_temperatures() sensors_fans() sensors_battery() Next TopicWebbrowser module Python prev next