next prev Profiling Python code Serious Software Development calls performance optimization. When optimizing application performance, cannot escape looking profilers. Profilers gamut monitoring production servers tracking frequency duration method calls. following tutorial will cover fundamentals using Python profiler, breaking down chief concepts, introducing different libraries utilities each chief concept Python profiling. First all, will list chief concepts Python profiling. will then break each chief concept into three chief segments: Definition Explanation Tools that work generic Python Applications Application Performance Monitoring (APM) utilities that utilities perfect profiling complete life cycle transactions applications. Most utilities probably written Python programming language; however, they work well regardless language application written Before begin, note that will mainly focus examples based Python Thus, let's started. Understanding Tracing Officially, tracing considered special case logging order record information associated with execution program. Since this case quite similar event logging, differences between event logging tracing definite. Event logging appears ideal systems administrators, whereas software developers more concerned with tracing debug software programs. consider one-liner thinking about tracing when software developers utilize logging order record data related execution software. open-source Standard Library Python, trace faulthandler modules allow basic tracing. understand working these modules detail. Understanding Python trace module Python trace module aims "examine which statements functions executed program runs generate analytic call-graph information". Python documentation trace module does provide much information; however, Python Module Week (PyMOTW) succinct description related module. trace will "follow Python statements they executed". consider example understand execution trace module. Example: main(): print('This main function') recurse(2) recurse(lvl): print('recurse({})'.format(lvl)) lvl: recurse(lvl notCalled(): print('This function never called') __name__ '__main__': main() Output: This main function recurse(2) recurse(1) recurse(0) Explanation: above snippet code, have defined main() function within which recurse() function invokes itself until parameter reaches zero. have then defined recurse() function with argument. last, have defined function notCalled() will never called program. tracing execution above program. Execution Tracing: python3 trace --ignore-dir=.../lib/python3.9 --trace trace_example.py modulename: trace_example, funcname: <module> trace_example.py(1): main(): trace_example.py(5): recurse(lvl): trace_example.py(10): notCalled(): trace_example.py(13): __name__ '__main__': trace_example.py(14): main() modulename: trace_example, funcname: main trace_example.py(2): print('This main function') This main function trace_example.py(3): recurse(2) modulename: trace_example, funcname: recurse trace_example.py(6): print('recurse({})'.format(lvl)) recurse(2) trace_example.py(7): lvl: trace_example.py(8): recurse(lvl modulename: trace_example, funcname: recurse trace_example.py(6): print('recurse({})'.format(lvl)) recurse(1) trace_example.py(7): lvl: trace_example.py(8): recurse(lvl modulename: trace_example, funcname: recurse trace_example.py(6): print('recurse({})'.format(lvl)) recurse(0) trace_example.py(7): lvl: Explanation: easy trace module directly from command line. statements being executed program runs printed when --trace option provided. This example also ignores location standard library Python order avoid tracing into importlib other modules. also perform several things using Python trace module. Some them follows: generate code coverage report order which lines executed skipped over with help --count also report relationships between functions that call other with help --listfuncs also track which function caller using --trackcalls Understanding Python faulthandler module terms comparison, faulthandler module slightly better Python documentation. states that purpose faulthandler module dump Python tracebacks explicitly fault, after timeout, user signal. also works well with other system fault handlers such Apport Windows fault handler. Both faulthandler trace modules offer more tracing abilities help debug Python code. will more profiling statistics next section. beginner tracing, recommended start simply using trace module. Open source options There different tools available options, such Jaeger Zipkin. Although they written Python programming language, they work efficiently distributed applications. Jaeger officially supports Python part Cloud Native Computing Foundation. more extensive deployment documentation. these reasons, also recommended begin with Jaeger wants trace requests distributed architecture. suitable their tracing requirement, Zipkin. What part code should profile? Now, delve into particulars profiling. term "profiling" mainly used testing performance, objective performance testing find bottlenecks performing deep analysis. Thus, utilize tracing tools support with profiling. Remember that tracing information logged software developers about execution software. Therefore, logging performance metrics also method perform profiling analysis. However, restricted tracing. profiling gains mindshare mainstream, have utilities that perform profiling directly. question what segments software profile (measure performance metrics)? Typically, profile: Methods Functions (most common) Lines (similar method profiling; however, performing line line) Memory (memory usage) Before into each these offer generic Python options, explore type metrics utilize profiling profiling techniques themselves. What metrics should profile? Speed (time) Typically, need measure while profiling time spent executing each method. Whenever utilize method profiling utility such cProfile (which available Python language), timing metrics methods display statistics, like number calls (shown ncalls), total time spent function (tottime), time call (tottime/ncalls shown percall), cumulative time spent function (cumtime), cumulative time call (quotient cumtime over number primitive calls shown percall after cumtime). particular timing metrics vary from utility utility; however, general case, expect something similar choice timing metrics cProfile similar tools. Calls (frequency) Another metric consider while profiling number calls made method. instance, cProfile highlights number function calls many those native calls. However, method acceptable speed, frequently called that becomes huge time sink. would like know this from profiler. Understanding Method Line Profiling general, most profiling tutorials based tracking timing metrics method beginners understand profiling. name suggests, line profiling signifies profile Python code line line. consider method profiling; however, more granular. most common metrics utilized line profiling timing metrics. also recommended start with profiling methods first beginner proceed further start getting comfortable with them. Understanding Python cProfile profile modules modules, cProfile, profile, available Python version numbers generated these modules formatted into reports using pstats module. consider following example cProfile module displaying numbers script. Example: import cProfile import cProfile.run('re.compile("foo|bar")') Output: function calls (246 primitive calls) 0.002 seconds Ordered standard name ncalls tottime percall cumtime percall filename:lineno(function) 0.001 0.001 0.001 0.001 :1() 0.000 0.000 0.000 0.000 enum.py:1017(_decompose) 0.000 0.000 0.000 0.000 enum.py:358(__call__) 0.000 0.000 0.000 0.000 enum.py:434(__iter__) 0.000 0.000 0.000 0.000 enum.py:438() 0.000 0.000 0.000 0.000 enum.py:670(__new__) 0.000 0.000 0.000 0.000 enum.py:792(value) 0.000 0.000 0.000 0.000 enum.py:928(_missing_) 0.000 0.000 0.000 0.000 enum.py:938(_create_pseudo_member_) 0.000 0.000 0.000 0.000 enum.py:977(__and__) 0.000 0.000 0.001 0.001 re.py:250(compile) 0.000 0.000 0.001 0.001 re.py:289(_compile) 0.000 0.000 0.000 0.000 sre_compile.py:249(_compile_charset) 0.000 0.000 0.000 0.000 sre_compile.py:276(_optimize_charset) 0.000 0.000 0.000 0.000 sre_compile.py:453(_get_iscased) 0.000 0.000 0.000 0.000 sre_compile.py:461(_get_literal_prefix) 0.000 0.000 0.000 0.000 sre_compile.py:492(_get_charset_prefix) 0.000 0.000 0.000 0.000 sre_compile.py:536(_compile_info) 0.000 0.000 0.000 0.000 sre_compile.py:595(isstring) 0.000 0.000 0.000 0.000 sre_compile.py:598(_code) 0.000 0.000 0.000 0.000 sre_compile.py:71(_compile) 0.000 0.000 0.000 0.000 sre_compile.py:759(compile) 0.000 0.000 0.000 0.000 sre_parse.py:111(__init__) 0.000 0.000 0.000 0.000 sre_parse.py:160(__len__) 0.000 0.000 0.000 0.000 sre_parse.py:164(__getitem__) 0.000 0.000 0.000 0.000 sre_parse.py:172(append) 0.000 0.000 0.000 0.000 sre_parse.py:174(getwidth) 0.000 0.000 0.000 0.000 sre_parse.py:224(__init__) 0.000 0.000 0.000 0.000 sre_parse.py:233(__next) 0.000 0.000 0.000 0.000 sre_parse.py:249(match) 0.000 0.000 0.000 0.000 sre_parse.py:254(get) 0.000 0.000 0.000 0.000 sre_parse.py:286(tell) 0.000 0.000 0.000 0.000 sre_parse.py:435(_parse_sub) 0.000 0.000 0.000 0.000 sre_parse.py:493(_parse) 0.000 0.000 0.000 0.000 sre_parse.py:76(__init__) 0.000 0.000 0.000 0.000 sre_parse.py:81(groups) 0.000 0.000 0.000 0.000 sre_parse.py:921(fix_flags) 0.000 0.000 0.000 0.000 sre_parse.py:937(parse) 0.000 0.000 0.000 0.000 types.py:171(__get__) 0.000 0.000 0.000 0.000 {built-in method __new__ type object 0x00007FFF032D3C60} 0.000 0.000 0.000 0.000 {built-in method _sre.compile} 0.001 0.001 0.002 0.002 {built-in method builtins.exec} 0.000 0.000 0.000 0.000 {built-in method builtins.isinstance} 30/27 0.000 0.000 0.000 0.000 {built-in method builtins.len} 0.000 0.000 0.000 0.000 {built-in method builtins.max} 0.000 0.000 0.000 0.000 {built-in method builtins.min} 0.000 0.000 0.000 0.000 {built-in method builtins.ord} 0.000 0.000 0.000 0.000 {method 'append' 'list' objects} 0.000 0.000 0.000 0.000 {method 'disable' '_lsprof.Profiler' objects} 0.000 0.000 0.000 0.000 {method 'find' 'bytearray' objects} 0.000 0.000 0.000 0.000 {method 'get' 'dict' objects} 0.000 0.000 0.000 0.000 {method 'items' 'dict' objects} 0.000 0.000 0.000 0.000 {method 'setdefault' 'dict' objects} 0.000 0.000 0.000 0.000 {method 'sort' 'list' objects} Explanation: above example, have imported cProfile modules. have then used run() function cProfile module. have specified compile() function module within this function. Once execute above, observe different time metrics covered under Profile Speed (Time) (like ncalls tottime) this example cProfile. profile module provides similar output with similar commands. typical way, switch profile cProfile unavailable. options Most tools quite fully-fledged tools used monitoring purposes. They will typically offer line method profiling. Timing metrics first-class citizens these tools. won't listing tools here almost will have these features. Understanding Memory profiling Memory usage another common component that profile. objective memory profiling find memory leaks optimize memory usage Python programs. terms generic Python options, most recommended tools memory profiling Python pympler objgraph libraries. Understanding Python Pympler library official documentation Python Pympler library provides more details. utilize Pympler library different ways, shown below: used determine consumption amount memory-specific Python objects. also identify whether objects leaked scope. also track lifetime objects specific classes. consider following example used track lifetime objects classes. Example: from pympler import classtracker import numpy class RandomNumbers: __init__(self, size): self.randomInts np.random.randint(1, 100, size) ctracker classtracker.ClassTracker() ctracker.track_class(RandomNumbers, name RandomNumbers.__name__) ctracker.create_snapshot(description "Random Numbers Begin") rand_1 RandomNumbers((1000, 1000)) rand_2 RandomNumbers((1000, 1000)) rand_3 RandomNumbers((1000, 1000)) ctracker.create_snapshot(description "End") ctracker.stats.print_summary() Output: ---- SUMMARY ------------------------------------------------------------------ Random Numbers Begin active average RandomNumbers active average RandomNumbers 11.44 3.81 ------------------------------------------------------------------------------- Explanation: above snippet code, imported classtracker module from pympler NumPy libraries. have then created class RandomNumbers, where have defined function generate random numbers using randint() function. created object ClassTracker() class used track_class() function track object RandomNumbers class. have then used create_snapshot() function gather current per-instance statistics save total amount memory related Python process. instantiated RandomNumbers class again used create_snapshot() function. last, have printed summary using stats.print_summary() function. Understanding Python objgraph library creator objgraph library, purpose this library help find memory leaks. Marius Gedminas said, "The objective select object memory that should there then what references keeping alive." that Marius emphasized making visualization better objgraph library than other memory profiling tools, which strength. Marius once illustrates working objgraph library finding memory leaks; however, won't looking into here because space constraints. options There tools available memory profiling. Understanding difference between Deterministic profiling statistical profiling While performing profiling, means require monitor execution. That affect underlying software being monitored. Either monitor calls function exception events, utilize random sampling deduce numbers. former called deterministic profiling, latter called statistical profiling. course, every method advantages disadvantages. Deterministic profiling highly precise; however, extra overhead affect accuracy. Statistical profiling less overhead compared, with drawback being lower precision. cProfile library that covered earlier utilizes deterministic profiling. look another open-source Python profiler that utilizes statistical profiling. This profiler known pyinstrument library. Understanding Python pyinstrument library pyinstrument library differentiates itself from other typical profilers ways. First, emphasizes that utilizes statistical profiling instead deterministic profiling. argues that while deterministic profiling provide more precision than statistical profiling, extra precision needs more overhead. extra overhead affect accuracy lead optimization wrong segment program. Especially, states that utilizing deterministic profiling means that "code that makes Python function calls invokes profiler lot, making slower." This results distorted, wrong part program gets optimized. Second, pyinstrument library differentiates itself being "full-stack recording". compare using cProfile library. cProfile library typically measures list functions then orders them time spent each function. contrast, pyinstrument library designed such that will track, instance, reason every single function gets called during request hence, full-stack recording feature. This makes this library ideal famous frameworks like Django Flask based Python. full-stack recording exactly last concept will cover this tutorial. Understanding Full-stack recording different utilities available market considered full-stack recording feature. concept behind full-stack recording that, request progresses through each layer stack, need which layer stack bottleneck performance appears. Sometimes slowness occur outside script written Python. Now, understand well-known options available Options categorize options into types: Open-source Python-specific Hosted Python-specific Python-specific open-source APM, Elastic APM. Examples Python-specific hosted option Relic, Scout, AppDynamics. hosted options quite similar Retrace, owned Stackify. However, retrace one-stop-shop, replacing some other tools only charges utilization. profiling application code, these tools also help trace request. understand consumption wall-clock time request using technology stack, including database queries requests from webserver. This makes these options prominent profiling tools have distributed application. Bonus Section: Profile viewers case gets confused, profile viewers profilers. However, they support turning profiling statistics into more visually pleasing display. example SnakeViz, browser-based graphical viewer output Python cProfile module. Moreover, SnakeViz that offers sunburst diagram. Another option better show statistics from cProfile statistics tuna. Tuna allows handle runtime import profiles, utilizes Bootstrap underlying technologies display. Next TopicBuild Dice-Rolling Application with Python prev next