next prev Metaprogramming with Metaclasses Python Metaprogramming might sound new, user ever worked with Decorators metaclasses, they have used metaprogramming their projects. Therefore, that metaprogramming program that used manipulating program. this tutorial, will discuss metaclasses their uses what their alternatives are. this advanced topic Python, users advised revise basic concepts "Decorators Python" "OOPS concepts Python" before starting this tutorial. Metaclasses Python, every module function associated with some type. example, user variable that integer value, then associated with "int" type. user know type anything using type() method. Example: number print("Type number is:", type(num)) list print("Type list is:", type(list)) name "Mark Jackson" print("Type name is:", type(name)) Output: Type number <class 'int'> Type list <class 'list'> Type name <class 'str'> Explanation Every type Python defined class. Therefore, above example, they object 'int,' 'list' 'str' class type, unlike language Java language which int, char, float primary data types. users create type creating class that type. example, create type Object City class. Example: class City: pass City_object City() now, will print type object City class print("Type City_object is:", type(City_object)) Output: Type City_object <class '__main__.City'> class Python also object, therefore, like other objects, instance Metaclass. metaclass special class type which responsible creating classes Class object. example, user wants find type "City" class, they will find that "type." Example: class City: pass now, will print type City class print("Type City class is:", type(City)) Output: Type City class <class 'type'> classes also object, modify them. example, user subtract fields functions class with other objects. Example: First, will define class without using class methods variables. class City: pass now, will define method variables City.a will now, define class methods City.foo lambda self: print('Pune') then, will create object userobject City() print(userobject.a) userobject.foo() Output: Pune summarize whole metaclass Metaclass used creating Classes, these classes create objects. metaclass responsible creating classes user write their customized metaclasses inserting code extra actions modifying classes created. Usually, user does need customized metaclass, exceptional cases, necessary. There some issues that resolved using metaclass non-metaclass, there some cases which only metaclass used resolving them. Create Customized Metaclass creating customized metaclass, user customized metaclass inherit type metaclass usually override, such __new__(): __new__() function classes before __int__() function. this used creating object return user override this function controlling objects created. __int__(): __int__() function used initializing created object which passed parameter. users create classes using type() method directly. type() method called following ways: shown previous example, user call with argument, will return type. user call three parameters. will create class. following arguments passed Name class Pass tuple which base classes inherited class Class dictionary: This will served local namespace class, which populated with functions variables. Example: City_method(self): print("This City class method!") will create base class class Base: userfunction(self): print("This inherited method!") will create city class dynamically using type() function. City type('City', (Base, dict(a "Mark Jackson", user_method City_method)) now, will print type City print("The Type City class: type(City)) will create instance City class City_object City() print(" Type City_object: type(City_object)) will call inherited method City_object.userfunction() will call City class method City_object.user_method() last will print variable print(City_object.a) Output: Type City class: <class 'type'> Type City_object: <class '__main__.City'> This inherited method! This City class method! Mark Jackson Now, let's create metaclass without using type() function directly. example, will create metaclass called MultiBases, which will check class being created inherited from more than base class. will raise error. Example: Inside metaclass class MultiBases(type): will override __new__() function __new__(city, city_name, bases, citydict): number base classes greator than will raise error len(bases)>1: raise TypeError("There inherited multiple base classes!!!") else will execute __new__() function super class, that will call __init__() function type class return super().__new__(city, city_name, bases, citydict) metaclass specified using 'metaclass' keyword argument will MultiBase class creating classes this will propagated subclasses Base class Base(metaclass MultiBases): pass this will raise error class P(Base): pass this will raise error class Q(Base): pass this will raise error class R(Base): pass This will raise error! class S(P, pass Output: --------------------------------------------------------------------------- TypeError Traceback (most recent call last) <ipython-input-2-409c90c285d5> <module> pass This will raise error! ---> class S(P, pass <ipython-input-2-409c90c285d5> __new__(city, city_name, bases, citydict) will raise error len(bases)>1: ----> raise TypeError("There inherited multiple base classes!!!") else will execute __new__() function super class, that TypeError: There inherited multiple base classes!!! Solve Problem with Metaclass There some problems that users solve using metaclass decorators. there some problems whose solution found only using metaclass. Such user wants debug class function, what they want that whenever class function executed, will print their full qualified name before executing their body. Example: from functools import wraps debugg(funct): '''decorator debugging passed function''' @wraps(funct) wrapperr(*args, **kwargs): print("The full name this Function:", funct.__qualname__) return funct(*args, **kwargs) return wrapperr debug_methods(clas): '''class decorator make debug decorator debuging class functions will check class dictionary callable(function) there any, replace with debugged version key, value vars(clas).items(): callable(value): setattr(clas, key, debugg(value)) return clas sample class @debugmethods class Calculator: add(self, return mul(self, return div(self, return p/q user_cal Calculator() print(user_cal.add(5, print(user_cal.mul(6, print(user_cal.div(21, Output: full name this method: Calculator.add full name this method: Calculator.mul full name this method: Calculator.div Explanation above solution working fine, there problem, which user wants apply decorator method subclasses which have inherited "Calculator" class. that scenario, user apply decorator method separately each subclass, just like above example Calculator class. Now, actual problem there loads subclasses class, applying decorator method individually each subclass challenging time consuming process. resolve this problem, user must make sure that each subclass this debug property, they should look metaclass based solution. Example: will create class normally then immediately will wrap using debug method decorator: from functools import wraps debugg(funct): '''decorator debugging passed function''' @wraps(funct) wrapperr(*args, **kwargs): print("The full name this Function:", funct.__qualname__) return funct(*args, **kwargs) return wrapperr debug_methods(clas): '''class decorator will make debug decorator debug class key, value vars(clas).items(): callable(value): setattr(clas, key, debugg(value)) return clas class debug_Meta(type): '''meta class which feed created class object debug_method getting debug functionality enabled objects''' __new__(clas, clasname, bases, clasdict): object super().__new__(clas, clasname, bases, clasdict) object debug_methods(object) return object base class with metaclass 'debug_Meta' subclass this will have applied debugging function class Base(metaclass debug_Meta):pass now, will inherite Base class Calculator(Base): add(self, return #and then, will inherite Calculator class Calculator_adv(Calculator): mult(self, return Calculator_adv object will show behaviour og debugging user_cal Calculator_adv() print(user_cal.add(3, user_cal Calculator_adv() print(user_cal.mult(3, Output: full name this Function: Calculator.add full name this Function: Calculator_adv.mult When user should Metaclass Users don't metaclass most often, metaclasses mainly used complicated situations. there cases where users metaclass: shown above example, Metaclass used generating down inheritance hierarchies. This will affect subclasses also. user such situations, then they metaclass. user wants change class automatically, they metaclass when created. user application programming interface developer, they metaclasses that purpose. Conclusion this tutorial, have discussed metaclasses, customize metaclass, users them solve problems complicated programming their alternatives. Next TopicPrecision Handling Python prev next