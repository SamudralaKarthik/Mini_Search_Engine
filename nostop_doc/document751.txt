next prev (Depth First Search) Python this tutorial, will learn about Depth first search algorithm implement with Python programming language. will discuss fundamental simplicity. This algorithm used solve graph related problem which will helpful many competitive exams. traversal algorithm which used traverse elements search element graph tree. Let's have basic introduction DFS. Introduction Depth First Search algorithm used traverse target node graph tree data structure. depth-first search derives from word "depth". priorities depth searches along branch, until branch. Python, easily implement using recursion other data structures like dictionaries sets. Representation Graph Before implementing algorithm, will understand represent graph Python. There several versions graph. graph have directed edges (defining source destination) between nodes, undirected edges. directed graph have weights. completely depend upon application versions graph. implement DFS, will graph with directed edges purpose traversal through entire graph. Python provides multiple ways represent graph Python; below most common ways. Adjacency Matrix Adjacency List Adjacency Matrix Adjacency Matrix square matrix shape (where number nodes graph). Each node represents node; each columns represents probable child that node. Each (row, column) pair represents potential edges. non-zero value position specifies existence edge between value zero means there edges between binary number used non-weighted graph represents edge exist, represents doesn't). example value between position represents there edge exists between node with weight represent adjacency matrices using 2-dimensional Numpy array. Adjacency List list collection several lists. Each list represents node graph, stores neighbors/children this node. dictionary represent adjacency list where keys nodes graph, their values list keeping neighbors these nodes. Let's take simple example graph represent using dictionary. above graph given four edges. Let's create Python dictionary represent this graph. graph {"A": ["B", "C"], "B": ["C"], "C": ["D"]} have idea represent graph Python. Let's implement algorithm. Implementing Depth First Search non-recursive approach) Let's consider following graph implementation. Let's define graph adjacency list using Python Dictionary. graph {"A":["B","C","D"], "B":["E"], "C":["G","F"], "D":["H"], "E":["I"], "F":["J"], "G":["K"]} implement both recursion technique non-recursion technique, iterative approach. this section, will understand iterative approach. will stack list keep track visited nodes. First, will visit root node mark visited. Then, will move towards neighbors stack. each step, will item from stack check been visited. node visited, will added path neighbors stack. Pseudocode Below Pseudocode DFS. init() function, function every node because most times, graph contain different disconnect part. makes sure that cover every vertex, also algorithm every node. DFS(G, u.visited true each G.Adj[u] v.visited false DFS(G,v) init() each u.visited false each DFS(G, Note above Pseudocode recursive approach. Let's implement using Python code. Example non_recursive_dfs(graph, source): source None source graph: return "Please Enter Valid input" path stack_val [source] while(len(stack) =stack_val.pop() path: path.append(s) graph: #leaf node continue neighbor_node graph[s]: stack_val.append(neighbor_node) return ".join(path) Output: order traversal graph 'Depth First' manner. using Recursive Method recursive popular problem solving approach which same problem divided into smaller instances. will define base case inside program. Let's understand below example. Example dfs_recursive(graph, source,path []): source path: path.append(source) source graph: leaf node, backtrack return path neighbour graph[source]: path dfs_recursive(graph, neighbour, path) return path graph {"A":["B","C","D"], "B":["E"], "C":["G","F"], "D":["H"], "E":["I"], "F":["J"], "G":["K"]} dfs_element dfs_recursive(graph, "A") print(dfs_element) Output: ['A', 'B', 'E', 'I', 'C', 'G', 'K', 'F', 'J', 'D', 'H'] order traversal again Depth-first manner. Complexity time complexity represented O(V+E), where shows number nodes number edges. space complexity 0(V). Application Algorithm following real-life application DFS. used find path. used test graph bipartite. used finding strongly connected components graph. used detecting cycle graph. used scheduling problem. used topological sorting. Conclusion This tutorial includes concept Depth-First Search Python which used traverse graph tree. have discussed both recursive non-recursive methods implement Python. have also defined represent graph Python. Next TopicFast Tutorial: Framework Create APIs prev next