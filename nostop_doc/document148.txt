next prev Modules Python this article, will discuss module Python programming language, users projects Python. will also discuss users modules conjunction with GitHub that work large projects with other users. will also learn create repository, project files' history, back when project's initial stage files modifies them repository. What Git? module Python language distributed version control system. version control system tools used tracking past files projects. Users easily save state files point instructing version control system. After this, user continue edit files project save project state. Saving project current state like keeping backup project directory. module, saving state referred making commit. Whenever user makes commit module, user adds commit message that explains changes made that state project. module show history changes commits made user project. This feature module really helps users figure what work they have done look specifically bugs that crept into systems. using modules, users also compare files projects with different commits. module also allows user return file files back earlier state project with very little effort. distributed version control system slightly different from version control system. earlier version control system works saving commits locally user's hard drive. This collection commits local hard drive user's known repository. this, users able work with team working same codebase. working with team same project, users need their repository saved platform where other team members access Distributed version control system saves repository chief server, which shared many users developers. This also feature file locking. modules, most users developers GitHub central repository, where anyone access file. GitHub like central place where anyone share code, everyone access that. full repository still saved local repos even after using GitHub. Basic Usage Module Till now, know module general. This topic will discuss users start working with modules their local computer system. Step Creating repository start working with module, users first need enter their information. They have username with configuration command. config global user.name name user goes here config global user.email "username@forexample.com" After setup username, users would need repository work Creating Repository very easy. Users initialization command directory: mkdir sample sample init Users initialize empty repository home sample After creating repository, users search module. module command user uses most frequently status: status This output shows couple information user, like which branch they that they have nothing commit. Nothing commit means that there file directory that module aware that's create repository. Step file Repository Create file repository that does know about Create file sample.py using editor, which only print statement #Sample.py print Adding File After this, user will status command again, they will different results: status After checking file, module will tell user that file untracked. That means saying that particular file part repository under version control. Users this adding file Git. Using command adding file module. sample.py status aware file sample.py, will list file under changes committed. addition file module transfers into staging area. This means users commit file repository. Making Commit Changes Whenever User commits changes, they telling module save this level state file repository. Users using commit command module. option command informs module commit following message. users while running command, module will open editor users create commit message. commit message user should write command like this: commit creating sample.py status Users that commit command returned couple information, most much useful, does tell user that only file changed because user only added file repository. commit command also informs simple hashing algorithm commit (775ca29). After running status command again, shows that user clean working directory, which means that changes file committed Git. Staging Area Module module staging area, which mostly referred index. staging area where module keeps track change's user wants their next commit. Whenever user runs command, like above, where file sample.py moved staging area, this change shown status. file project moved from untracked section module committed section output. staging area module shows exact content file when user command. user modifies this again, file will visible both areas, staging unstaging status output. stage working with module file, which already been committed once, there three versions file available which users work: version user's hard drive that user editing. Another version stored module user's staging area. third version present repository file. three versions file different from another. moving changes staging area users then committing files, they bring back these versions file into sync. .gitignore status command module very accessible, users most often. sometimes, users might find that there couples files that showing untracked section module, they want modules them. that, user .gitignore file. example: #Let's create Python file project same directory called example.py: #example.py get_example return cow After this, modify sample.py file include example.py call function: #sample.py import example example example.get_example print Animal .format (example) Whenever user imports local module, Python starts compiling module into byte code saves file their filesystem. Python2, after compiling module into bytecode, will save file form example.pyc. case python3, will generate _pycache_ directory store .pyc file example: After doing this, user runs command status, they will that particular directory present untracked section. Users also that their example.py file untracked section, changes they made sample.py section, which known "Changes staged commit". This section means that changes user made earlier have been added staging area module. example: status example.py sample.py files repository, user needs same they earlier. example: example.py sample.py status Now, user should commit changes should finish clean commit example module whenever user runs status command, they will _pycache_ directory like this: status user wants _pycache_ directory content ignored, then they have .gitignore file their repository. This very simple process. Users have edit file their chosen editor. .gitignore __pycache__ Then, users have status command, they longer _pycache_ directory content. Although user will .gitignore file. example: status file .gitignore just regular text file, this added repository just like other regular files. example: .gitignore commit create .gitignore There more entrance .gitignore file, which directory that user store their virtual environments. This directory called virtualenvs. virtualenvs directory normally known venv. Users these their .gitignore files project. doing this, directory files project present repository will ignored. there file directory present then, action will done. Users also store global .gitignore file their home directory. This process very easy simple user's editor uses save temporary files makes back files local directory computer system. example: .gitignore __pycache__ Venv Venv Venv.bak env.bak .pytest_cache .cover .coverage What user should Repository? When users initial stage working version control tool, most probably with module. user would want store every kind file repository this mistake. module does have limitations also security concerns which users face some limits what type files data they repository. basic rule version control systems that user should only source files version control systems never generated files version control system. source file file that user creates while typing editor. generated files files that computer creates while processing source files. example: Sample.py source file, while Sample.pyc generated file. reasons involving generated files repository: Storing generated files repository waste space time. generated files created again, need recreated different format. user using IronPython Cython, user using Jython interpreter, then .pyc files would different from each other. committing format .pyc file could create conflicts repository. generated filers comparatively larger than source files project. Adding generated files repository means that other users developers particular project also have download files store them, even they need files. Another rule repository that user should commit binary files with precautions should avoid committing files large size. module repository does save full replica each file project user commit. Instead, repository uses complicated algorithm, which based different following versions files. This reduces quantity storage file needs. this algorithm does apply binary files binary files such files have good difference tools. binary files, module repository save full file project whenever user makes commit. When user working module, storing files GitHub repositories save confidential information repository, while sharing publicly. command module. used seeing history commits made user. example: Users history commits made user repository. commit message will appear order they were made. starting commit will identified word "commit" after simple hashing area commit. command will provide history every simple hashing areas. Conclusion This article discussed modules, version control system, make commit repository functions, rules adding files information repositories module GitHub. different types command like .gitignore, log, add, status, etc., their files project directories. Next TopicTop Python Frameworks Gaming prev next