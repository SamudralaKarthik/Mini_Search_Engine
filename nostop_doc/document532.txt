next prev Python pympler library Programming language like Python consists different sets libraries perform memory profiling. Examples such libraries memory_profiler, guppy/heapy, scalene, etc. these libraries offer usage memory through python code several ways. However, there provision monitoring memory utilization objects created with help user-defined classes them. There situations where require monitoring usage memory specific kind object. Python library known pympler very useful those requirements. pympler library consists list modules that allows monitor memory utilization scripting Python different ways. following tutorial, will understand different modules available pympler library with help various examples. let's started. Understanding Python pympler library pympler library development tool used measure, monitor, analyze behaviour memory Python objects running Python-based application. obtain detailed insight into size lifetime Python objects pympling Python application. also easily identify undesirable unexpected runtime behaviour such memory bloat other "pymples". Pympler integrates three previously separate modules into single, comprehensive profiling utility. asizeof module offers fundamental size detail several Python objects. muppy module utilized online monitoring Python application. ClassTracker class overs off-line analysis lifetime selected Python objects. profiling frontend exposes process statistics, garbage visualization class tracker statistics. Requirements pympler library pympler library completely written Python, with dependencies external libraries. This library integrates Bottle Flot. Pympler library been tested with Python 3.5, 3.6, 3.7, 3.8, 3.9, 3.10. Pympler platform-independent library tested different Linux distributions (32-bits 64-bits), Windows MacOS Install Python pympler library? order install Python library, need 'pip', framework manage packages required install modules from trusted public repositories. Once have 'pip', install pympler library using command from Windows command prompt (CMD) terminal shown below: Syntax: python.exe install pympler Verifying Installation Once module installed, verify creating empty Python program file writing import statement follows: File: verify.py import pympler Now, save above file execute using following command terminal: Syntax: python verify.py above Python program file does return error, library installed properly. However, case where exception raised, reinstalling library, also recommended refer official documentation pympler library. following tutorial, will cover list modules shown below: asizeof classtracker classtracker_stats tracker muppy garbagegraph refbrowser refgraph summary understand these modules pympler library detail. Understanding asizeof module asizeof module allows measure size objects with different methods provides. Some these methods described following table: Methods Description asizeof() This method accepts single multiple objects input returns size each object bytes. asized() This method accepts object input returns list objects type pympler.asizeof.Asized, which contains information regarding memory utilization objects passed. format() This method allows format memory information available specific object. This provides with detailed insight into complex objects. itemsize() This method returns size single object bytes from list objects. basicsize() This method returns basic size object bytes. flatsize() This method returns flat size object bytes. refs() This method returns list objects referred object passed isclass() This method accepts object input returns True object class else False. isbuiltin() This method accepts object input returns True object built-in Python keyword else False. iscode() This method accepts object input returns True object code else False. isframe() This method accepts object input returns True object frame else False. isfunction() This method accepts object input returns True object function else False. ismethod() This method accepts object input returns True object method else False. ismodule() This method accepts object input returns True object module else False. consider some examples demonstrating usage above methods asizeof module. Example from pympler import asizeof list1 range(20)] list2 range(20) print("Size List list1: bytes" %asizeof.asizeof(list1)) print("Size List list2: bytes" %asizeof.asizeof(list2)) print("Size List list1, list2 combined: bytes" %asizeof.asizeof(list1, list2)) print("Size List list1 list2: bytes, bytes" %asizeof.asizesof(list1, list2)) Output: Size List list1: bytes Size List list2: bytes Size List list1, list2 combined: 928 bytes Size List list1 list2: bytes, bytes Explanation: above snippet code, have imported asizeof module from pympler library. have then defined different lists. have then used asizeof() asizesof() methods calculate size different lists print results users. Example from pympler import asizeof list1 range(20)] list2 range(20) asizedObj asizeof.asized(list1) print("Object Type: type(asizedObj)) print(asizedObj) print("Flat Size Total Size %d\n"%(asizedObj.flat, asizedObj.size)) asizedObjs asizeof.asized(list1, list2) print(asizedObjs[0].format()) print(asizedObjs[1].format()) print("\nObject Stats: print(asizeof.asized(list1, detail stats 1).format()) print("\nObject Details: print(asizeof.asized(list1, detail 1).format()) Output: Object Type: size 880, flat 248, refs[0], name '[0, 19]' Flat Size 248, Total Size size=880 flat=248 range(0, size=48 flat=48 Object Stats: asized(detail=0, stats=1): size 880, flat 248, refs[0], name '[0, 19]' bytes byte aligned byte sizeof(void*) object given objects sized objects seen objects missed duplicates deepest recursion size=880 flat=248 Object Details: size=880 flat=248 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=32 flat=32 size=24 flat=24 Explanation: above snippet code, have again imported required module defined different lists. have then defined object that stores list generated from asized() function. have then printed type object along with object. have then used flat size attributes return flat size total size object. have then again used asized() method include both lists. have then printed format both lists. last, have printed object stats details. Example from pympler import asizeof list1 range(20)] print("Size Single element List bytes" %asizeof.itemsize(list1)) print("Basic Size Object bytes" %asizeof.basicsize(list1)) print("Flat Size Object bytes" %asizeof.flatsize(list1)) print("List Objects Referred Object asizeof.refs(list1)) Output: Size Single element List bytes Basic Size Object bytes Flat Size Object bytes List Objects Referred Object Explanation: above snippet code, have used methods like itemsize(), basicsize(), flatsize() refs() print different details with respect list defined. Example from pympler import asizeof import random list1 range(20)] print("Is Object Class ",asizeof.isclass(list1)) print("Is Object Built-in ",asizeof.isbuiltin(list1)) print("Is Object Code ",asizeof.iscode(list1)) print("Is Object Frame ",asizeof.isframe(list1)) print("Is Object Function ",asizeof.isfunction(list1)) print("Is Object method ",asizeof.ismethod(list1)) print("Is Object Module ",asizeof.ismodule(list1)) print() print("Is Object Module ",asizeof.ismodule(random)) print() methodTest(): return random.randint(1, 150) print() print("Is Object Function ",asizeof.ismethod(methodTest)) print("Is Object method ",asizeof.isfunction(methodTest)) class The_testing: __init__(self): pass testPrint(self): print("Testing Class") myTesting The_testing() print() print("Is Object Function asizeof.ismethod(myTesting.testPrint)) print("Is Object method asizeof.isfunction(myTesting.testPrint)) print("Is Object Class asizeof.isclass(The_testing)) print() print("Is Object Built-in asizeof.isbuiltin(min)) print("Is Object Built-in asizeof.isbuiltin(sum)) print("Is Object Built-in asizeof.isbuiltin(max)) Output: Object Class False Object Built-in False Object Code False Object Frame False Object Function False Object method False Object Module False Object Module True Object Function False Object method True Object Function True Object method False Object Class True Object Built-in True Object Built-in True Object Built-in True Explanation: have imported required modules defined list above snippet code. have then used different methods like isclass(), isbuiltin(), iscode(), isframe(), isfunction(), ismethod() ismodule() print different Boolean outputs. Understanding classtracker classtracker_stats module classtracker module allows monitor memory utilization objects created user-defined classes with different methods. classtracker_stats module allows format data capture with help classtracker module various ways. following section, will understand with help different examples trace memory utilization specific kinds user-defined objects then format stats monitoring several ways using classtracker classtracker_stats modules. There various classes methods that these modules offer. Some them described below: Classes/Methods Description classtracker.ClassTracker() This class allows create object which monitor memory utilization object specific type. ClassTracker.track_class() This method accepts reference class input which want monitor. ClassTracker.create_snapshot() This method allows record memory usage registered classes point when called. ClassTracker.stats.print_summary() This method allows print snapshots taken since starting. ClassTracker.close() This method will inform class tracker stop monitoring everything. ClassTracker.clear() This method allows clear stats collected till now. ClassTracker.track_object() This method allows monitor memory usage object passed ClassTracker.track_change() This method allows monitor memory usage object passed well changes ClassTracker.detach_class() This method accepts class reference input removes that class from monitoring list class tracker. ClassTracker.stats.sort_stats() This method allows sort stats monitoring. give sorting like name class, active, average, pct., etc. ClassTracker.stats.dump_stats() This method allows dump monitoring stats output file. classtracker_stats.HtmlStats() This class accepts class tracker instance input will responsible formatting monitoring stats html. HtmlStats.create_html() This method will create HTML file monitoring stats. will also create supporting folder files with same name HTML file name. classtracker.PeriodicThread() This class accepts class tracker instance input interval seconds. will then take snapshots that interval. PeriodicThread.tracker.stop_periodic_snapshot() call this method inform periodic thread stop taking snapshots. PeriodicThread.tracker.start_periodic_snapshots() call this method inform periodic thread start taking snapshots consider some examples demonstrating above classes methods classtracker module. Example import numpy from pympler import classtracker class RandomNumberGenerator: __init__(self, size): self.randomInts np.random.randint(1, 150, size) ctrack classtracker.ClassTracker() ctrack.track_class(RandomNumberGenerator, name RandomNumberGenerator.__name__) ctrack.create_snapshot(description "Start") randOne RandomNumberGenerator((1500,1500)) randTwo RandomNumberGenerator((1500,1500)) randThree RandomNumberGenerator((1500,1500)) ctrack.create_snapshot(description "Intermediate") ctrack.stats.print_stats() randThree ctrack.create_snapshot(description "End") ctrack.stats.print_summary() ctrack.close() Output: ---- SUMMARY ------------------------------------------------------------------ Start active average RandomNumberGenerator Intermediate active average RandomNumberGenerator 25.75 12.88 active average RandomNumberGenerator 17.17 8.58 ------------------------------------------------------------------------------- Explanation: above snippet code, have imported required modules. have then defined class generate random numbers. created object ClassTracker() class used track_class() method track created class. have then used create_snapshot() method record memory usage registered class. created multiple objects class again used create_snapshot() method. deleted object class again used create_snapshot() method. last, have printed summary using stats.print_summary() method closed processing using close() method. Example import numpy from pympler import classtracker class RandomNumberGenerator: __init__(self, size): self.randomInts np.random.randint(1, 150, size) class RandDistribution: __init__(self, size): self.uniformDist np.random.uniform(size size) ctrack classtracker.ClassTracker() ctrack.track_class(RandomNumberGenerator, name RandomNumberGenerator.__name__) ctrack.track_class(RandDistribution, name RandDistribution.__name__) ctrack.create_snapshot(description "Start") randOne RandomNumberGenerator((1000,1000)) randTwo RandomNumberGenerator((1000,1000)) unifDistOne RandDistribution((100,100)) unifDistTwo RandDistribution((100,100)) ctrack.create_snapshot(description "Intermediate") randTwo, unifDistTwo ctrack.create_snapshot(description "End") ctrack.stats.print_summary() ctrack.clear() ctrack.stats.print_summary() ctrack.close() Output: ---- SUMMARY ------------------------------------------------------------------ Start active average RandDistribution RandomNumberGenerator Intermediate active average RandDistribution 156.84 78.42 RandomNumberGenerator 7.63 3.81 active average RandDistribution 78.45 78.45 RandomNumberGenerator 3.82 3.82 ------------------------------------------------------------------------------- ---- SUMMARY ------------------------------------------------------------------ ------------------------------------------------------------------------------- Explanation: above snippet code, have again imported required modules created different classes. created object ClassTracker() class used track_class() method both classes. have then used create_snapshot() method multiple times record memory usage both classes. have also performed different functions like instantiating class deleting object. have then printed summary. have used clear() method clear stats collected. last, have printed summary again closed process. Example import numpy from pympler import classtracker class RandomNumberGenerator: __init__(self, size): self.randomInts np.random.randint(1, 150, size) class RandDistribution: __init__(self, size): self.uniformDist np.random.uniform(size size) randOne RandomNumberGenerator((1500, 1500)) randTwo RandomNumberGenerator((1500, 1500)) unifDistOne RandDistribution((150, 150)) unifDistTwo RandDistribution((150, 150)) ctrack classtracker.ClassTracker() ctrack.track_object(randOne) ctrack.track_change(randOne) ctrack.track_object(randTwo) ctrack.track_change(randTwo) ctrack.track_object(unifDistOne) ctrack.track_change(unifDistOne) ctrack.track_object(unifDistTwo) ctrack.track_change(unifDistTwo) ctrack.create_snapshot(description "Start") randOne.randomInts np.random.randint(1, 150, (150, 150)) ctrack.create_snapshot(description "Intermediate") randTwo ctrack.create_snapshot(description "End") ctrack.stats.print_summary() ctrack.close() Output: ---- SUMMARY ------------------------------------------------------------------ Start active average RandDistribution 352.16 RandomNumberGenerator 88.22 Intermediate active average RandDistribution 352.16 RandomNumberGenerator 88.22 active average RandDistribution 352.16 RandomNumberGenerator 88.22 ------------------------------------------------------------------------------- Explanation: above snippet code, have seen methods like track_object() track_change() order monitor memory usage object, passed changes Example import numpy from pympler import classtracker class RandomNumberGenerator: __init__(self, size): self.randomInts np.random.randint(1, 150, size) class RandDistribution: __init__(self, size): self.uniformDist np.random.uniform(size size) ctrack classtracker.ClassTracker() ctrack.track_class(RandomNumberGenerator, name RandomNumberGenerator.__name__) ctrack.track_class(RandDistribution, name RandDistribution.__name__) ctrack.create_snapshot(description "Start") randOne RandomNumberGenerator((1500, 1500)) randTwo RandomNumberGenerator((1500, 1500)) unifDistOne RandDistribution((150, 150)) unifDistTwo RandDistribution((150, 150)) ctrack.create_snapshot(description "Intermediate") randTwo, unifDistTwo ctrack.create_snapshot(description "End") ctrack.stats.print_summary() Detaching "RandomNumberGenerator". Already monitored instance will monitored future instance won't monitored detach_all() detach_all_classes() detaches objects classes. ctrack.detach_class(RandomNumberGenerator) randOne rand3 RandomNumberGenerator((1000,1000)) ctrack.create_snapshot(description "Last") ctrack.stats.sort_stats().print_summary() print("Tracked Classes ctrack.stats.tracked_classes) ctrack.stats.dump_stats("pympler_stats.out") ctrack.close() Output: ---- SUMMARY ------------------------------------------------------------------ Start active average RandDistribution RandomNumberGenerator Intermediate active average RandDistribution 176.11 RandomNumberGenerator 8.58 8.58 active average RandDistribution 176.11 RandomNumberGenerator 8.58 8.58 ------------------------------------------------------------------------------- ---- SUMMARY ------------------------------------------------------------------ Start active average RandDistribution RandomNumberGenerator Intermediate active average RandDistribution 176.11 RandomNumberGenerator 8.58 8.58 active average RandDistribution 176.11 RandomNumberGenerator 8.58 8.58 Last active average RandDistribution 176.11 176.11 RandomNumberGenerator ------------------------------------------------------------------------------- Tracked Classes ['RandDistribution', 'RandomNumberGenerator'] Explanation: above snippet code, have illustrated method removing class that want monitor dumping monitoring stats output file that load later. this example, have used detach_class(), stats.sort_stats(), stats.dump_stats() methods. First all, have registered classes created earlier monitoring, then created instances classes, deleted instances, then unregistered class from monitoring. have also taken memory snapshot between steps. have then checked still monitoring object that class getting created. last, have stored monitoring stats output file. classtracker module also offers ConsoleStats class which allows load monitoring stats from file. Below have reloaded again monitoring stats store file previous step printed stats again verify. Example ctrack classtracker.ClassTracker() consoleStats classtracker.ConsoleStats(ctrack, "pympler_stats.out") consoleStats.print_summary() print("Tracked Classes ",consoleStats.tracked_classes) Output: ---- SUMMARY ------------------------------------------------------------------ Start active average RandDistribution RandomNumberGenerator Intermediate active average RandDistribution 176.11 RandomNumberGenerator 8.58 8.58 active average RandDistribution 176.11 RandomNumberGenerator 8.58 8.58 Last active average RandDistribution 176.11 176.11 RandomNumberGenerator ------------------------------------------------------------------------------- Tracked Classes ['RandDistribution', 'RandomNumberGenerator'] Explanation: above snippet code, have used ConsoleStats() class printed summary. Example import numpy from pympler import classtracker, classtracker_stats class RandomNumberGenerator: __init__(self, size): self.randomInts np.random.randint(1, 150, size) class RandDistribution: __init__(self, size): self.uniformDist np.random.uniform(size size) ctrack classtracker.ClassTracker() ctrack.track_class(RandomNumberGenerator, name RandomNumberGenerator.__name__) ctrack.track_class(RandDistribution, name RandDistribution.__name__) htmlStats classtracker_stats.HtmlStats(ctrack) ctrack.create_snapshot(description "Start") randOne RandomNumberGenerator((1500, 1500)) randTwo RandomNumberGenerator((1500, 1500)) unifDistOne RandDistribution((150, 150)) unifDistTwo RandDistribution((150, 150)) ctrack.create_snapshot(description "Intermediate") #ctrack.stats.print_stats() randTwo, unifDistTwo ctrack.create_snapshot(description "End") ctrack.stats.print_summary() htmlStats.dump_stats("pympler_html_stats.out") print("Tracked Classes ",htmlStats.tracked_classes) htmlStats.create_html("html_stats.html") ctrack.close() Output: ---- SUMMARY ------------------------------------------------------------------ Start active average RandDistribution RandomNumberGenerator Intermediate active average RandDistribution 352.16 176.08 RandomNumberGenerator 17.17 8.58 active average RandDistribution 176.11 176.11 RandomNumberGenerator 8.58 8.58 ------------------------------------------------------------------------------- Tracked Classes ['RandDistribution', 'RandomNumberGenerator'] HTML Output: Explanation: above snippet code, have explained method formatting monitoring statistics HTML file with charts explaining class's memory usage using HtmlStats() class. have then used create_html() method create HTML file. Example import numpy from pympler import classtracker import time class RandomNumberGenerator: __init__(self, size): self.randomInts np.random.randint(1, 150, size) class RandDistribution: __init__(self, size): self.uniformDist np.random.uniform(size size) ctrack classtracker.ClassTracker() ctrack.track_class(RandomNumberGenerator, name RandomNumberGenerator.__name__) ctrack.track_class(RandDistribution, name RandDistribution.__name__) periodicThread classtracker.PeriodicThread(ctrack, 0.1) periodicThread.start() randOne RandomNumberGenerator((1500, 1500)) unifDistOne RandDistribution((150, 150)) ctrack.stats.print_summary() periodicThread.tracker.stop_periodic_snapshots() randTwo RandomNumberGenerator((1500, 1500)) unifDistTwo RandDistribution((150, 150)) ctrack.stats.print_summary() periodicThread.tracker.start_periodic_snapshots() ctrack.stats.print_summary() ctrack.close() Output: ---- SUMMARY ------------------------------------------------------------------ active average RandDistribution RandomNumberGenerator ------------------------------------------------------------------------------- ---- SUMMARY ------------------------------------------------------------------ active average RandDistribution RandomNumberGenerator ------------------------------------------------------------------------------- ---- SUMMARY ------------------------------------------------------------------ active average RandDistribution RandomNumberGenerator active average RandDistribution 352.16 176.08 RandomNumberGenerator 17.17 8.58 ------------------------------------------------------------------------------- Explanation: above snippet code, have explained method inform class tracker take snapshots periodically rather than manually taking snapshots each time using PeriodicThread() class. above example, have shown tracker.stop_periodic_snapshots() tracker.start_periodic_snapshots() methods. Understanding tracker module tracker module allows monitor overall memory usage over time. allow track difference memory usage between summaries. will start importing tracker module from pympler library: Syntax: from pympler import tracker These following classes methods that tracker module offers: Classes Methods Description tracker.SummaryTracker() This class allows monitor memory utilization between summaries. SummaryTracker.create_summary() This method allows create summary memory usage. SummaryTracker.print_diff() This method allows find difference between summaries. diff() This method returns difference between summaries list. consider some examples demonstrating usage above methods. Example from pympler import tracker summaryTracker tracker.SummaryTracker() summaryTracker.print_diff() Output: types objects total size ========================================= =========== ============ list 3871 334.62 3875 270.01 881 24.10 dict 1.48 code 1.22 tuple pympler.asizeof.Asized function (store_info) pympler.process._ProcessMemoryInfoWin32 pympler.classtracker.Snapshot cell weakref method float Explanation: above snippet code, have imported required module. have then created instance SummaryTracker() class print difference between summaries using print_diff() method. Example from pympler import tracker summaryTracker tracker.SummaryTracker() summaryTracker.create_summary() Creating Temporary List Check presence difference temp_list [i*i range(15000)] summaryTracker.create_summary() summaryTracker.print_diff(summary1 s_0, summary2 s_1) Output: types objects total size ========================================= =========== ============ list 3870 453.31 15858 433.62 3874 269.93 dict pympler.asizeof.Asized tuple 448 code pympler.process._ProcessMemoryInfoWin32 pympler.classtracker.Snapshot float Explanation: above snippet code, have imported required module. have then created instance SummaryTracker() class created different summaries using create_summary() method. have then used print_diff() method print difference between both summary memory usage. Example from pympler import tracker summaryTracker tracker.SummaryTracker() summaryTracker.create_summary() Creating Temporary List Check presence difference temp_list [i*i range(15000)] summaryTracker.create_summary() print(sorted(summaryTracker.diff(summary1 s_0, summary2 s_1), lambda x[2], reverse True)) Output: ['list', 3870, 464192], ['int', 15856, 443976], ['str', 3874, 276407], ['dict', 576], ['pympler.asizeof.Asized', 512], ['tuple', 448], ['code', 413], ['pympler.process._ProcessMemoryInfoWin32', 96], ['pympler.classtracker.Snapshot', 96], ['float', Explanation: above snippet code, have used diff() method return difference between summaries list used sorted() method sort list printed users. Understanding muppy module muppy module allows developer detect memory leaks. will start importing muppy module from pympler library: Syntax: from pympler import muppy Different methods that muppy module provides described follows: Methods Description muppy.get_objects() This method returns list objects memory. muppy.filter() This method allows filter objects passed order keep only objects specific type. muppy.get_referents() This method allows find objects referring object passed muppy.print_summary() This method allows print memory usage table. muppy.getsizeof() This method returns size object bytes. consider following examples illustrating usage above methods muppy module: Example from pympler import muppy the_objects muppy.get_objects() print("Number Objects len(the_objects)) Output: Number Objects 50880 Explanation: above snippet code, have imported required module used get_objects() method list objects memory printed total number objects using len() method. Example from pympler import muppy the_objects muppy.get_objects() objectsByType muppy.filter(the_objects, Type list) print(objectsByType[:5]) Output: [( 2294, 140, 'the_objects muppy.get_objects()\nprint("Number Objects len(the_objects))', 'the_objects muppy.get_objects()\nprint("Number Objects len(the_objects))' )], Explanation: above snippet code, have used filter() method filter objects list printed list users. Example from pympler import muppy the_list [i*i range(5999)] allObjectsReferredByList muppy.get_referents(the_list) print("Number Objects Referred List the_list len(allObjectsReferredByList)) muppy.print_summary() theList [i*i range(15000)] print("Size List theList bytes" %muppy.getsizeof(theList)) Output: Number Objects Referred List the_list 5999 types objects total size ============================ =========== ============ 15902 3.10 dict 4296 1.67 code 5352 924.66 type 836 654.47 list 563.39 7640 213.69 213.30 tuple 3411 194.41 wrapper_descriptor 2201 154.76 method_descriptor 1239 87.12 abc.ABCMeta 85.15 builtin_function_or_method 1210 85.08 weakref 1177 82.76 getset_descriptor 849 53.06 frozenset 47.48 Size List theList 121432 bytes Explanation: above snippet code, have demonstrated get_referents(), print_summary(), getsizeof() methods. Understanding garbagegraph module garbagegraph module allows monitor cyclic objects. This module consists class named GarbageGraph, which accepts input list objects generates graphviz visualization displaying relation between them, which support detect cycle. GarbageGraph extension ReferenceGraph, which will discussing refgraph section. will start importing garbagegraph module from pympler library: Syntax: from pympler import garbagegraph following methods that garbagegraph module offers: Methods Description GarbageGraph.write_graph() This method allows save reference graphs output file. GarbageGraph.render() This method allows render graph creating with help write_graph() method graphviz graph with extension. consider example demonstrating usage above methods garbagegraph module. Example: from pympler import garbagegraph True [10, refGraph garbagegraph.GarbageGraph([p, refGraph.write_graph("refGraph.out") print(refGraph.render("refGraph1.out")) Output File: refGraph.out Process this file with graphviz digraph node [shape=box]; "Xx7f39954b7340" label "'A'\nstr" "Xx55ca999273e0" label "True\nbool" "Xx7f38d1955cf0" label "{'A': True}\ndict" "Xx7f38d0ab2508" label "[10, 30]\nlist" "Xx7f38d1404b88" label "{20 30}\ndict" Xx7f38d1955cf0 Xx55ca999273e0 [label="A"]; Output: True Explanation: above snippet code, have shown usage write_graph() render() methods garbagegraph module. Understanding refbrowser module refbrowser module allows print tree-like illustrations object referrers. will start importing refbrowser module from pympler library: Syntax: from pympler import refbrowser consider following examples demonstrating ConsoleBrowser FileBrowser classes refbrowser module. Example from pympler import refbrowser the_browser refbrowser.ConsoleBrowser(q) print("Using ConsoleBrowser Class:") the_browser.print_tree() Output: Using ConsoleBrowser Class: str-+-list--dict--module(__main__) +-dict--module(__main__)--dict +-frozenset--dict-+-module(sre_parse) +-function (_class_escape) +-function (_escape) +-function (_uniq) +-function (_parse_sub) +-function (_parse) +-function (_parse_flags) +-function (fix_flags) +-function (parse) +-function (parse_template) +-function (expand_template) +-function (__init__) +-function (opengroup) +-function (closegroup) +-function (checkgroup) +-function (checklookbehindgroup) +-function (__init__) +-function (dump) +-function (__repr__) +-function (__len__) +-function (__delitem__) +-function (__getitem__) +-function (__setitem__) +-function (insert) +-function (append) +-function (getwidth) +-function (__init__) +-function (__next) +-function (match) +-function (get) +-function (getwhile) +-function (getuntil) +-function (tell) +-function (seek) +-function (error) +-function (groups) +-function (pos) Explanation: From above example, understand creation tree-like exploration objects with help ConsoleBrowser class refbrowser module. Example from pympler import refbrowser fileBrowser refbrowser.FileBrowser(q) print("Using FileBrowser Class:") fileBrowser.print_tree("tree.out") Output: Using FileBrowser Class: str-+-frame (codename: _get_tree)-+-frame (codename: _get_tree)-+-frame (codename: _get_tree) +-list +-frame (codename: _get_tree)-+-frame (codename: _get_tree) +-list +-frame (codename: _get_tree)-+-frame (codename: _get_tree) +-list +-list +-frame (codename: _get_tree)-+-frame (codename: _get_tree) +-list +-frame (codename: _get_tree)-+-frame (codename: _get_tree) +-list +-list +-frame (codename: _get_tree)-+-list +-frame (codename: _get_tree) +-list +-frame (codename: _get_tree)-+-list +-frame (codename: _get_tree) +-frame (codename: _get_tree)-+-list +-frame (codename: _get_tree) +-frame (codename: _get_tree)--list +-list-+-list-+-list +-list +-list +-list +-list +-list +-frame (codename: _get_tree) +-list +-list +-list +-list +-list +-frame (codename: _get_tree) +-frame (codename: _get_tree)-+-list +-frame (codename: _get_tree) +-list +-dict-+-list +-list +-frame (codename: _get_tree) +-frame (codename: _get_tree) +-frame (codename: _get_tree) +-module(__main__) Explanation: From above example, understand creation tree-like exploration objects with help FileBrowser class refbrowser module. Understanding refgraph module refgraph module allows create graphviz graph references. will start importing refgraph module from pympler library: Syntax: from pympler import refgraph following methods that refgraph module offers: Classes Methods Description refgraph.ReferenceGraph() This class accepts list objects input then creates reference graph displaying their relation. ReferenceGraph.write_graph() This method allows save reference graphs output file. ReferenceGraph.render() This method allows render graph creating with help write_graph() method graphviz graph with extension. consider some examples demonstrating usage above methods refgraph module. Example from pympler import refgraph True [10, refGraph refgraph.ReferenceGraph([p, refGraph.write_graph("refGraphGraphviz") Output: Process this file with graphviz digraph node [shape=box]; "Xx238d66c43f0" label "'A'\nstr" "Xx7ffb66896868" label "True\nbool" "Xx238d6665b40" label "{'A': True}\ndict" "Xx238e53935c0" label "[10, 30]\nlist" "Xx238d6665c00" label "{20: 30}\ndict" Xx238d6665b40 Xx7ffb66896868 [label="A"]; Explanation: above snippet code, have imported required module defined some objects. have then created object ReferenceGraph() class that accepts list objects defined earlier. have then used write_graph() method save reference graph output file. Example from pympler import refgraph True [10, refGraph refgraph.ReferenceGraph([p, print(refGraph.render("refGraphGraphviz")) Output: True Explanation: above snippet code, have demonstrated render() method ReferenceGraph() class. Understanding summary module summary module allows create summary list objects. will start importing summary module from pympler library: Syntax: from pympler import summary following methods that summary module offers: Methods Description summary.summarize() This method allows create summary list objects table. summary.print_() This method allows print output summarize() method table format. summary.get_diff() This method allows find different types summary generated summarize() method. consider example demonstrating usage above methods summary module. Example from pympler import summary sumByType summary.summarize(objectsByType) summary.print_(sumByType) Output: types objects total size ======= =========== ============ list 79.32 Explanation: above snippet code, have imported required module. have then used summarize() method create summary list objects table. have then used print_() method print output summarize() method. Example from pympler import summary sumByList summary.summarize(allObjectsReferredByList) summary.print_(sumByList) Output: types objects total size ======= =========== ============ 5999 164.03 Explanation: above snippet code, have imported required module. have then used summarize() method create summary list objects table. have then used print_() method print output summarize() method. Example from pympler import summary sumFull summary.summarize(the_objects) summary.print_(sumFull) Output: types objects total size ============================ =========== ============ 16673 3.21 dict 4544 1.77 code 5638 975.36 type 703.47 213.51 tuple 3615 205.41 wrapper_descriptor 2294 161.30 builtin_function_or_method 1486 104.48 method_descriptor 1306 91.83 weakref 1242 87.33 abc.ABCMeta 85.15 list 342 79.16 getset_descriptor 56.31 1814 54.70 frozenset 47.48 Explanation: above snippet code, have imported required module. have then used summarize() method create summary list objects table. have then used print_() method print output summarize() method. Example from pympler import summary sumByType summary.summarize(objectsByType) sumFull summary.summarize(the_objects) theDiff summary.get_diff(sumByType, sumFull) summary.print_(theDiff) Output: types objects total size ============================ =========== ============ 16671 3.21 dict 4542 1.77 code 5638 975.36 type 703.47 213.51 tuple 3611 205.20 wrapper_descriptor 2294 161.30 builtin_function_or_method 1486 104.48 method_descriptor 1306 91.83 weakref 1242 87.33 abc.ABCMeta 85.15 getset_descriptor 56.31 1804 54.42 frozenset 47.48 function (__init__) 33.60 Explanation: above snippet code, have shown get_diff() method summary module. Next TopicSnakeViz library Python prev next