next prev Stack Python this tutorial, will learn basics stack implement using Python code. What Stack? stack linear data structure where data arranged objects over another. stores data LIFO (Last First Out) manner. data stored similar order plates arranged above another kitchen. simple example stack Undo feature editor. Undo feature works last event that have done. always pick last plate from stack plate. stack, element inserted element removed only that end. perform operations stack PUSH POP. PUSH operation when element POP operation when remove element from stack. Methods Stack Python provides following methods that commonly used with stack. empty() returns true, stack empty. time complexity O(1). size() returns length stack. time complexity O(1). top() This method returns address last element stack. time complexity O(1). push(g) This method adds element stack time complexity O(1). pop() This method removes topmost element stack. time complexity O(1). Implementation Stack Python offers various ways implement stack. this section, will discuss implementation stack using Python module. implement stack Python following ways. List dequeu LifeQueue Implementation Using List Python list used stack. uses append() method insert elements list where stack uses push() method. list also provides pop() method remove last element, there shortcomings list. list becomes slow grows. list stores element next other. list grows block memory then Python allocates some memory. That's list become slow. Let's understand following example initial empty stack my_stack append() function push element my_stack my_stack.append('x') my_stack.append('y') my_stack.append('z') print(my_stack) pop() function element from my_stack LIFO order print('\nElements poped from my_stack:') print(my_stack.pop()) print(my_stack.pop()) print(my_stack.pop()) print('\nmy_stack after elements poped:') print(my_stack) Output: ['x', 'y', 'z'] Elements poped from my_stack: my_stack after elements poped: Traceback (most recent call last): File "C:/Users/DEVANSH SHARMA/PycharmProjects/Hello/Stack.py", line <module> print(my_stack.pop()) IndexError: from empty list Explanation above code, have defined empty list. inserted elements using append() method. That similar push() method. also removed elements using pop() method. pop() method returns last element list. Implementation using collection.deque collection module provides deque class, which used creating Python stacks. deque pronounced "deck" which means "double-ended queue". deque preferred over list because performs append operation faster than list. time complexity O(1), where list takes O(n). Let's understand following example Example from collections import deque my_stack deque() append() function used push element my_stack my_stack.append('a') my_stack.append('b') my_stack.append('c') print('Initial my_stack:') print(my_stack) pop() function used element from my_stack LIFO order print('\nElements poped from my_stack:') print(my_stack.pop()) print(my_stack.pop()) print(my_stack.pop()) print('\nmy_stack after elements poped:') print(my_stack) Output: Initial my_stack: deque(['a', 'b', 'c']) Elements poped from my_stack: my_stack after elements poped: deque([]) Explanation: above code almost similar previous example. However, only difference that, have imported deque from collection module. Deque list list stores element right next each other uses contiguous memory. This most effective several operations, like indexing into list. example Getting list1[2] fast Python knows exact position particular element. contiguous memory also allows slice work well lists. list consumes extra time append() some objects than others. block contiguous memory full, will another block that take much longer time than normal append() function. Implementation Using queue module queue module LIFO queue, which same stack. Generally, queue uses put() method data method take data. Below methods that available queue. empty() queue empty, returns true; otherwise return false. maxsize() This method used maximum number elements allowed queue. get() returns removes element from queue. Sometime. queue empty; waits until element available. full() returns True queue full. queue defined maxsize default. this case, will return True. put(item) adds element queue; queue full, wait until space available. put_nowait(item) adds element into queue without delaying. qsize() returns size queue. Let's understand following example queue module. Example Implementing stack using queue module from queue import LifoQueue Initializing my_stack stack with maxsize my_stack LifoQueue(maxsize qsize() display number elements my_stack print(my_stack.qsize()) put() function used push element my_stack my_stack.put('x') my_stack.put('y') my_stack.put('z') print("Stack Full: my_stack.full()) print("Size Stack: my_stack.qsize()) element used get() function from my_stack LIFO order print('\nElements poped from my_stack') print(my_stack.get()) print(my_stack.get()) print(my_stack.get()) print("\nStack Empty: my_stack.empty()) Output: Stack Full: False Size Stack: Elements poped from my_stack Stack Empty: True Explanation above, have imported queue module that LIFOqueue. works same stack this module includes some additional functions mentioned above. defined stack with maxsize that means hold maximum five values initial array size zero; pushed three elements stack using put() method. Now, again checked whether stack empty size stack. have three elements stack. popped element using get() method. removes last added element first. After removing entire elements, empty stack. Python Stacks Threading also Python stack multi-threaded program. advanced topic frequently used skip this section interested threading. list deque behave differently using threading program. Using list multi-threading programming dangerous because thread-safe. other hand, deque little complex because append() pop() methods atomic, which means they will interrupt other thread. build multithreading program using deque, cause complexities future. question arises, build program Python stack with threading. answer that LIFOqueue know that what LIFO stands Last First Out. uses put() gets() remove stack element. Which Implementation Stack Should Consider? have mentioned three methods implement stack Python. above methods have their advantages disadvantages. cleat confusion; using stack with threading, should Lifoqueue make sure about performance popping pushing elements. using threading, deque. also list implement stack list have potential memory reallocation issues. list deque same interface, deque doesn't memory allocation issues. Conclusion have defined stack implementation brief. Python stack used real-life programs. choose either implement method according requirements. have also defined Python stack with threading environment. Next TopicHeap Sort Python prev next