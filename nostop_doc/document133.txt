next prev Merge Sort Python Merge sort similar quick sort algorithm works concept divide conquer. most popular efficient sorting algorithm. best example divide conquer category algorithms. divides given list halves, calls itself halves then merges sorted halves. define merge() function used merging halves. lists divided again again into halves until only element each. Then combine pair element lists into element lists, sorting them process. sorted element pairs merged into four element lists, until sorted list. Merge Sort Concept Let's following Merge sort diagram. have divided given list halves. list couldn't divided equal parts doesn't matter all. Merge sort implement using ways top-down approach bottom-up approach. down approach above example, which Merge sort most often used. bottom-up approach provides more optimization which will define later. main part algorithm that combine sorted sublists. Let's merge sorted merge list. sorted empty First, observe first element both lists. find B's first element smaller, this sorted list move forward list. Sorted look next pair elements smaller into sorted list move forward list. Sorted Continue this process with sorted list 11}. There special cases. What both sublists have same elements such case, move either sublist element sorted list. Technically, move forward both sublist elements sorted list. have element left sublist. When sublist simply element second after other. should remember that sort element order. sort given list ascending order easily sort descending order. Implementation merge sort algorithm implemented suing top-down approach. look slightly difficult, will elaborate each step details. Here, will implement this algorithm types collections integer element's list (typically used introduce sorting) custom objects more practical realistic scenario). Sorting Array main concept algorithm divide (sub)list into halves sort them recursively. continue process until lists that have only element. Let's understand following function division merge_sort(array, left_index, right_index): left_index right_index: return middle (left_index right_index)//2 merge_sort(array, left_index, middle) merge_sort(array, middle right_index) merge(array, left_index, right_index, middle) primary focus divide list into subparts before sorting happen. need integer value operator indices. Let's understand above procedure following steps. First step create copies lists. first list contains lists from [left_index,...,middle] second from [middle+1,?,right_index]. traverse both copies list using pointer, select smaller value values them sorted list. Once element list move forward sorted list regardless. remaining elements other copy sorted array. Let's implement merge sort Python program. Python Program funtion divide lists sublists merge_sort(list1, left_index, right_index): left_index right_index: return middle (left_index right_index)//2 merge_sort(list1, left_index, middle) merge_sort(list1, middle right_index) merge(list1, left_index, right_index, middle) Defining function merge list merge(list1, left_index, right_index, middle): Creating subparts lists left_sublist list1[left_index:middle right_sublist list1[middle+1:right_index+1] Initial values variables that keep track where each list1 left_sublist_index right_sublist_index sorted_index left_index traverse both copies until element while left_sublist_index len(left_sublist) right_sublist_index len(right_sublist): left_sublist smaller element, sorted part then move forward left_sublist increasing pointer) left_sublist[left_sublist_index] right_sublist[right_sublist_index]: list1[sorted_index] left_sublist[left_sublist_index] left_sublist_index left_sublist_index Otherwise into right sublist else: list1[sorted_index] right_sublist[right_sublist_index] right_sublist_index right_sublist_index move forward sorted part sorted_index sorted_index will through remaining elements them while left_sublist_index len(left_sublist): list1[sorted_index] left_sublist[left_sublist_index] left_sublist_index left_sublist_index sorted_index sorted_index while right_sublist_index len(right_sublist): list1[sorted_index] right_sublist[right_sublist_index] right_sublist_index right_sublist_index sorted_index sorted_index list1 [44, merge_sort(list1, len(list1) print(list1) Output: Sorting Custom Objects also sort custom objects using Python class. This algorithm almost similar above need make more versatile pass comparison function. will create custom class, fields make changes below algorithm make more versatile. this using lambda functions. Let's understand following example. Python Program class Car: __init__(self, make, model, year): self.make make self.model model self.year year __str__(self): return str.format("Make: Model: Year: {}", self.make, self.model, self.year) merge(list1, comp_fun): left_copy list1[l:m r_sublist list1[m+1:r+1] left_copy_index r_sublist_index sorted_index while left_copy_index len(left_copy) r_sublist_index len(r_sublist): comp_fun instead simple comparison operator comp_fun(left_copy[left_copy_index], r_sublist[r_sublist_index]): list1[sorted_index] left_copy[left_copy_index] left_copy_index left_copy_index else: list1[sorted_index] r_sublist[r_sublist_index] r_sublist_index r_sublist_index sorted_index sorted_index while left_copy_index len(left_copy): list1[sorted_index] left_copy[left_copy_index] left_copy_index left_copy_index sorted_index sorted_index while r_sublist_index len(r_sublist): list1[sorted_index] r_sublist[r_sublist_index] r_sublist_index r_sublist_index sorted_index sorted_index merge_sort(list1, comp_fun): return r)//2 merge_sort(list1, comp_fun) merge_sort(list1, comp_fun) merge(list1, comp_fun) car1 Car("Renault", "33 Duster", 2001) car2 Car("Maruti", "Maruti Suzuki Dzire", 2015) car3 Car("Tata motor", "Jaguar", 2004) car4 Car("Cadillac", "Seville Sedan", 1995) list1 [car1, car2, car3, car4] merge_sort(list1, len(list1) lambda carA, carB: carA.year carB.year) print("Cars sorted year:") list1: print(car) print() merge_sort(list1, len(list1) lambda carA, carB: carA.make carB.make) print("Cars sorted make:") list1: print(car) Output: Cars sorted year: Make: Cadillac, Model: Seville Sedan, Year: 1995 Make: Renault, Model: Duster, Year: 2001 Make: Tata motor, Model: Jaguar, Year: 2004 Make: Maruti, Model: Maruti Suzuki Dzire, Year: 2015 Cars sorted make: Make: Cadillac, Model: Seville Sedan, Year: 1995 Make: Maruti, Model: Maruti Suzuki Dzire, Year: 2015 Make: Renualt, Model: Duster, Year: 2001 Make: Tata motor, Model: Jaguar, Year: 2004 Optimization improve performance merge sort algorithm. First let's understand difference between top-down bottom-up merge sort. bottom-up approach sorts elements adjacent lists iteratively where top-down approach breaks down lists into halves. given list [10, instead breaking down into [10], [4], [2], [12], [1], divides into sublists which already sorted: [10, [2], 12], ready sort them. Merge sort inefficient algorithm both time space smaller sublists. insertion sort more efficient algorithm than merge sort smaller sublists. Conclusion Merge sort popular efficient algorithm. more efficient algorithm large lists. doesn't depend unfortunate decisions that lead runtimes. There major demerit merge sort. uses additional memory that used store temporary copies lists before merging them. However Merge sort widely used software. performance fast produces excellent result. have discussed merge sort concept brief implement both simple integer list custom objects lambda function used comparison. Next TopicPython Matrix prev next