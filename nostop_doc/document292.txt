next prev Python Event-Driven programming this tutorial, will learn about Event-Driven programming Python module (Asyncio) that Python Event-Driven programming. Event-Driven programming Eventually, flow program depends upon events, programming which focuses events called Event-Driven programming. were only dealing with either parallel sequential models, will discuss asynchronous model. programming model following concept Event-Driven programming called Asynchronous model. working Event-Driven programming depends upon events happening program. Other than this, depends upon program's event loops that always listen incoming event program. Once event loop starts program, then only events will decide what will execute which order. Look following flow chart event loops understand working events event-driven programming: Asyncio- Python Event-Driven programming module asyncio module added into Python version 3.4, available later versions Python. Asyncio module provides very good infrastructure writing concurrent code single-threaded using coroutines program. asyncio module Python, following different concepts used while doing event-driven programming: event loop Futures Coroutines @asyncio.coroutine decorator Tasks Transports Protocols Let's learn about these different concepts used asyncio module detail understand they work while doing event-driven programming. event loop event loop functionality asyncio module used handle events happening computational program. Event loops like round while execution whole program happening, also keeps track executed incoming events. major advantages asyncio module that allows only single event loop process. asyncio module, have some methods which manage event loop code. Following such methods provided asyncio module. time() this method return current time user, according internal clock present event loop. loop get_event_loop() using this method, will event loop return according current context executing program. call_soon(CallbackFunction, ArgumentGiven) With this function, arrange that callback function will called soon possible. callback function given argument will called when control returns event loop after call_soon() returns. call_later(time_to_delayed, CallbackFunction, ArgumentGiven) Using this method, arrange that callback function given method will called after time delay seconds) provided. new_event_loop() Using this method, create return event loop project. set_event_loop() With help this method, event loop current context executing from program loop. run_forever() using loop.run_forever() method program, loop until stop() method called. Now, will look Python program following example where will event loop method, i.e., get_event_loop() method. using this method, will print command give inside event. Example: Look following Python program with event loops Importing asyncio module program import asyncio default function with event loops method loopText(loop): text printing command print('Printing this text through event loop') loop.stop() Stopping loop loop asyncio.get_event_loop() Using get_event_loop() method print text loop.call_soon(loopText, loop) Using call_soon() method from event loops loop.run_forever() run_forever() event loop loop.close() Closing loop Output Printing this text through event loop Explanation: have first imported asyncio module program event loops methods. After that, have defined default function where gave 'loop' parameter print command inside function. used stop() method from event loops stop event. After that, used get_event_loop() method loop parameter print text from default function. Then, call_soon() event loop method, used function name parameter function arguments. last, used run_forever() close() event loops methods. Futures Future classes given asyncio module compatible with concurrent.futures methods. future class given asyncio module represents computation from program, which accomplished. There some major differences between concurrent.futures.Future asyncio.futures. callback function that have registered future class with add_done_callback() method will always called only through call_soon() method from event loop. exception() result() methods from future class will take timeout time given argument, they will show error output when future isn't done these functions. cannot asyncio.futures.Future class with as_completed() wait() functions present concurrent.futures package compatible with them. Now, will look Python program following example, where will future class methods from asyncio module print text output. Example: Importing asyncio module program import asyncio default function from async module using future parameter async myFunction(future): await asyncio.sleep(2) Using sleep() function asyncio module future.set_result('This text printed using future class methods!') Printing text from future parameter Using get_event_loop() method from event loop loop asyncio.get_event_loop() future asyncio.Future() Using future() class method Calling default function from future class method asyncio.ensure_future(myFunction(future)) Using finally method future parameter function try: loop.run_until_complete(future) print(future.result()) printing result from future class finally: loop.close() finally closing loop Output This text printed using future class methods! Explanation: have first defined default function, i.e., 'myFunction', with future parameter. Inside function, used sleep() method two-second pause execution. Then, gave text which want print result using future class methods. used get_event_loop method from event loop program. Then, used future() class method future parameter given default function. Now, print text output have used future print text output, have used finish method, wherein method, have called printing command, finish method, closed loop using close() method. Coroutines concept coroutines inside asyncio module very similar concept coroutine thread object from threading module. This concept coroutines asyncio module generalization form subroutine concept. even suspend coroutine during program's execution that suspended coroutine will wait external processing given user. suspended coroutine will return where last suspended only after external processing done completely. asyncio module coroutines, following ways that will help implement coroutines program: @asyncio.coroutine decorator async function() Let's understand both ways using their implementation Python program. @asyncio.coroutine decorator implement coroutines inside program utilizing generators with asyncio module decorator, i.e., @asyncio.coroutine decorator. understand this implementation coroutine with decorator through following example. Example: Look following Python program: Importing asyncio module program import asyncio Using @asyncio.coroutine decorator implement coroutines @asyncio.coroutine Using default function with coroutine implementation operationCoroutine(): print("This text present inside coroutine asyncio module!") Printing text inside coroutine loop asyncio.get_event_loop() Using get_event_loop() method print text try: loop.run_until_complete(operationCoroutine()) Using run_until_complete() loop method default function finally: loop.close() closing loop Output This text present inside coroutine asyncio module! Explanation: have used @asyncio.coroutine decorator after importing asyncio module. Then, used default function coroutine method text. After that, used get_event_loop() method from event loop print text output. Last, used 'try finally' method default function closed loop program using close() function. async function() that async function() most generalized method implementing coroutines asyncio module. understand this method implementing coroutines with function() through following example. Example: Look following Python program: Importing asyncio module program import asyncio Using async function() implement coroutines async operationCoroutine(): print("This text present inside coroutine asyncio module!") Printing text inside coroutine loop asyncio.get_event_loop() Using get_event_loop() method print text try: loop.run_until_complete(operationCoroutine()) Using run_until_complete() loop method default function finally: loop.close() closing loop Output This text present inside coroutine asyncio module! Explanation: Like first implementing coroutines, have followed same path this method too. this method, instead using decorator then defining default function coroutines, have directly used async operationCoroutine() function asyncio module implement coroutines. Tasks Tasks subclass given asyncio module responsible executing asyncio coroutines inside event loop parallel manner execution. understand working tasks subclass using Python program execute coroutines with Example Importing asyncio module program import asyncio Importing time module import time Using async default function() async Task_ex(n): time.sleep(2) sleep() function time module print("Loop event processing coroutine {}".format(n)) given printing tasks print output Generating tasks with async default function async Generator_task(): looping over tasks using loop range(10): asyncio.ensure_future(Task_ex(i)) After completing loop print("All given tasks completed") asyncio.sleep(2) loop asyncio.get_event_loop() printing output using event loop method loop.run_until_complete(Generator_task()) Running loop loop.close() Closing loop Output Loop event processing coroutine Loop event processing coroutine Loop event processing coroutine Loop event processing coroutine Loop event processing coroutine Loop event processing coroutine Loop event processing coroutine Loop event processing coroutine Loop event processing coroutine Loop event processing coroutine given tasks completed Explanation: have imported asyncio time modules program functions. Then, used async default function task printing processed coroutines. used sleep() function time module give break seconds after printing every executed coroutine. Then, used another async default function loop over tasks After completing loops, function will print 'task completed.' last, used event loop method running closing loop program. Transports Transports classes provided asyncio module, them implement various types communication program. transport classes thread-safe, always have pair them with protocol instance after communication channel established. asyncio transport class, following types transports inherited program from base transport class: Datagram transport: Datagram transport interface that sending data. Read Transport: Read transport interface transport classes with only read-only mode. Write Transport: This transport interface inherited transport classes with only write-only mode. Base Subprocess transport: base Subprocess transport class functions very similarly base transport class. above-mentioned inherited transport classes, only following distinct types methods subsequently transient from base transport class: is_closing(): This method will return true only given transport class argument already closed closing now. close(): This method used close current transport class running program. get_protocol(): get_protocol() method transport class current protocol return. get_extra_info(className, default none): this method some additional information about transport class gave argument. Protocols asyncio module, provided with several base classes which implement network protocols subclasses. such classes conjunction with transport classes. protocol will outgoing data parses incoming data, whereas transport class responsible buffering actual I/O. Following three classes protocols: Protocol class: base class protocols, implementing streaming protocols with transports. Datagram protocol class: another base class protocols that implementing datagram protocols with transports. Subprocess protocol class: this base class from protocols implement various protocols communicating child processes using unidirectional pipes. Next TopicPython Semaphore prev next