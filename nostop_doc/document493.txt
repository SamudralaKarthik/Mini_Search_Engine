next prev Traffic Flow Simulation Python know that traffic does always flow smoothly; however, cars flawlessly crossing intersections, turning, stopping traffic signals look splendid. This observation thinking significant traffic flow human civilization. following tutorial, will understand importance traffic simulation. will also compare various methods possible model traffic and, last, demonstrate simulation with source code. Understanding importance traffic flow simulation explanation behind traffic simulation producing data without real world. Instead testing ideas managing traffic systems real world collecting data with help sensors, utilize model executed software predict traffic flow. This model supports accelerating optimization data gathering traffic systems. Simulation much cheaper faster alternative real-world testing. Training Machine Learning (ML) models needs huge datasets that complicated expensive gather process. Producing data procedurally simulating traffic flow easily modified precise time data required. Modeling will start modeling traffic system analyse optimize traffic system mathematical order. Such model should realistically depict flow traffic basis input parameters (road network geometry, vehicles minute, vehicle speed, many more). Traffic system models usually classified into three categories, depending level they operating Microscopic Models: These models represent every vehicle separately attempt replicate driver behaviour. Macroscopic Models: These models describe movement vehicles terms traffic density (vehicle kilometre) traffic flow (vehicles minute). They generally analogous fluid flow. Mesoscopic Models: These models hybrid models that bring together features both microscopic macroscopic models. They develop flow "packets" vehicles. following tutorial, will microscopic model. Understanding Microscopic Models microscopic driver model describes behaviour single driver/vehicle. result, must multi-agent system; that every vehicle operates independently with help input from environment. Every vehicle microscopic models numbered i-th vehicle follows (i-1)-th vehicle. will denote position i-th vehicle along road xi, speed length li. this true every vehicle. will denote bumper-to-bumper distance velocity difference between i-th vehicle vehicle front (vehicle number i-1) ∆vi. Understanding Intelligent Driver Model (IDM) 2000, Treiber, Hennecke et Helbing developed model called Intelligent Driver Model. This model illustrates acceleration i-th vehicle function variable those vehicle front define dynamics equation shown below: Since have already seen si, ∆vi, other parameters follows: s₀ᵢ: This parameter minimum desired distance between vehicle i-1. v₀ᵢ: This parameter maximum desired speed vehicle δ: This parameter acceleration exponent, controls "smoothness" acceleration. Tᵢ: This parameter reaction time i-th vehicle's driver. aᵢ: This parameter maximum acceleration vehicle bᵢ: This parameter comfortable deceleration vehicle s^*: This parameter desired distance between vehicle i-1. First, will look s^*, which distance comprised three terms. s₀ᵢ: This parameter, said before, minimum desired distance. vᵢTᵢ: This parameter reaction time safety distance. distance vehicle travels before driver reacts (brakes). Since speed distance over time, distance speed times time. (vᵢ Δvᵢ)/√(2aᵢ bᵢ): This parameter more complicated term. speed-difference-based safety distance. signifies distance will take vehicle slow down (without hitting vehicle front), without breaking much (the deceleration should less than bᵢ). Understanding working Intelligent Driver Model assume vehicles moving along straight path obey following equation: order better knowledge above equation, divide terms two. have free road acceleration interaction acceleration. free road acceleration acceleration free road: empty road with vehicles ahead. case plot acceleration function speed will following result: Image: Acceleration function speed above graph, notice that acceleration maximal when vehicle stationary When speed vehicle approaches maximum speed v01, acceleration turns zero. This statement implies that acceleration free road will accelerate vehicle maximum speed. case need plot v-a diagram from various values δ, will notice that controls quickly driver decelerates when approaching maximum speed, which turn regulates smoothness acceleration/deceleration. Image: Acceleration function speed interaction acceleration connected interaction with vehicle front. understand working better considering following situations: free road s^*): When vehicle front away, distance dominates desired distance s*, interaction almost This indicates that govern vehicle free road acceleration. high approach rates (∆vi): When difference between speed high, interaction acceleration attempts compensate that braking slowing down with help (vi<vi)^2 term numerator; however, hard. achieve this through denominator 4bi si^2. small distance difference (?? ∆?? acceleration turns into simple repulsive force. Understanding Traffic Road Network Model Image: Example directed graph Set: have model network roads. perform with help directed graph (V,E), where: considered vertices nodes). considered edges that exemplify roads. Every vehicle about have path comprised multiple roads (edges). will apply Intelligent Driver Model vehicles same road (same edge). When vehicle gets road, remove from that road following road. won't keeping (array) nodes simulation. However, every road about defined values start nodes explicit way. Understanding Stochastic Vehicle Generator have options include vehicles simulation: First Option: every vehicle manual manner simulation creating instance Vehicle class including list vehicles. Second Option: also stochastic vehicle pre-defined probabilities. order with second option, need define stochastic vehicle generator. define stochastic vehicle generator constraints: Vehicle generation rate (τ): (in-vehicle minute) This constraint describes number vehicles that should added simulation, average, minute. Vehicle configuration list (L): This constraint list tuples consisting configuration probability vehicles. stochastic vehicle generator generates vehicle Vi with probability Understanding Traffic Light Traffic lights placed vertices characterized zones: Slow down zone: slow down distance factor characterize this zone. slow down zone zone where vehicles will slow down their maximum speed with help slow down factor. Stop zone: stop distance characterizes this zone. stop zone achieved with help damping force through following dynamic equation: Project Code Traffic Flow Simulation this project, will adopt object-oriented approach. Thus, every road vehicle must defined class. will utilize following initializing function frequently various upcoming classes. This function will allow default configuration present class through function set_default_config. also expects dictionary sets every property dictionary property instance present class. this manner, there need worry about updating __init__ functions different classes about alterations future. consider following snippet code that illustrates same: File: init.py __init__(self, config {}): Setting default configuration self.set_default_config() Updating configuration attr, config.items(): setattr(self, attr, val) Explanation: above snippet code, have defined __init__() function that accepts dictionary config. Within this function, have used set_default_config() function order default configuration. have then used for-loop iterate through attributes values present config dictionary used setattr() function update configuration different classes. Road will create Road class. consider following snippet code demonstrating same: File: road.py importing distance function from scipy package from scipy.spatial import distance defining Road class class Road: __init__(self, start, end): self.start start self.end self.initProperties() initProperties(self): self.length distance.euclidean(self.start, self.end) self.angleSin (self.end[1] self.start[1]) self.length self.angleCos (self.end[0] self.start[0]) self.length Explanation: above snippet code, have imported distance function from SciPy package defined class Road. have initialized some parameters self, start, within this class using __init__() function. have then defined another function initProperties() that calculates left length road sine cosine angle order draw screen. Simulation will create Simulation class some methods include roads simulation. consider following snippet code demonstrating same: File: simulator.py importing Road class from .road import Road defining Simulator class class Simulator: __init__(self, config {}): Setting default configuration self.set_default_config() Updating configuration attr, config.items(): setattr(self, attr, val) set_default_config(self): Time keeping self.t Frame count keeping self.frame_count Simulation time step self.dt 1/60 Array store roads self.roads createRoad(self, start, end): the_road Road(start, end) self.roads.append(the_road) return the_road createRoads(self, roadList): the_road roadList: self.createRoad(*the_road) Explanation: have imported Road class from road.py file above snippet code. have then defined class Simulation. have used initializing function that defined earlier within this class. have then defined another function set_default_config() some values attributes default settings. have then defined function createRoad() createRoads() order create multiple roads. Window will display Simulation screen real-time. order perform this, will utilize pygame library create Window class that accepts Simulation class argument. will define different drawing functions that support drawing basic shapes. loop method creates pygame window calls every frame draw method loop argument. This will become helpful when Simulation requires updated every frame. consider following snippet code demonstrating same: File: window.py import pygame from pygame import gfxdraw import numpy class Window: __init__(self, simulate, config {}): Simulation draw self.simulate simulate Setting default configurations self.set_default_config() Updating configurations attr, config.items(): setattr(self, attr, val) set_default_config(self): """Setting default configuration""" self.the_width 1400 self.the_height 1000 self.the_bgColor (250, 250, 250) self.the_fps self.the_zoom self.the_offset self.mouseLast self.mouseDown False loop(self, loop None): """Showing window visualizing simulation runs loop function.""" Creating pygame window self.screen pygame.display.set_mode((self.the_width, self.the_height)) pygame.display.flip() Fixed clock pygame.time.Clock() draw text pygame.font.init() self.text_font pygame.font.SysFont('Lucida Console', Drawing loop running True while self.simulate.stop_condition(self.simulate) running: Updating simulation loop: loop(self.simulate) Drawing simulation self.draw() Updating window pygame.display.update() clock.tick(self.the_fps) Handling events event pygame.event.get(): Handling mouse drag wheel events convert(self, None): """Converting simulation coordinates screen coordinates""" inverseConvert(self, None): """Converting screen coordinates simulation coordinates""" the_background(self, """Filling screen with color.""" the_line(self, start_pos, end_pos, color): """Drawing line.""" the_rect(self, pos, size, color): """Drawing rectangle.""" the_box(self, pos, size, color): """Drawing rectangle.""" the_circle(self, pos, radius, color, filled True): """Drawing circle""" the_polygon(self, vertices, color, filled True): """Drawing polygon""" the_rotated_box(self, pos, size, angle None, None, None, centered True, color 255), filled True): """Drawing filled rectangle centered *pos* with size *size* rotated anti-clockwise *angle*.""" the_rotated_rect(self, pos, size, angle None, None, None, centered True, color 255)): """Drawing rectangle centered *pos* with size *size* rotated anti-clockwise *angle*.""" drawAxes(self, color (100, 100, 100)): """Drawing axis""" drawGrid(self, unit color (150, 150, 150)): """Drawing grid""" drawRoads(self): """Drawing every road""" drawStatus(self): """Drawing status text""" draw(self): Filling background self.the_background(*self.the_bgColor) Major minor grid axes self.drawGrid(10, (220, 220, 220)) self.drawGrid(100, (200, 200, 200)) self.drawAxes() Drawing roads self.drawRoads() Drawing status info self.drawStatus() Explanation: above snippet code, have imported pygame library. have then created class Window. have initialized some parameters within this class default configurations. have then defined loop function that displays window visualizing simulation executes loop function. have then defined different functions like convert, inverseConvert, the_background, the_line, the_rect, the_box, the_circle, the_polygon, the_rotated_box, the_rotated_rect, drawAxes, drawGrid, drawRoads, drawStatus, draw. have saved above files folder named trafficFlowSimulator. will create another python file __init__.py import classes from above files. File: __init__.py from .road import from .simulator import from .window import Explanation: above snippet code, have imported classes from python files have created earlier. test code output. File: testCase1.py from trafficFlowSimulator import Creating simulation firstSimulation Simulator() Adding road firstSimulation.createRoad((300, 97), 97)) Adding multiple roads firstSimulation.createRoads([ ((300, 97), 97)), ((0, 101), (300, 101)), ((180, 61), 61)), ((220, 56), (180, 61)), ((300, 31), (220, 56)), ((180, 61), (160, 97)), ((158, 131), (300, 131)), ((0, 179), (300, 179)), ((300, 181), 181)), ((160, 101), (156, 180)) Starting simulation firstWindow Window(firstSimulation) firstWindow.loop() Output: Explanation: above snippet code, have imported classes from trafficFlowSimulator. have then created object Simulator() class. have then added road using createRoad() function that created earlier. have then added multiple roads using createRoads() function. last, have started simulation creating object Window() class using loop() function. Vehicles Now, will vehicles roads. will using Taylor series order approximate solution dynamic equations that have discussed earlier modeling section this tutorial. Taylor series expansion infinitely differential function will substitute ∆x, will get: will replace position precision, will stop order position acceleration highest-order derivative. equation (2): Equation speed, will substitute v: will stop order highest-order derivative have acceleration (order speed). Equation (2): Equation every iteration frame), once calculate acceleration with help formula, will update position speed using these equations: Equation Equation consider following snippet code demonstrating same: File: numericalApprx.py defining formula self.a self.v self.a self.x self.v self.a Explanation: Since above snippet code only approximation, speed sometimes become negative (however, model does permit that). instability arises when speed negative, position speed diverge into negative infinity. overcome this problem predicting negative speed setting equal zero, working from there: consider following snippet code demonstrating same: File: negativeSpeed.py self.v self.a self.x self.v self.v self.a self.v else: self.v self.a self.x self.v self.a Explanation: above snippet code, have used if-else conditional statement check speed negative. order calculate acceleration, will denote lead vehicle leadVehicle calculate interaction term (denoted alpha) when leadVehicle None. consider following snippet code demonstrating same: File: leadVehicle.py alpha leadVehicle: del_x leadVehicle.x self.x leadVehicle.l del_v self.v lead.v alpha (self.s0 max(0, self.T self.v del_v self.v self.sqrt_ab)) del_x self.a self.a_max (self.v self.v_max)**4 alpha**2) Explanation: above snippet code, have initialized value alpha zero. have then used conditional statement calculate del_x del_v alpha value. case vehicle stopped (for example, traffic light), will utilize damping equation. After then, will combine everything update method within Vehicle class. consider following snippet code demonstrating same: File: vehicle.py import numpy class Vehicle: __init__(self, config {}): Setting default configuration self.set_default_config() Updating configuration attr, config.items(): setattr(self, attr, val) Calculate properties self.initProperties() set_default_config(self): self.l self.s_0 self.T self.vMax 16.6 self.aMax 1.44 self.bMax 4.61 self.path self.currentRoadIndex self.x self.v self.vMax self.a self.stopped False initProperties(self): self.sqrt_ab np.sqrt(self.aMax self.bMax) self._vMax self.vMax update(self, leadVehicle, dt): Updating position velocity self.v self.a self.x 1/2 self.v self.v self.a self.v else: self.v self.a self.x self.v self.a dt/2 Updating acceleration alpha leadVehicle: del_x leadVehicle.x self.x leadVehicle.l del_v self.v leadVehicle.v alpha (self.s_0 max(0, self.T self.v del_v self.v self.sqrt_ab)) del_x self.a self.aMax (self.v self.vMax) alpha self.stopped: self.a self.bMax self.v self.vMax stopVehicle(self): self.stopped True unstopVehicle(self): self.stopped False slowVehicle(self, self.vMax fastVehicle(self): self.vMax self._vMax Explanation: above snippet code, have imported required module defined class Vehicle. have used __init__() function default configurations within this class. have then defined initProperty() function along with update() function that updates position, velocity, acceleration. have also defined functions stop, unstop, slow down increase velocity vehicle. Road class, will include deque (also known double-ended queue) order keep track vehicles. data structure like queue better storing vehicles first Vehicle queue farthest down road first that remove from queue. remove first data element from deque using self.vehicles.popleft(). will include update method Road class. consider following snippet code understand same: File: road.py update(self, dt): len(self.vehicles) Updating first vehicle self.vehicles[0].update(None, Updating other vehicles range(1, num): lead self.vehicles[i self.vehicles[i].update(lead, Explanation: above snippet code, have defined function update Road class. Within this function, have assigned length vehicles deque variable used condition check greater than zero update first vehicle. have then used for-loop ranging from updated rest vehicles deque. update method Simulation class well. Here following snippet code demonstrating same: File: simulation.py update(self): Updating every road road self.roads: road.update(self.dt) Checking roads bounds vehicle road self.roads: road does have vehicles, then continue len(road.vehicles) continue vehicle road.vehicles[0] first vehicle road bounds vehicle.x road.length: vehicle next road vehicle.currentRoadIndex len(vehicle.path): Updating current road next road vehicle.currentRoadIndex Creating copy reseting some vehicle properties newVehicle deepcopy(vehicle) newVehicle.x Adding next road nextRoadIndex vehicle.path[vehicle.currentRoadIndex] self.roads[nextRoadIndex].vehicles.append(newVehicle) cases, removing from road road.vehicles.popleft() Explanation: above snippet code, have defined update() function Simulation class. Within this function, have updated every road. have then checked roads out-of-bounds vehicles performed operations accordingly. Now, let's back Window class method order update simulation real-time: File: window.py run(self, stepsPerUpdate """Running simulation updating every loop.""" loop(sim): sim.run(stepsPerUpdate) self.loop(loop) Explanation: above snippet code, have defined method that updates simulation every loop. now, will include vehicles manually: File: testCase2.py firstSimulation.roads[4].vehicles.append( Vehicle({ "path" firstSimulation.roads[0].vehicles.append(Vehicle()) firstSimulation.roads[1].vehicles.append(Vehicle()) firstSimulation.roads[6].vehicles.append(Vehicle()) firstSimulation.roads[7].vehicles.append(Vehicle()) Output: Explanation: above snippet code, manually added vehicles roads created earlier. have used append() function insert vehicles different roads. Vehicle Generators File: vehicleGenerator.py from .vehicle import Vehicle from numpy.random import randint class VehicleGenerators: __init__(self, sim, config {}): set_default_config(self): self.vehicleRate self.vehicles initProperties(self): self.upcomingVehicle self.generateVehicle() generateVehicle(self): """Returning random vehicle from self.vehicles with random proportions""" update(self): """Adding vehicles""" Explanation: above snippet code, have imported Vehicle class from vehicle.py file randint function from numpy library. have then created class VehicleGenerators defined __init__ function setting default configuration initProperties. have then included functions like generateVehicle update return random vehicle from self.vehicles with random proportions vehicles. VehicleGenerators class array tuples (odds, vehicle). first data element tuple weight (not probability) vehicle generation same tuple. have used weights they convenient work with since utilize integers. instance, have three vehicles with weights This corresponds 3/6, 1/6, 2/6 with (= utilize following algorithm order implement this: Generating number between weights. While non-negative Looping through possible vehicles subtracting their weight each iteration. Returning last utilized vehicle. Suppose that have weights W1, W2, W3. following algorithm will allow allocate numbers between first vehicle, numbers between second vehicle, numbers between W3 third vehicle. File: vehicleGenerator.py generateVehicle(self): """Returning random vehicle from self.vehicles with random proportions""" total sum(pair[0] pair self.vehicles) randint(1, total (weight, config) self.vehicles: weight return Vehicle(config) Explanation: above snippet code, have defined function generateVehicle(). have calculated pair self.vehicles within this function returned random vehicle with random proportions. have included property known lastAddedTime that whenever vehicle, current time will updated every time generator performs function. When time duration between current time lastAddedTime greater than period vehicle generation, vehicle included. period adding vehicles 60/vehicleRate because vehicleRate vehicles minute, minute seconds. will also check road space upcoming vehicle. perform this operation checking distance between last vehicle road length safety distance upcoming vehicle. consider following snippet code demonstrating same: File: vehicleGenerator.py update(self): """Adding vehicles""" self.simulation.t self.lastAddedTime self.vehicleRate: time elapsed after last added vehicle greater than vehicle period; then generate vehicle road self.simulation.roads[self.upcomingVehicle.path[0]] len(road.vehicles) 0\ road.vehicles[-1].x self.upcomingVehicle.s_0 self.upcomingVehicle.l: there space generated vehicle; then self.upcomingVehicle.timeAdded self.simulation.t road.vehicles.append(self.upcomingVehicle) Resetting lastAddedTime upcomingVehicle self.lastAddedTime self.simulation.t self.upcomingVehicle self.generateVehicle() Explanation: above snippet code, have defined update() function order vehicles simulation. have used conditional statement check whether time elapsed after addition last vehicle greater than vehicle period generating vehicle same. have also checked space present generated vehicle added last, have reset time last addition upcoming vehicle. Finally, should update vehicle generators calling update method from Simulation class. consider following snippet code understand same: File: testCase3.py firstSimulation.createGen({ 'vehicleRate' 'vehicles' {"path" 1]}], {"path" [4]}], {"path" [5]}], {"path" [6]}], {"path" [7]}] Output: Explanation: above snippet code, have initialized createGen function Simulation class provided required values parameters like vehicleRate vehicles. have also specified paths vehicles executed program. Traffic Lights traffic light properties simulation. default properties traffic signal follows: File: trafficLight.py class TrafficSignal: __init__(self, roads, config {}): Initializing roads self.roads roads Setting default configuration self.set_default_config() Updating configuration attr, config.items(): setattr(self, attr, val) Calculating properties self.initProperties() set_default_config(self): self.cycle [(False, True), (True, False)] self.slowDistance self.slowFactor self.stopDistance self.currentCycleIndex self.last_t Explanation: above snippet code, have defined class TrafficSignal. have used __init__() function initialize some variables functions within this class. have then defined another function default configuration. self.cycle variable array tuples consisting states (for example, True symbolizes green False symbolizes red) every road self.roads. default configuration, data element (False, True) indicates first roads read second green (True, False) opposite. will this approach easily scalable. create traffic lights involving more than roads, traffic lights with distinct signals right left turns, even synchronized traffic signals across different intersections. update function traffic signal will customizable. default behaviour this function will symmetric fixed-time cycling. File: trafficLight.py initProperties(self): range(len(self.roads)): the_road self.roads[i]: the_road.setTrafficSignal(self, @property currentCycle(self): return self.cycle[self.currentCycleIndex] update(self, simulation): Going through cycles every cycleLength repeats cycleLength (simulation.t cycleLength) self.currentCycleIndex int(m) Explanation: above snippet code, have defined initProperties() function. have then used for-loop iterating through each road array setting signals within this function. have then defined function return current cycle index. have then defined update function where have gone through cycles repeat. will include following methods Road class. File: road.py setTrafficSignal(self, signal, group): self.trafficSignal signal self.trafficSignalGroup group self.hasTrafficSignal True @property trafficSignalState(self): self.hasTrafficSignal: self.trafficSignalGroup return self.trafficSignal.currentCycle[i] return True Explanation: above snippet code, have defined functions Traffic signal state each cycle. will following snippet code update function Road class. File: road.py Checking traffic signal self.trafficSignalState: case traffic signal green does exist Then vehicles pass self.vehicles[0].unstopVehicle() the_vehicle self.vehicles: the_vehicle.fastVehicle() else: case traffic signal self.vehicles[0].x self.length self.trafficSignal.slowDistance: Slowing vehicles down slowing zone self.vehicles[0].slowVehicle(self.trafficSignal.slowSpeed) self.vehicles[0].x self.length self.trafficSignal.stopDistance and\ self.vehicles[0].x self.length self.trafficSignal.stopDistance Stopping vehicles stop zone self.vehicles[0].stopVehicle() Explanation: above snippet code, have checked traffic signal perform specific tasks specific signal. will check state traffic light update method Simulation class: File: simulator.py signal self.trafficSignals: signal.update(self) Explanation: above snippet code, used for-loop iterate through each signal trafficSignals array update them. Here output same: Output: Curves roads real world have curves. Since can, technically, create curves this traffic flow simulation hand-writing coordinates roads estimate curve, perform same thing procedural way. will using Bezier curves this. will create curve.py file consisting functions helping creating curves referencing them their road indices. consider following snippet code demonstrating same: File: curve.py curvePoints(begin, end, ctrl, curve straight line (begin[0] end[0]) (begin[1] end[1]) return [begin, end] return curve path range(res p)**2 begin[0] 2*(1 p)*p ctrl[0] p**2 *end[0] p)**2 begin[1] 2*(1 p)*p ctrl[1] p**2 *end[1] path.append((a, return path curveRoad(begin, end, turnDirection, 15): pts curvePoints(begin, end, turnDirection, res) return [(pts[i pts[i]) range(1, len(pts))] Explanation: above snippet code, have defined function curvePoints(). have then checked curve straight line performed operations accordingly. have then defined another function curveRoad() that returns curved path. test above code better illustration. File: testCase3.py from trafficFlowSimulation import Creating simulation firstSimulation Simulator() Adding multiple roads firstSimulation.createRoads([ ((0, 105), (145, 105)), ((155, 115), (155, 205)), *curveRoad((145, 105), (155, 115), (155, 105)) firstSimulation.create_gen({ 'vehicleRate' 'vehicles' {"path" *range(2, 17), 1]}] Starting simulation Window(firstSimulation) win.run(steps_per_update Explanation: above snippet code, have imported folder containing classes created earlier. have then created instance Simulator() class. have then added multiple roads. have also included curveRoad() function create curve road. have then added vehicles simulation executed program. Output: Limitations While modify Simulation class store data related simulation that utilize later, would better gathering data more streamlined. This simulation still lacking lot. curves implementation inefficient causes issues with interaction between vehicles traffic signals. While some concerned about Intelligent Driver Model overkill, significant have model that replicate real-world phenomena such traffic waves (also known ghost traffic snakes) effects driver reaction time. same reason, opted utilize Intelligent Driver Model. However, order create simulation where precision extreme realism significant, like video games, substitute with simpler logic-based model. Depending completely simulation-based data increases risk over-fitting. model could optimizing treats available simulation absent real world. Conclusion Simulation significant segments data science machine learning. Sometimes, collecting data from real world either possible costly. data generation supports building huge datasets somewhat better price. Simulation also support filling gaps real-world data. occasions, real-world datasets lack edge cases that critical developed model. Next TopicHow Merge Sort Lists Python prev next