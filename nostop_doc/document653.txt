next prev Puzzle problem Python puzzle problem solution covered this article. board with tiles (each tile number from single empty space provided. goal vacant space arrange numbers tiles such that they match final arrangement. Four neighbouring (left, right, above, below) tiles moved into available area. instance, (Brute Force) state-space tree (Set configurations particular issue, i.e., states that reached from beginning state), depth-first search. Figure Puzzle's State Space Tree this solution, further movements might always send closer objective, rather further away. Regardless initial state, state-space tree searches down leftmost route from root. With this method, answer node might never discovered. (Brute Force) search state space tree using breadth-first approach. always locates goal state that closest root. However, algorithm tries same series movements regardless initial state. Branch Bound avoiding searching sub-trees which include answer node, "intelligent" ranking function, also known approximatsion costs function, frequently speed search answer node. However, instead using backtracking method, does BFS-style search. Basically, Branch Bound involves three different kinds nodes. live node created node whose children have been formed. offspring E-node which live node, being investigated. another way, E-node node that currently expanding. created node which developed examined further referred dead node. dead node already extended offspring. Costs function search tree, each node corresponding costs. next E-node found using costs function. E-node with lowest costs next one. function defined C(Y) g(Y) h(Y) where g(Y) costs reaching current node from root. h(Y) costs reaching answer node from optimum costs function algorithm puzzles suppose that will costs unit move tile direction. light this, create following costs function 8-puzzle algorithm c(y) f(y) h(y) where f(y) path's total length from root h(y) amount non-blank tiles which their final goal position (misplaced tiles). change state into desired state, there least h(y) movements required. There algorithm estimatsing unknown value h(y), which accessible. Final algorithm order maintain list live nodes, algorithm LCSearch employs functions Least() Add(). Least() identifies live node with least c(y), removes from list, returns Add(y) adds list live nodes. Add(y) implements list live nodes min-heap. route taken aforementioned algorithm arrive final configuration 8-Puzzle from starting configuration supplied shown diagram below. Keep mind that only nodes with lowest costs function value extended. Code Python code display from root node final destination node N*N-1 puzzle algorithm help Branch Bound technique answer assumes that instance puzzle solved Importing 'copy' deepcopy method import copy Importing heap methods from python library Priority Queue from heapq import heappush, heappop This particular changed transform program from puzzle(n=3) into puzzle(n=4) bottom, left, top, right rows cols creating class Priority Queue class priorityQueue: Constructor initializing Priority Queue 	def __init__(self): 		self.heap Inserting 'key' 	def push(self, key): 		heappush(self.heap, key) funct remove element that minimum, from Priority Queue 	def pop(self): 		return heappop(self.heap) funct check Queue empty 	def empty(self): 		if self.heap: 			return True 		else: 			return False structure node class nodes: 	def __init__(self, parent, mats, empty_tile_posi, 				costs, levels): 					 This will store parent node current node helps tracing path when solution visible 		self.parent parent Useful Storing matrix 		self.mats mats useful Storing position where empty space tile already existing matrix 		self.empty_tile_posi empty_tile_posi Store misplaced tiles 		self.costs costs Store moves 		self.levels levels This func used order form priority queue based costs objects 	def __lt__(self, nxt): 		return self.costs nxt.costs method calc. misplaced tiles, that non-blank tiles their final posi calculateCosts(mats, final) int: 	count 	for range(n): 		for range(n): 			if ((mats[i][j]) 				(mats[i][j] final[i][j])): 				count 				 	return count newNodes(mats, empty_tile_posi, new_empty_tile_posi, 			levels, parent, final) nodes: 				 Copying data from parent matrixes present matrixes 	new_mats copy.deepcopy(mats) Moving tile position 	x1 empty_tile_posi[0] 	y1 empty_tile_posi[1] 	x2 new_empty_tile_posi[0] 	y2 new_empty_tile_posi[1] 	new_mats[x1][y1], new_mats[x2][y2] new_mats[x2][y2], new_mats[x1][y1] Setting misplaced tiles 	costs calculateCosts(new_mats, final) 	new_nodes nodes(parent, new_mats, new_empty_tile_posi, 					costs, levels) 	return new_nodes func print matrix printMatsrix(mats): 	for range(n): 		for range(n): 			print("%d (mats[i][j]), 		print() func know valid invalid matrix coordinates isSafe(x, 	return Printing path from root node final node printPath(root): root None: 		return 	printPath(root.parent) 	printMatsrix(root.mats) 	print() method solving N*N puzzle algo utilizing Branch Bound technique. empty_tile_posi blank tile position initially. solve(initial, empty_tile_posi, final): Creating priority queue storing live nodes search tree 	pq priorityQueue() Creating root node 	costs calculateCosts(initial, final) 	root nodes(None, initial, 				empty_tile_posi, costs, Adding root list live nodes 	pq.push(root) Discovering live node with min. costs, adding children list live nodes finally deleting from list. 	while pq.empty(): Finding live node with min. estimatsed costs deleting form list live nodes 		minimum pq.pop() min. node 		if minimum.costs 			# Printing path from root 			# destination; 			printPath(minimum) 			return Generating feasible children 		for range(n): 			new_tile_posi 				minimum.empty_tile_posi[0] rows[i], 				minimum.empty_tile_posi[1] cols[i], 				 			if isSafe(new_tile_posi[0], new_tile_posi[1]): 				 				# Creating child node 				child newNodes(minimum.mats, 								minimum.empty_tile_posi, 								new_tile_posi, 								minimum.levels 								minimum, final,) 				# Adding child list live nodes 				pq.push(child) Main Code Initial configuration Value taken here empty space initial 			[ 			[ Final configuration that solved Value taken empty space final Blank tile coordinates initial configuration empty_tile_posi Method call solving puzzle solve(initial, empty_tile_posi, final) Output: Next Topicaccuracy_score Sklearn prev next