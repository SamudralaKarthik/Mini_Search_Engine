next prev Windows System Administration Management using Python Managing activities Windows System Administration manually exhausting. What could Python codes instead managing these tasks manually. following tutorial, will discover such module that allows program perform different processes based System Administration. This Python module known module. WMI, abbreviated Windows Management Instrumentation, implementation Microsoft Common Information Model (short CMI) DMTF, which vendor-neutral, industry-standard method demonstrating Management Information. allows programmers query almost piece data from computer executing required agent with appropriate permissions. Python offers module that acts lightweight wrapper around available classes functionalities could utilized Systems Administrators order query data from local remote Windows machines. this tutorial, will understand module perform various activities based Windows System Administration. before begin installing required module. Install Python Module? order install Python module, need 'pip', framework manage packages required install modules from trusted public repositories. Once have 'pip', install module using command from Windows command prompt (CMD) terminal shown below: Syntax: python.exe install Verifying Installation Once module installed, verify creating empty Python program file writing import statement follows: File: verify.py import Now, save above file execute using following command terminal: Syntax: python verify.py above Python program file does return error, module installed properly. However, case where exception raised, reinstalling module, also recommended refer official documentation module. Establishing Connection following section, will begin establishing connection machine. Most time, will connect local machine with help following Python syntax: Syntax: connecting local machine my_connection wmi.WMI() Suppose want connect remote machine. that case, must provide machine name Address) following parameters such 'user' 'password' pass credentials that authenticate account establish remote connection. Example: importing required module import connecting remote machine my_connection wmi.WMI("13.78.128.231", user r"mango", password "mango@123") Finding Class have connection established; however, query specific information regarding system, must first find class that deliver that information. also 'classes' property objects such wmi.WMI().classes, order return list classes. From these extracted classes, filter particular keywords find specific class looking for, shown following example: Example: importing required module import connecting local machine my_connection wmi.WMI() extracting class names from className my_connection.classes: 'Process' className: print(className) Output: Win32_ProcessStartTrace Win32_PerfFormattedData_PerfOS_Processor Win32_PerfFormattedData_PerfProc_Process Win32_SessionProcess Win32_PerfRawData_PerfProc_Process Win32_PerfRawData_Counters_PerProcessorNetworkInterfaceCardActivity Win32_PerfRawData_LSM_UserInputDelayperProcess Win32_PerfFormattedData_Counters_ProcessV2 Win32_PerfFormattedData_LSM_UserInputDelayperProcess Win32_PerfFormattedData_Counters_PerProcessorNetworkInterfaceCardActivity Win32_Processor Win32_ProcessTrace CIM_OSProcess CIM_ProcessExecutable CIM_Processor CIM_AssociatedProcessorMemory Win32_ComputerSystemProcessor Win32_PerfFormattedData_GPUPerformanceCounters_GPUProcessMemory Win32_PerfRawData_HvStats_HyperVHypervisorLogicalProcessor Win32_PerfFormattedData_Counters_ProcessorInformation CIM_ProcessThread CIM_Process Win32_PerfFormattedData_Counters_PerProcessorNetworkActivityCycles Win32_AssociatedProcessorMemory Win32_PerfRawData_HvStats_HyperVHypervisorRootVirtualProcessor Win32_PerfFormattedData_Counters_SecurityPerProcessStatistics Win32_ProcessStartup Win32_PerfRawData_GPUPerformanceCounters_GPUProcessMemory Win32_PerfRawData_Counters_ProcessorInformation Win32_PerfRawData_Counters_ProcessV2 Win32_PerfRawData_Counters_PerProcessorNetworkActivityCycles Win32_PerfRawData_Counters_SecurityPerProcessStatistics Win32_PerfFormattedData_HvStats_HyperVHypervisorLogicalProcessor Win32_Process Win32_PerfFormattedData_HvStats_HyperVHypervisorRootVirtualProcessor Win32_NamedJobObjectProcess Win32_SystemProcesses Win32_ProcessStopTrace Win32_PerfRawData_PerfOS_Processor Explanation: above snippet code, have imported module established connection local machine. have then extracted class names from module using for-loop iterating through each class available module. Finding Methods Properties Class Even know name Class, will still need precise name property these classes provide methods that carry particular operations. order retrieve methods properties specific class, create connection utilize operator 'Class Name' order access namespace, then 'properties' 'methods' attribute return Python List property/method names. consider following example demonstrating same: Example: importing module import printing properties print("Properties class:") print(wmi.WMI().Win32_Process.methods.keys()) printing methods print("\nMethods class:") print(wmi.WMI().Win32_Process.properties.keys()) Output: Properties class: dict_keys(['Create', 'Terminate', 'GetOwner', 'GetOwnerSid', 'SetPriority', 'AttachDebugger', 'GetAvailableVirtualSize']) Methods class: dict_keys(['Caption', 'CommandLine', 'CreationClassName', 'CreationDate', 'CSCreationClassName', 'CSName', 'Description', 'ExecutablePath', 'ExecutionState', 'Handle', 'HandleCount', 'InstallDate', 'KernelModeTime', 'MaximumWorkingSetSize', 'MinimumWorkingSetSize', 'Name', 'OSCreationClassName', 'OSName', 'OtherOperationCount', 'OtherTransferCount', 'PageFaults', 'PageFileUsage', 'ParentProcessId', 'PeakPageFileUsage', 'PeakVirtualSize', 'PeakWorkingSetSize', 'Priority', 'PrivatePageCount', 'ProcessId', 'QuotaNonPagedPoolUsage', 'QuotaPagedPoolUsage', 'QuotaPeakNonPagedPoolUsage', 'QuotaPeakPagedPoolUsage', 'ReadOperationCount', 'ReadTransferCount', 'SessionId', 'Status', 'TerminationDate', 'ThreadCount', 'UserModeTime', 'VirtualSize', 'WindowsVersion', 'WorkingSetSize', 'WriteOperationCount', 'WriteTransferCount']) Explanation: above snippet code, have imported required module. have then used WMI() establish connection with remote machine. have then written name class followed operator along with keywords 'properties' 'methods' print properties methods users. Handling Process Since have gathered information regarding methods properties class 'Win32_Process', will class name followed open close parenthesis order return objects class. consider following example demonstrating same: Example: importing module import establishing connection with local machine my_connection wmi.WMI() processing list process my_connection.Win32_Process(): print("ID: {0}\nHandle Count: {1}\nProcess Name: {2}\n".format( process.ProcessId, process.HandleCount, process.Name Output: Handle Count: Process Name: System Idle Process Handle Count: 5863 Process Name: System Handle Count: Process Name: Registry Handle Count: Process Name: smss.exe 788 Handle Count: 773 Process Name: csrss.exe 892 Handle Count: Process Name: wininit.exe 912 Handle Count: Process Name: csrss.exe 964 Handle Count: 714 Process Name: services.exe 984 Handle Count: 1571 Process Name: lsass.exe 568 Handle Count: Process Name: winlogon.exe 1056 Handle Count: 1746 Process Name: svchost.exe 1084 Handle Count: Process Name: fontdrvhost.exe 14104 Handle Count: Process Name: python3.9.exe Explanation: above snippet code, have imported module established successful connection with local machine. extracted process list using for-loop iterating through each process with their Handle Count, Name process. also filter these processes with their names properties print only selected processes (es). example, wanted select processes named 'code.exe' that running locally then filtered processes that have handle count more than with help conditional statement: if<condition> consider following script understand same: Example: importing module import establishing connection with local machine my_connection wmi.WMI() filtering specific processes process my_connection.Win32_Process(name "code.exe"): process.HandleCount 100: only processes with Handle Count above print("ID: {0}\nHandle Count: {1}\nProcess Name: {2}\n".format( process.ProcessId, process.HandleCount, process.Name Output: 10464 Handle Count: 859 Process Name: Code.exe 14796 Handle Count: 228 Process Name: Code.exe 12388 Handle Count: 704 Process Name: Code.exe 2504 Handle Count: Process Name: Code.exe 1044 Handle Count: 485 Process Name: Code.exe 12668 Handle Count: 334 Process Name: Code.exe 8088 Handle Count: 362 Process Name: Code.exe 10720 Handle Count: Process Name: Code.exe 8976 Handle Count: Process Name: Code.exe 14804 Handle Count: Process Name: Code.exe Explanation: above snippet code, have again imported module established connection with local machine. have then used for-loop iterate through processes class specified name process filter that required process. have also included conditional statement order print those processes details only whose Handle Counts more than 100. Module also allows programmers begin process kill existing one. consider following example demonstrating same where have created process then stored Process uniquely identify process that terminate later using that Example: importing module import establishing connection with local machine my_connection wmi.WMI() starting process capturing process process_id, return_val my_connection.Win32_Process.Create(CommandLine "notepad.exe") killing process using process my_connection.Win32_Process(ProcessId process_id)[0].Terminate() Explanation: above snippet code, have imported module established successful connection with local machine. have then started process using Create() function stored process last, have used Terminate() function kill process. Handling Services adapt similar approach order list filter services working machine with help class called Win32_Service. consider following snippet code demonstrating same: Example: importing module import establishing connection with local machine my_connection wmi.WMI() listing services service my_connection.Win32_Service(StartMode "Auto", State "Running"): filtering service names 'Windows' service.DisplayName: print("Status: \nStart Mode: \nService Name: \nDisplay Name: \n\n".format( service.State, service.StartMode, service.Name, service.DisplayName Output: Status: Running Start Mode: Auto Service Name: AudioEndpointBuilder Display Name: Windows Audio Endpoint Builder Status: Running Start Mode: Auto Service Name: Audiosrv Display Name: Windows Audio Status: Running Start Mode: Auto Service Name: EventLog Display Name: Windows Event Status: Running Start Mode: Auto Service Name: FontCache Display Name: Windows Font Cache Service Status: Running Start Mode: Auto Service Name: mpssvc Display Name: Windows Defender Firewall Status: Running Start Mode: Auto Service Name: StiSvc Display Name: Windows Image Acquisition (WIA) Status: Running Start Mode: Auto Service Name: Wcmsvc Display Name: Windows Connection Manager Status: Running Start Mode: Auto Service Name: Winmgmt Display Name: Windows Management Instrumentation Status: Running Start Mode: Auto Service Name: WpnService Display Name: Windows Push Notifications System Service Status: Running Start Mode: Auto Service Name: WSearch Display Name: Windows Search Status: Running Start Mode: Auto Service Name: WpnUserService_a17f9 Display Name: Windows Push Notifications User Service_a17f9 Explanation: above snippet code, have imported module established connection with local machine. have then used for-loop iterate through Win32_Services class module over given conditions. have also used conditional statement filter required services. perform several other functionalities with these classes, such starting stopping service more. Next TopicIndentation Error Python prev next