next prev Python Generators What Python Generator? Python Generators functions that return traversal object used create iterators. traverses entire items once. generator also expression which syntax similar list comprehension Python. There complexity creating iteration Python; need implement __iter__() __next__() method keep track internal states. lengthy process create iterators. That's generator plays essential role simplifying this process. there value found iteration, raises StopIteration exception. Create Generator function Python? quite simple create generator Python. similar normal function defined keyword uses yield keyword instead return. that body function contains yield statement, automatically becomes generator function. Consider following example: simple(): range(10): if(i%2==0): yield #Successive Function call using loop simple(): print(i) Output: yield return yield statement responsible controlling flow generator function. pauses function execution saving states yielded caller. Later resumes execution when successive function called. multiple yield statement generator function. return statement returns value terminates whole function only return statement used function. Using multiple yield Statement multiple yield statement generator function. Consider following example. multiple_yield(): str1 "First String" yield str1 str2 "Second string" yield str2 str3 "Third String" yield str3 multiple_yield() print(next(obj)) print(next(obj)) print(next(obj)) Output: First String Second string Third String Difference between Generator function Normal function Normal function contains only Lreturn statement whereas generator function contain more yield statement. When generator functions called, normal function paused immediately control transferred caller. Local variable their states remembered between successive calls. StopIteration exception raised automatically when function terminates. Generator Expression easily create generator expression without using user-defined function. same lambda function which creates anonymous function; generator's expressions create anonymous generator function. representation generator expression similar Python list comprehension. only difference that square bracket replaced round parentheses. list comprehension calculates entire list, whereas generator expression calculates item time. Consider following example: list [1,2,3,4,5,6,7] List Comprehension [x**3 list] Generator expression (x**3 list) print(a) print(z) Output: <generator object <genexpr> 0x01BA3CD8> 125, 216, 343] above program, list comprehension returned list cube elements whereas generator expression returned reference calculated value. Instead applying loop, also call next() generator object. Let's consider another example: list [1,2,3,4,5,6] (x**3 list) print(next(z)) print(next(z)) print(next(z)) print(next(z)) Output: Note:- When call next(), Python calls __next__() function which have passed parameter. above program, have used next() function, which returned next item list. Example: Write program print table given number using generator. table(n): range(1,11): yield n*i table(15): print(i) Output: above example, generator function iterating using loop. Advantages Generators There various advantages Generators. them given below: Easy implement Generators easy implement compared iterator. iterator, have implement __iter__() __next__() function. Memory efficient Generators memory efficient large number sequences. normal function returns sequence list which creates entire sequence memory before returning result, generator function calculates value pause their execution. resumes successive call. infinite sequence generator great example memory optimization. Let's discuss below example using sys.getsizeof() function. import List comprehension nums_squared_list range(1000)] print(sys.getsizeof("Memory Bytes:"nums_squared_list)) Generator Expression nums_squared_gc range(1000)) print(sys.getsizeof("Memory Bytes:", nums_squared_gc)) Output: Memory Bytes: 4508 Memory Bytes: observe from above output that list comprehension using 4508 bytes memory, whereas generator expression using bytes memory. means that generator objects much efficient than list compression. Pipelining with Generators Data Pipeline provides facility process large datasets stream data without using extra computer memory. Suppose have file from famous restaurant. file column (4th column) that keeps track number burgers sold every hour want find total number burgers sold years. that scenario, generator generate pipeline with series operations. Below code with open('sells.log') file: burger_col (line[3] line file) per_hour (int(x) burger_col 'N/A') print("Total burgers sold ",sum(per_hour)) Generate Infinite Sequence generator produce infinite items. Infinite sequences cannot contained within memory since generators produce only item time, consider following example: infinite_sequence(): while True: yield infinite_sequence(): print(i) Output: ......... .......... 316 317 Traceback (most recent call last): File "C:\Users\DEVANSH SHARMA\Desktop\generator.py", line <module> print(i) KeyboardInterrupt this tutorial, have learned about Python Generators. Next TopicWeb Scraping Using Python prev next