next prev Flipping Tiles (Memory game) using Python Anyone test their memory playing flipping-tiles game. Each number figure pair tiles this set, which even number. must flip tiles that them because they facing down. flips tiles turn, they match, they taken out. not, they turned around back into position. Until tiles have been matched eliminated, continue this manner. Introducing game tiles grid displayed either face face down. there engage game itself. Here's reminder game operates tiles face down game begins. player then turns over cards clicks them choose tiles stay face they have same image. not, they must turned face down once more after little interval. Flipping clickable tiles currently have programme that merely draws tile grid before stopping. time goes want programme generate variety images. will initially draw face-down tiles, followed clicked tiles screen everything goes according plan player. Moving drawing code this language draw() function next logical step. While application running, computer will continue execute draw(), causing tiles continue drawn based whether they facing down. draw function() background(255, 255, 255); (var tiles.length; i++) tiles[i].draw(); let's turn those tiles face up! player must click tile order flip This language projects, write mouseClicked() function respond mouse clicks, computer will that code each time mouse clicked. process click somehow When application notices that player clicked someplace, want mouseX mouseY detect they have clicked tile. Let's begin giving Tile isUnderMouse() method that returns true given inside area tile. tile correspond upper left corner tile because we've created tiles, thus should only return true provided between this.x this.x this.size provided falls between this.y this.y this.size. Tile.prototype.isUnderMouse function(x, return this.x this.x this.size this.y this.y this.size; Since have that method now, check mouseClicked() each tile within mouseX mouseY using loop. then isFaceUp() property tile true. mouseClicked function() (var tiles.length; i++) (tiles[i].isUnderMouse(mouseX, mouseY)) tiles[i].isFaceUp true; Restricting flipping cards player's ability flip tiles over feature should've developed, however we've left crucial limitation users shouldn't capable flipping more than tiles once. number flipped tiles will need recorded some way. straightforward approach would global variable called numFlipped that increment each time player turns card face numFlipped would less than tile isn't already face only flip over numFlipped mouseClicked function() (var tiles.length; i++) tile tiles[i]; (tiles.isUnderMouse(mouseX, mouseY)) (numFlipped !tile.isFaceUp) tile.isFaceUp true; numFlipped++; Delaying tile's flipping logic behind flipping tiles finished. Next, what? Let's over guidelines once more tiles stay face they have same image. Otherwise, after while, tiles turn back around. will difficult test first portion can't simply seek fresh matches, will first develop second component, which automatically flips tiles back over. setting isFaceUp false, know reverse direction tiles, what about after some time passed? Delaying code execution takes many forms different languages environments, need figure achieve This language. order determine delay period passed, need mechanism keep track time. also need call code once delay period ended. What would advise this created delayStartFC global variable, which initially empty. After flipping over second tile mouseClicked() method, kept present value frameCount delayStartFC. tell time programmes using variable that indicates many frames have passed since programme began execute. draw() function, determine whether frameCount value much higher than previous one. tiles turned over, numFlipped Additionally, nullized delayStartFC. fact, it's wonderful solution that doesn't involve writing code. loop noLoop methods ensure that draw code only called when delay present order improve performance. Here's everything explained numFlipped delayStartFC null; mouseClicked function() (var tiles.length; i++) tile tiles[i]; (tile.isUnderMouse(mouseX, mouseY)) (numFlipped !tile.isFaceUp) tile.isFaceUp true; numFlipped++; (numFlipped delayStartFC frameCount; loop(); draw function() (delayStartFC (frameCount delayStartFC) (var tiles.length; i++) tiles[i].isFaceUp false; numFlipped delayStartFC null; noLoop(); background(255, 255, 255); (var tiles.length; i++) tiles[i].draw(); Checking matches were able match tiles above, were likely disappointed when they were turned back over because, hey, were successful! it's time this game rule into action When tiles line perfectly, they should remain face This indicates that whenever there flipped over tiles, well before user delay, should look matching tiles. Pseudo-code that would there tiles flipped over: first tile same face second tile: keep tiles face determine tiles facing same direction? already have checked this (numFlipped First, need tiles that faced locate them? Each time, could traverse over array identify tiles whose isFaceUp property true before storing those into another array. Let's take short always keep flipped tiles inside array convenience. doing this, each time player flips tile, avoid having loop through entire array tiles. first swap numFlipped array, then flippedTiles.length wherever numFlipped previously used. This mouseClicked() function looks flippedTiles delayStartFC null; mouseClicked function() (var tiles.length; i++) tile tiles[i]; (tile.isUnderMouse(mouseX, mouseY)) (flippedTiles.length !tile.isFaceUp) tile.isFaceUp true; flippedTiles.push(tile); (flippedTiles.length delayStartFC frameCount; loop(); Now, identifying whether tiles flippedTiles array indeed have same face requires further investigation. What face property, then? It's object, since variable directing same location computer memory each, face matching tiles should actually pointing exact same item. This fact that each image object only ever created once (for example, getImage("avatars/old-spice-man")), that object then twice pushed onto faces array face possibleFaces[randomInd]; selected.push(face); selected.push(face); variables that refer objects used, both those variables correspond same object memory, then equality operator, least JavaScript, will return true. result, quick check using equality operator face property each tile. (flippedTiles[0].face flippedTiles[1].face) must keep tiles that certain they match. They would currently turned over after some delay. could simply choose animation this scenario, can't rely that there will animation subsequent turns. need method able say, "Hey, when turn them back, should turn these specific ones over." That good application boolean property! Let's isMatch property Tile constructor then just inside that block, isMatch property true. shown below (flippedTiles[0].face flippedTiles[1].face) flippedTiles[0].isMatch true; flippedTiles[1].isMatch true; make decision regarding whether flip tiles over with without delay using that property. (var tiles.length; i++) tile tiles[i]; (!tile.isMatch) tile.isFaceUp false; Complete Code import random, pygame, from pygame.locals import Tile function(x, face) this.x this.y this.face face; this.size 50; Tile.prototype.drawFaceDown function() fill(214, 247, 202); strokeWeight(2); rect(this.x, this.y, this.size, this.size, 10); image(getImage("avatars/leaf-green"), this.x, this.y, this.size, this.size); this.isFaceUp false; Tile.prototype.drawFaceUp function() fill(214, 247, 202); strokeWeight(2); rect(this.x, this.y, this.size, this.size, 10); image(this.face, this.x, this.y, this.size, this.size); this.isFaceUp true; Tile.prototype.isUnderMouse function(x, return this.x this.x this.size this.y this.y this.size; Global config NUM_COLS NUM_ROWS Declare array possible faces faces getImage("avatars/leafers-seed"), getImage("avatars/leafers-seedling"), getImage("avatars/leafers-sapling"), getImage("avatars/leafers-tree"), getImage("avatars/leafers-ultimate"), getImage("avatars/marcimus"), getImage("avatars/mr-pants"), getImage("avatars/mr-pink"), getImage("avatars/old-spice-man"), getImage("avatars/robot_female_1") Make array which each, then randomize possibleFaces faces.slice(0); selected (var i++) Randomly pick from array remaining faces randomInd floor(random(possibleFaces.length)); face possibleFaces[randomInd]; Push copies onto array selected.push(face); selected.push(face); Remove from array possibleFaces.splice(randomInd, shuffle elements that array shuffleArray function(array) counter array.length; While there elements array while (counter Pick random index Math.floor(Math.random() counter); Decrease counter counter--; swap last element with temp array[counter]; array[counter] array[ind]; array[ind] temp; shuffleArray(selected); Create tiles tiles (var NUM_COLS; i++) (var NUM_ROWS; j++) tileX tileY tileFace selected.pop(); tiles.push(new Tile(tileX, tileY, tileFace)); background(255, 255, 255); draw them face down (var tiles.length; i++) tiles[i].drawFaceDown(); flippedTiles delayStartFC null; mouseClicked function() (var tiles.length; i++) (tiles[i].isUnderMouse(mouseX, mouseY)) (flippedTiles.length !tiles[i].isFaceUp) tiles[i].drawFaceUp(); flippedTiles.push(tiles[i]); (flippedTiles.length (flippedTiles[0].face flippedTiles[1].face) flippedTiles[0].isMatch true; flippedTiles[1].isMatch true; delayStartFC frameCount; loop(); draw function() (delayStartFC (frameCount delayStartFC) (var tiles.length; i++) (!tiles[i].isMatch) tiles[i].drawFaceDown(); flippedTiles delayStartFC null; noLoop(); Output: Next TopicPython Curl prev next