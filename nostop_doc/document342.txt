next prev Decorators with Parameters Python this tutorial, will discuss Decorators with parameters Python, before starting this topic, users must study Decorators Python, Function Decorators. Decorators very powerful useful tool Python because allows users modify behaviour function class. Python functions treated supreme citizens objects. Functions referenced variable. Functions passed argument other functions. Functions returned from function. Decorators with parameters like normal decorators. Syntax: @decorator(params) function_name(): 	'''Function implementation''' Code Implementation Decorators with Parameters: function_name(): 	'''Function implementation''' function_name (decorator(params))(function_name) execute this code, execution will start from left right, which will call decorator(params) returning function object func_obj. func_obj(function_name) will called using func_obj. Inside inner function, required operations will performed, actual function reference will return assigning function_name. Now, users function_name() call function with decorator applied. Implement Decorators with Parameters: First, will what could output code parameters directly without implementing value. decorators_1(*args, **kwargs): inner_1(func_1): doing operations with func_1 return func_1 return inner_1 this function_object mentioned above content @decorators_1(params) func_1(): function implementation Here, above code, params empty, might some errors. Let's understand this stepwise: decorator_function(function_name): print("Inside Decorator: inner_1(*args, **kwargs): print("Inside Inner Function: print("'Decorated function'") perform this operations with function_name function_name() return inner_1 @decorator_function function_to(): print("Inside actual function") function_to() Output: Inside Decorator: Inside Inner Function: 'Decorated function' Inside actual function Visual Representation Code Execution: Inside Decorator Execution: Inside Inner Function Execution: Decorator Function Execution: Final Output Execution: above code, will outputs from functions called using decorators with parameters. Alternate Way: following code, will write code using decorators functions alternative way. decorator_fun(function_name): print ("Inside Decorator: inner_1(*args, **kwargs): print ("Inside Inner Function: print ("'Decorated function'") Perform this operations with function_name function_name() return inner_1 function_to(): print ("Inside actual function") This another using decorators decorator_fun(function_to)() Output: Inside decorator Inside inner function Decorated function Inside actual function will different examples using decorations with parameter better understanding concept. Example decorator_1(*args, **kwargs): print("Inside Decorator") inner_1(function_1): Here, will functionality code: print ("Inside inner function") print studying kwargs['JTP']) function_1() Returning inner function return inner_1 @decorator_1(JTP "COMPUTER SCIENCE ENGINEERING my_function(): print ("Inside actual function") Output: Inside Decorator Inside inner function studying COMPUTER SCIENCE ENGINEERING Inside actual function Visual Representation Code Execution: Final Output Execution: Example decorator_function(A, Inner_1(function_1): wrapper_1(*args, **kwargs): print studying COMPUTER SCIENCE ENGINEERING print ("Summation values {}".format(A function_1(*args, **kwargs) return wrapper_1 return Inner_1 here, using decorator my_function(*args): args: print (ele) another using decorators decorator_function(22, 14)(my_function)('Computer', 'Science', 'and', 'Engineering') Output: studying COMPUTER SCIENCE ENGINEERING Summation values Computer Science Engineering above example also shows that enclosed inner function access parameters outer function. Visual Representation Code Execution: Example deco_decorator(dataType, message_1, message_2): decorator_1(function_1): print (message_1) wrapper_1(*args, **kwargs): print(message_2) all([type(arg) dataType args]): return function_1(*args, **kwargs) return "Invalid Input" return wrapper_1 return decorator_1 @deco_decorator(str, "Decorator 'string_Join'", "stringJoin process started ...") string_Join(*args): args: return @deco_decorator(int, "Decorator 'summation_1'\n", "summation process started ...") summation_1(*args): summ1 args: summ1 return summ1 print (string_Join("I 'am "studying 'Computer "Science "and "Engineering")) print print ("The equal summation_1(22, 133, 627, 181, 219)) Output: Decorator 'string_Join' Decorator 'summation_1' stringJoin process started studying Computer Science Engineering summation process started equal 1242 Visual Representation Process: Returning decorator_1: Returning wrapper_1: Executing message_1: Executing String_Join: Executing summation_1: Final Output Execution: Conclusion this tutorial, have discussed execute function using decorator with parameters. have also explained examples using visual representation inner functions Outer functions parameters. Next TopicDynamic Typing Python prev next