next prev Building Blockchain using Python Before start building blockchain using Python programming language, back very beginning. 2008, author authors) under pseudonym Satoshi Nakamoto released white paper describing purely peer-to-peer version electronic cash. Exclusive this electronic cash system, transactions wouldn't have depend third-party verifications ensure security every transaction. Instead, every transaction would timestamped, then hashed into ongoing chain proof-of-work based hash. Thus, what hashing proof-of-work? will introduce these concepts following tutorial understand they establish groundwork encrypted electronic cash system cryptocurrency. Satoshi Nakamoto described particular form electronic currency her) paper became Bitcoin, first cryptocurrency. However, this useful when attempting build blockchain using Python? following tutorial, will understand same. Understanding Blockchain system that Bitcoin depends upon growing list records (that blocks) that connected another called Blockchain. Bitcoin first successful application this system, soon after growth fame, other cryptocurrencies were established same beliefs. However, this system limited collecting financial information. Instead, stored type data inconsequential independent Blockchain network. Fundamentally, data stored blockchain should have consisted following characteristics: Immutable Distributed Persistent loss data) Unhackable blockchain open-source application that shared between thousands computers. These computers follow rules order track money that been sent from accounts tied blockchain software. These qualities mandatory order maintain Blockchain's integrity network security within which transactions occur. Every block data that says, instance, "Tom paid Harry $500 Tuesday, 14th." Blockchain, send money without using bank. order illustrate simplicity elegance such system describe nuances, will understand process creating very Blockchain using Python programming language. following project, will only need Python. Also, remember that Blockchain will simplified, high-level introduction. won't building entire Bitcoin blockchain. Instead, will creating functions order blocks, transactions, encryption that data temper-proof. Let's started. Building blockchain Python have divided process building blockchain into several steps better understanding. These steps follows: Step Creating Blockchain class Step Writing Function build Blocks Step Writing Functions create Transactions Last Block Step Writing Function "Hash" Blocks Step Creating Blockchain Sending some money Now, will discuss these steps following sections. Creating Blockchain class will start importing required libraries. this case, will needing hashlib library encryption, JSON library blocks formatting, time library timestamp each block. will then creating class initializing following variables: chain: This will empty list which will blocks. Quite literally, 'blockchain'. pendingTransactions: When users send coins each other, their transactions will locate this array until approve insert them into block. newBlock: This method that will define soon, will utilize order include each block chain. consider following snippet code demonstrating same. Example: importing required libraries import hashlib import json from time import time creating Block_chain class class Block_chain(object): __init__(self): self.chain self.pendingTransactions self.newBlock(previousHash "The Times 03/Jan/2009 Chancellor brink second bailout banks.", the_proof 100) Explanation: above snippet code, have imported required libraries created Block_chain class where initialized different variables described earlier. Writing Function construct Blocks that have initialized empty chain, begin inserting blocks into will then define JSON object with following properties: index: Taking length blockchain adding will this reference individual block, instance, genesis block index timestamp: With help time() module, will stamp block when it's created. Users check when their transaction confirmed on-chain. transactions: transactions that have been 'pending' list will displayed block. proof: This property comes from miner thinks they found valid 'proof' 'nonce'. previous_hash: hashed version most recent approved block. Once above properties block, will include them chain. Initially, empty pending list transactions then block self.chain return understand above using snippet code shown below. Example: Creating block listing key/value pair block information JSON object. Reset list pending transactions append newest block chain. newBlock(self, the_proof, previousHash None): the_block 'index': len(self.chain) 'timestamp': time(), 'transactions': self.pendingTransactions, 'proof': the_proof, 'previous_hash': previousHash self.hash(self.chain[-1]), self.pendingTransactions self.chain.append(the_block) return the_block Explanation: above snippet code, have defined newBlock function included properties described earlier. emptied pending list transactions added block chain. last, have returned block. Writing Functions Create Transactions Last Block Now, include list transactions program because this whole program quite pointless without one. first define method that returns block that added most recently will this second index). After that, will create another method represent transaction. This method will consist three most significant variables the_sender, the_recipient, the_amount. Without these variables included every transaction, users cannot spend, earn, things with newly produced cryptocurrency. Remember that these transactions over-simplified reflect things find true cryptocurrency. will include the_transaction JSON object pool pendingTransactions. These will stay indetermination state until block mined added blockchain. future reference, will return index block which transaction about added. consider following snippet code demonstrating same. Example: #Searching blockchain most recent block. @property lastBlock(self): return self.chain[-1] Adding transaction with relevant info 'blockpool' list pending transactions. newTransaction(self, the_sender, the_recipient, the_amount): the_transaction 'sender': the_sender, 'recipient': the_recipient, 'amount': the_amount self.pendingTransactions.append(the_transaction) return self.lastBlock['index'] Explanation: above snippet code, defined method lastBlock(), which returns most recent block added. have then defined function newTransaction(), within which have defined JSON object the_transaction included addresses sender, recipient, amount. added this JSON object pendingTransaction returned last block. Writing Function "Hash" Blocks Now, Cryptography program. know, Bitcoin many other blockchains utilize SHA-256, encryption hash function, which accepts some text string (stored Unicode value) spits 64-character long encrypted string. blockchain, text that encrypt considered block. instance, encrypted string, "hash", Bitcoin genesis block appears like this: fbc13b85c4ade52e2def26eae950f3b55b174df887ad0f0fb5ebfd56881f7fcb Blockchains considered tamper-proof every block consists copy previous hash block. hash derived from last block, cannot change aspect block without altering every single hash front Suppose that someone downloaded Bitcoin blockchain their computer wrote "Satoshi sends Alex 7,236,000 Bitcoin!" into genesis block broadcasted this Bitcoin network claimed that secret billionaire. However, soon self-respecting miner compares their current copy blockchain, especially hash values stored each block, with copy chain, they will notice that liar, refusing validate network. will define method that accepts block alter key/value pairs into strings. will then convert that string into Unicode, which will pass into SHA256 method from hashlib library create hexadecimal string from return value. will then return hash. understand same using following snippet code. Example: receiving block. Turning into string, turning that into Unicode (for hashing). Hashing with SHA256 encryption, then translating Unicode into hexadecimal string. hash(self, the_block): stringObject json.dumps(the_block, sort_keys True) blockString stringObject.encode() rawHash hashlib.sha256(blockString) hexHash rawHash.hexdigest() return hexHash Explanation: above snippet code, have defined hash() function accepts block turned them into Strings then into Unicode hashing. have then used SHA256() function encryption then translated Unicode into Hexadecimal string. Creating Blockchain Sending some Money Since have created class blockchain included various methods order build block transaction, along with custom method utilized hash block with SHA256 encryption, begin building chain. will initialize instance Block_chain class perform some dummy transactions. Make sure list them some blocks that include chain. consider following snippet code demonstrating same. Example: block_chain Block_chain() transaction1 block_chain.newTransaction("Satoshi", "Alex", BTC') transaction2 block_chain.newTransaction("Alex", "Satoshi", BTC') transaction3 block_chain.newTransaction("Satoshi", "James", BTC') block_chain.newBlock(10123) transaction4 block_chain.newTransaction("Alex", "Lucy", BTC') transaction5 block_chain.newTransaction("Lucy", "Justin", BTC') transaction6 block_chain.newTransaction("Justin", "Alex", BTC') block_chain.newBlock(10384) print("Genesis block: block_chain.chain) Explanation: have instantiated Block_chain() class above snippet code. have then performed some transactions printed them users. Now, have look complete code project building blockchain using Python. Complete Project Code File: buildingBlockchain.py importing required libraries import hashlib import json from time import time creating Block_chain class class Block_chain(object): __init__(self): self.chain self.pendingTransactions self.newBlock(previousHash "The Times 03/Jan/2009 Chancellor brink second bailout banks.", the_proof 100) Creating block listing key/value pairs block information JSON object. Reset list pending transactions append newest block chain. newBlock(self, the_proof, previousHash None): the_block 'index': len(self.chain) 'timestamp': time(), 'transactions': self.pendingTransactions, 'proof': the_proof, 'previous_hash': previousHash self.hash(self.chain[-1]), self.pendingTransactions self.chain.append(the_block) return the_block #Searching blockchain most recent block. @property lastBlock(self): return self.chain[-1] Adding transaction with relevant info 'blockpool' list pending tx's. newTransaction(self, the_sender, the_recipient, the_amount): the_transaction 'sender': the_sender, 'recipient': the_recipient, 'amount': the_amount self.pendingTransactions.append(the_transaction) return self.lastBlock['index'] receiving block. Turning into string, turning that into Unicode (for hashing). Hashing with SHA256 encryption, then translating Unicode into hexidecimal string. hash(self, the_block): stringObject json.dumps(the_block, sort_keys True) blockString stringObject.encode() rawHash hashlib.sha256(blockString) hexHash rawHash.hexdigest() return hexHash block_chain Block_chain() transaction1 block_chain.newTransaction("Satoshi", "Alex", BTC') transaction2 block_chain.newTransaction("Alex", "Satoshi", BTC') transaction3 block_chain.newTransaction("Satoshi", "James", BTC') block_chain.newBlock(10123) transaction4 block_chain.newTransaction("Alex", "Lucy", BTC') transaction5 block_chain.newTransaction("Lucy", "Justin", BTC') transaction6 block_chain.newTransaction("Justin", "Alex", BTC') block_chain.newBlock(10384) print("Genesis block: block_chain.chain) Output: Genesis block: {'index': 'timestamp': 1640067926.584454, 'transactions': 'proof': 100, 'previous_hash': 'The Times 03/Jan/2009 Chancellor brink second bailout banks.'}, {'index': 'timestamp': 1640067926.584454, 'transactions': {'sender': 'Satoshi', 'recipient': 'Alex', 'amount': BTC'}, {'sender': 'Alex', 'recipient': 'Satoshi', 'amount': BTC'}, {'sender': 'Satoshi', 'recipient': 'James', 'amount': BTC'} 'proof': 10123, 'previous_hash': 'a1b0cf063d43989421eb4b28d9be8f82c2e2e9e40bc9814321e3cbb70b00530a'}, {'index': 'timestamp': 1640067926.584454, 'transactions': {'sender': 'Alex', 'recipient': 'Lucy', 'amount': BTC'}, {'sender': 'Lucy', 'recipient': 'Justin', 'amount': BTC'}, {'sender': 'Justin', 'recipient': 'Alex', 'amount': BTC'} 'proof': 10384, 'previous_hash': '23699917fdcc013a85bbb5872251768e976bfcc2cd8403565c04970bca24a871'} Explanation: above output, observe that blockchain contains three blocks right now: genesis block (with index transactions), addition that added ourselves. also notice that encrypted hashes (derived from every preceding block) timestamps match each other. Granted, computer constructed each block almost simultaneously executed program generated blocks almost same time; however, Bitcoin blocks created approximately every minutes. Does anyone notice account balances? Blockchains banks, here good example distinguish between two. cryptocurrency wallet will estimate balance scanning complete chain summing many coins received spent. have rely bank tell amount present account. only trusting network instead mega-corporation. Isn't fascinating? Summing following tutorial, have successfully built blockchain that fill with blocks full transactions cryptocurrency; however, this secure network. First, created block time somebody calls newBlock(), there conditions. newBlock() method requires parameter called proof; however, that anything case. either number string saying, "hello world", literally anything. network Bitcoin, there consensus mechanism place called Proof Work, which illustrates rules which security achieved. proof random number that very difficult find unless have some dedicated high-performance machines working around clock. There many other details missing, such fees miners collect, count transaction, public/private key, Merkle tree structure, more. However, above walkthrough helpful fundamental example moving segments blockchain. Next TopicHuffman Coding using Python prev next